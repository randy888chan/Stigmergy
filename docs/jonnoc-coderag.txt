Directory structure:
└── jonnoc-coderag/
    ├── README.md
    ├── jest.config.js
    ├── LANGUAGE_DETECTION_SUMMARY.md
    ├── LICENSE
    ├── package.json
    ├── tsconfig.json
    ├── .env.example
    ├── docs/
    │   ├── ai-integration.md
    │   ├── available-tools.md
    │   ├── installation-setup.md
    │   ├── list-projects-tool.md
    │   ├── mcp-prompts.md
    │   ├── multi-project-management.md
    │   ├── quality-metrics.md
    │   ├── scanner-usage-examples.md
    │   ├── scanner-usage.md
    │   ├── semantic-search.md
    │   ├── troubleshooting.md
    │   ├── user-guide.md
    │   └── semantic-search/
    │       ├── custom-endpoints.md
    │       ├── IMPLEMENTATION_SUMMARY.md
    │       ├── ollama-setup.md
    │       └── openai-setup.md
    ├── src/
    │   ├── config.ts
    │   ├── index.ts
    │   ├── types.ts
    │   ├── analysis/
    │   │   └── metrics-manager.ts
    │   ├── cli/
    │   │   └── scan.ts
    │   ├── graph/
    │   │   ├── edge-manager.ts
    │   │   ├── neo4j-client.ts
    │   │   └── node-manager.ts
    │   ├── mcp/
    │   │   ├── base-handler.ts
    │   │   ├── http-handler.ts
    │   │   ├── sse-handler.ts
    │   │   ├── stdio-handler.ts
    │   │   └── tools/
    │   │       ├── analyze-testing-annotations.ts
    │   │       ├── edge-management.ts
    │   │       ├── find-deprecated-code.ts
    │   │       ├── find-nodes-by-annotation.ts
    │   │       ├── get-annotation-usage.ts
    │   │       ├── get-framework-usage.ts
    │   │       ├── list-projects.ts
    │   │       ├── metrics-analysis.ts
    │   │       ├── node-management.ts
    │   │       ├── relationship-analysis.ts
    │   │       ├── remote-scanner-tools.ts
    │   │       ├── scanner-tools.ts
    │   │       └── semantic-search.ts
    │   ├── scanner/
    │   │   ├── codebase-scanner.ts
    │   │   ├── types.ts
    │   │   ├── detection/
    │   │   │   ├── build-file-detector.ts
    │   │   │   └── language-detector.ts
    │   │   ├── git/
    │   │   │   ├── git-auth-manager.ts
    │   │   │   ├── git-cache-manager.ts
    │   │   │   ├── git-repository-manager.ts
    │   │   │   ├── git-url-parser.ts
    │   │   │   ├── index.ts
    │   │   │   └── types.ts
    │   │   └── parsers/
    │   │       ├── java-parser.ts
    │   │       ├── python-parser.ts
    │   │       ├── typescript-parser.ts
    │   │       ├── base/
    │   │       │   ├── BaseLanguageParser.ts
    │   │       │   ├── EntityFactory.ts
    │   │       │   └── RelationshipBuilder.ts
    │   │       ├── entity-parsers/
    │   │       │   ├── java/
    │   │       │   │   ├── JavaClassParser.ts
    │   │       │   │   ├── JavaFieldParser.ts
    │   │       │   │   └── JavaMethodParser.ts
    │   │       │   ├── python/
    │   │       │   │   ├── PythonClassParser.ts
    │   │       │   │   └── PythonFunctionParser.ts
    │   │       │   └── typescript/
    │   │       │       └── TypeScriptClassParser.ts
    │   │       ├── extractors/
    │   │       │   ├── base/
    │   │       │   │   ├── AnnotationExtractor.ts
    │   │       │   │   ├── ContentExtractor.ts
    │   │       │   │   ├── DocumentationExtractor.ts
    │   │       │   │   └── MethodCallExtractor.ts
    │   │       │   ├── java/
    │   │       │   │   ├── JavaAnnotationExtractor.ts
    │   │       │   │   ├── JavaContentExtractor.ts
    │   │       │   │   ├── JavaDocExtractor.ts
    │   │       │   │   └── JavaMethodCallExtractor.ts
    │   │       │   ├── python/
    │   │       │   │   ├── DocstringExtractor.ts
    │   │       │   │   ├── PythonAnnotationExtractor.ts
    │   │       │   │   ├── PythonContentExtractor.ts
    │   │       │   │   └── PythonMethodCallExtractor.ts
    │   │       │   └── typescript/
    │   │       │       ├── JsDocExtractor.ts
    │   │       │       ├── TypeScriptAnnotationExtractor.ts
    │   │       │       ├── TypeScriptContentExtractor.ts
    │   │       │       └── TypeScriptMethodCallExtractor.ts
    │   │       └── framework-detection/
    │   │           ├── FrameworkDetectionTypes.ts
    │   │           ├── FrameworkDetector.ts
    │   │           ├── FrameworkModule.ts
    │   │           ├── PythonFrameworkDetector.ts
    │   │           ├── java/
    │   │           │   ├── JavaFrameworkDetector.ts
    │   │           │   └── frameworks/
    │   │           │       ├── AxonFramework.ts
    │   │           │       ├── BeanValidationFramework.ts
    │   │           │       ├── BladeFramework.ts
    │   │           │       ├── CamelFramework.ts
    │   │           │       ├── DropWizardFramework.ts
    │   │           │       ├── GrailsFramework.ts
    │   │           │       ├── GWTFramework.ts
    │   │           │       ├── HibernateFramework.ts
    │   │           │       ├── JavaCoreFramework.ts
    │   │           │       ├── JerseyFramework.ts
    │   │           │       ├── JHipsterFramework.ts
    │   │           │       ├── JPAFramework.ts
    │   │           │       ├── JSFFramework.ts
    │   │           │       ├── JUnitFramework.ts
    │   │           │       ├── LombokFramework.ts
    │   │           │       ├── MicronautFramework.ts
    │   │           │       ├── MockitoFramework.ts
    │   │           │       ├── PlayFramework.ts
    │   │           │       ├── QuarkusFramework.ts
    │   │           │       ├── SparkFramework.ts
    │   │           │       ├── SpringBootFramework.ts
    │   │           │       ├── StrutsFramework.ts
    │   │           │       ├── VaadinFramework.ts
    │   │           │       ├── VertxFramework.ts
    │   │           │       └── WicketFramework.ts
    │   │           └── typescript/
    │   │               ├── TypeScriptFrameworkDetector.ts
    │   │               └── frameworks/
    │   │                   ├── AngularFramework.ts
    │   │                   ├── NestJSFramework.ts
    │   │                   ├── ReactFramework.ts
    │   │                   ├── TypeORMFramework.ts
    │   │                   └── TypeScriptCoreFramework.ts
    │   ├── services/
    │   │   ├── embedding-service.ts
    │   │   └── semantic-search-manager.ts
    │   └── utils/
    │       └── token-limiter.ts
    └── tests/
        ├── config.test.ts
        ├── git-auth-manager.test.ts
        ├── git-cache-manager.test.ts
        ├── git-url-parser.test.ts
        ├── remote-scanner-tools.test.ts
        ├── simple-components.test.ts
        ├── types.test.ts
        ├── analysis/
        │   └── metrics-manager.test.ts
        ├── graph/
        │   ├── edge-manager.test.ts
        │   ├── neo4j-client.test.ts
        │   └── node-manager.test.ts
        ├── mcp/
        │   ├── base-handler.test.ts
        │   └── tools/
        │       ├── analyze-testing-annotations.test.ts
        │       ├── find-deprecated-code.test.ts
        │       ├── find-nodes-by-annotation.test.ts
        │       ├── get-annotation-usage.test.ts
        │       ├── get-framework-usage.test.ts
        │       ├── list-projects-tool.test.ts
        │       ├── mcp-tools-simple.test.ts
        │       ├── node-management-tools.test.ts
        │       ├── scanner-tools.test.ts
        │       └── semantic-search-tools.test.ts
        ├── scanner/
        │   ├── codebase-scanner-enhanced.test.ts
        │   ├── codebase-scanner.test.ts
        │   ├── scanner-simple.test.ts
        │   ├── scanner-types.test.ts
        │   ├── detection/
        │   │   ├── integration.test.ts
        │   │   └── language-detector.test.ts
        │   └── parsers/
        │       ├── java-parser.test.ts
        │       ├── python-parser.test.ts
        │       ├── typescript-parser.test.ts
        │       ├── base/
        │       │   └── base-language-parser.test.ts
        │       └── framework-detection/
        │           └── import-based-detection.test.ts
        └── services/
            ├── embedding-service.test.ts
            └── semantic-search-manager.test.ts

================================================
FILE: README.md
================================================
# CodeRAG - Enterprise Code Intelligence Platform

**Advanced graph-based code analysis for AI-assisted software development**

CodeRAG is a professional code intelligence platform that transforms complex software projects into searchable knowledge graphs. By mapping code structures, dependencies, and relationships, it enables AI development tools to provide contextually accurate assistance for enterprise-scale codebases.

## What CodeRAG Does

CodeRAG creates a comprehensive graph database representation of your codebase using Neo4J, enabling sophisticated analysis and AI-powered insights:

- **Automated Code Analysis** - Scans and maps classes, methods, interfaces, dependencies, and architectural relationships across multiple programming languages
- **Remote Repository Analysis** - Directly analyze any GitHub, GitLab, or Bitbucket repository without local cloning, supporting both public and private repositories with secure authentication
- **Intelligent Language Detection** - Automatically identifies project languages, frameworks, and build configurations from metadata and build files  
- **Quality Assessment** - Calculates industry-standard software metrics (CK metrics, package coupling, architectural patterns) to identify technical debt and improvement opportunities
- **Semantic Code Search** - Enables natural language queries to find code by functionality rather than syntax
- **Multi-Project Management** - Supports enterprise environments with multiple codebases, providing unified analysis and cross-project insights

## Who Should Use CodeRAG

### Enterprise Development Teams
- **Large-scale projects** with complex architectures requiring deep code understanding
- **Legacy system maintenance** where comprehensive codebase mapping is essential
- **Code quality initiatives** needing objective metrics and architectural analysis

### AI-Assisted Development
- **Development teams using AI coding assistants** (Claude Code, GitHub Copilot, Cursor, Windsurf) who need enhanced contextual awareness
- **Code review processes** requiring comprehensive understanding of change impacts
- **Architectural decision-making** supported by data-driven insights

### Software Engineering Leadership
- **Technical leads** managing code quality and architectural compliance
- **Engineering managers** tracking technical debt and team productivity
- **Architects** designing and maintaining system boundaries and dependencies

## Key Use Cases

### Code Review Enhancement
Provide AI assistants with comprehensive codebase context, enabling more accurate suggestions and impact analysis during code reviews.

### Onboarding Acceleration  
Help new team members quickly understand complex codebases through interactive exploration and relationship mapping.

### Technical Debt Management
Identify architectural issues, code smells, and coupling problems with objective metrics and actionable insights.

### Legacy System Modernization
Map existing system architectures and dependencies to inform refactoring strategies and modernization planning.

### Architectural Compliance
Monitor adherence to architectural principles and detect violations or degradation over time.

## Supported Technologies

### Programming Languages
- **TypeScript** and **JavaScript** - Full ES6+ support with framework detection
- **Java** - Comprehensive analysis including Spring Boot ecosystem
- **Python** - Complete support with framework identification
- **C#** *(planned)* - .NET ecosystem support in development

### Enterprise Frameworks
- **Spring Boot**, **Spring Framework** - Java enterprise applications
- **React**, **Angular**, **Vue.js** - Modern frontend frameworks  
- **NestJS**, **Express** - Node.js backend frameworks
- **Django**, **FastAPI** - Python web frameworks

## Getting Started

Ready to enhance your development workflow with intelligent code analysis? Our comprehensive [User Guide](docs/user-guide.md) provides everything you need to set up and integrate CodeRAG with your development environment.

## Enterprise Features

### Multi-Project Management
- **Project Isolation** - Separate analysis for different codebases with unified management
- **Cross-Project Analysis** - Compare metrics and patterns across multiple projects
- **Remote Repository Support** - Scan public and private repositories from GitHub, GitLab, and Bitbucket directly
- **Bulk Operations** - Efficient scanning and analysis of multiple repositories

### Quality Metrics
- **CK Metrics Suite** - Weighted Methods per Class, Coupling Between Objects, Response for Class
- **Package Metrics** - Afferent/Efferent Coupling, Instability, Abstractness
- **Architectural Analysis** - Circular dependency detection, design pattern identification

### Advanced Search Capabilities  
- **Semantic Search** - Natural language queries powered by AI embeddings
- **Relationship Mapping** - Trace dependencies, inheritance hierarchies, and method calls
- **Pattern Detection** - Identify design patterns and architectural structures

## Documentation

### Getting Started
- **[Installation & Setup Guide](docs/installation-setup.md)** - Comprehensive setup instructions
- **[AI Integration Guide](docs/ai-integration.md)** - Connect to Claude Code, Cursor, Windsurf, and other AI tools
- **[User Guide](docs/user-guide.md)** - Complete feature overview and workflows

### Advanced Usage
- **[Scanner Usage](docs/scanner-usage.md)** - Detailed scanning options and project analysis
- **[Quality Metrics](docs/quality-metrics.md)** - Understanding and interpreting code quality measurements  
- **[Multi-Project Management](docs/multi-project-management.md)** - Enterprise-scale project organization
- **[Semantic Search](docs/semantic-search.md)** - Natural language code discovery

### Reference
- **[Available Tools](docs/available-tools.md)** - Complete API reference for all 23 analysis tools
- **[Troubleshooting](docs/troubleshooting.md)** - Common issues and solutions

## Professional Support

CodeRAG is designed for professional software development environments. The platform provides:

- **Comprehensive Documentation** - Detailed guides for setup, integration, and advanced usage
- **Enterprise Architecture** - Scalable design supporting large codebases and multiple projects  
- **Quality Assurance** - Extensive test suite with 402+ tests ensuring reliability
- **Open Source** - MIT licensed with transparent development and community contributions

## Contributing

We welcome contributions from the software development community. Please review our contributing guidelines and submit pull requests to help improve CodeRAG's capabilities.

## License

MIT License - see [LICENSE](LICENSE) for complete terms.

---

**Ready to enhance your AI-assisted development workflow?** Start with our [Installation & Setup Guide](docs/installation-setup.md) to begin analyzing your codebase in minutes.


================================================
FILE: jest.config.js
================================================
export default {
  preset: 'ts-jest/presets/default-esm',
  extensionsToTreatAsEsm: ['.ts'],
  testEnvironment: 'node',
  testMatch: ['**/__tests__/**/*.ts', '**/?(*.)+(spec|test).ts'],
  transform: {
    '^.+\\.ts$': ['ts-jest', {
      useESM: true,
      tsconfig: {
        module: 'esnext'
      }
    }]
  },
  moduleNameMapper: {
    '^(\\.{1,2}/.*)\\.js$': '$1'
  },
  collectCoverage: true,
  coverageDirectory: 'coverage',
  coverageReporters: ['text', 'lcov', 'html']
};


================================================
FILE: LANGUAGE_DETECTION_SUMMARY.md
================================================
# Automatic Language Detection Feature Summary

## 🎯 Overview

Successfully implemented comprehensive automatic language detection for the CodeRAG scanner, eliminating the need for manual project type specification while adding intelligent project analysis capabilities.

## ✅ Implementation Completed

### 🔧 Core Components

1. **ProjectBuildFileDetector** (`src/scanner/detection/build-file-detector.ts`)
   - Detects and analyzes multiple build file types
   - Extracts project metadata (name, version, description, dependencies)
   - Supports: package.json, pom.xml, build.gradle, setup.py, pyproject.toml, *.csproj

2. **ProjectLanguageDetector** (`src/scanner/detection/language-detector.ts`)
   - Coordinates between build file and file extension detection
   - Provides intelligent recommendations for scan configuration
   - Handles multi-language projects and mono-repositories

3. **Enhanced Types** (`src/scanner/types.ts`)
   - New interfaces for ProjectMetadata, ProjectDetectionResult
   - Support for build systems, frameworks, and sub-projects
   - Comprehensive type safety throughout detection system

### 🌟 Key Features

- **🔍 Build File Analysis**: Automatically detects languages from build files
- **📊 Project Metadata Extraction**: Extracts name, version, description, dependencies
- **🏗️ Framework Detection**: Identifies React, Spring Boot, Django, Express, etc.
- **🔄 Multi-Language Support**: Handles complex projects (TypeScript + Java + Python)
- **🏢 Mono-Repository Detection**: Discovers and manages sub-projects
- **🎯 Intelligent Fallback**: Uses file extensions when build files unavailable
- **⚙️ Manual Override**: Allows language specification when needed

### 📋 Enhanced CodebaseScanner

- **Auto-Detection Integration**: `validateProjectStructure()` uses new detection system
- **Smart Recommendations**: `getRecommendedScanConfig()` provides intelligent suggestions
- **Language-Specific Optimizations**: Tailored exclude paths per framework
- **Enhanced CLI Experience**: Rich project information display

### 🧪 Comprehensive Testing

- **402 tests passing** across 31 test suites
- **97.91% coverage** for ProjectLanguageDetector
- **Unit tests** for all detection components
- **Integration tests** for component interaction
- **Enhanced scanner tests** with comprehensive mocking

## 🚀 Usage Examples

### Before (Manual)
```bash
npm run scan /path/to/project -- --languages typescript,java
```

### After (Automatic)
```bash
npm run scan /path/to/project
# Output: ✅ Multi-language project detected: TypeScript (frontend), Java (backend)
# Framework: React + Spring Boot, Build systems: npm + Maven
```

## 📖 Documentation Updates

Updated comprehensive documentation in:
- **README.md**: Highlights new auto-detection capabilities
- **docs/user-guide.md**: Updated workflows and examples
- **docs/scanner-usage.md**: Detailed auto-detection guide
- **docs/multi-project-management.md**: Multi-language project examples
- **CLAUDE.md**: Implementation status and feature descriptions

## 🎯 Benefits

1. **Zero Configuration**: Works out-of-the-box for most projects
2. **Intelligent Analysis**: Extracts valuable project metadata automatically
3. **Multi-Language Support**: Handles complex real-world project structures
4. **Better User Experience**: Rich feedback and intelligent suggestions
5. **Framework Awareness**: Optimizes scanning based on detected frameworks
6. **Mono-Repository Ready**: Handles complex organizational structures

## 🔮 Future Enhancements

- Additional build file formats (CMake, Cargo.toml, go.mod)
- Enhanced framework detection (Vue.js, Angular, Flask, etc.)
- Project dependency graph analysis
- Cross-project relationship detection in mono-repositories

---

**Status**: ✅ **COMPLETED** - Feature is fully implemented, tested, and documented.
**Tests**: 402 passing, 0 failing
**Coverage**: High coverage across all detection components
**Documentation**: Comprehensive updates across all user-facing docs


================================================
FILE: LICENSE
================================================
MIT License

Copyright (c) 2025 Jonathan Crabtree

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


================================================
FILE: package.json
================================================
{
  "name": "coderag",
  "version": "1.0.0",
  "description": "MCP Server for Neo4J GraphRAG - stores and retrieves rich code metadata in graph format",
  "main": "build/index.js",
  "type": "module",
  "bin": {
    "coderag-scan": "build/cli/scan.js"
  },
  "scripts": {
    "build": "tsc",
    "dev": "tsx src/index.ts",
    "start": "node build/index.js",
    "scan": "tsx src/cli/scan.ts",
    "scan:built": "node build/cli/scan.js",
    "test": "jest",
    "lint": "eslint src/**/*.ts",
    "typecheck": "tsc --noEmit"
  },
  "keywords": [
    "mcp",
    "model-context-protocol",
    "neo4j",
    "graphrag",
    "code-analysis"
  ],
  "author": "",
  "license": "MIT",
  "dependencies": {
    "@modelcontextprotocol/sdk": "^1.12.1",
    "@types/tmp": "^0.2.6",
    "@typescript-eslint/parser": "^6.13.0",
    "@typescript-eslint/types": "^6.21.0",
    "commander": "^11.1.0",
    "dotenv": "^16.4.5",
    "express": "^4.18.2",
    "glob": "^10.3.10",
    "neo4j-driver": "^5.25.0",
    "openai": "^5.3.0",
    "simple-git": "^3.28.0",
    "tmp": "^0.2.3",
    "zod": "^3.22.4"
  },
  "devDependencies": {
    "@types/express": "^4.17.21",
    "@types/jest": "^29.5.8",
    "@types/node": "^20.10.0",
    "@typescript-eslint/eslint-plugin": "^6.13.0",
    "@typescript-eslint/parser": "^6.13.0",
    "eslint": "^8.54.0",
    "jest": "^29.7.0",
    "ts-jest": "^29.1.1",
    "tsx": "^4.6.0",
    "typescript": "^5.3.0"
  },
  "files": [
    "build"
  ]
}



================================================
FILE: tsconfig.json
================================================
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "Node16",
    "moduleResolution": "Node16",
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "declaration": true,
    "outDir": "./build",
    "rootDir": "./src",
    "resolveJsonModule": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "isolatedModules": true,
    "lib": ["ES2022", "DOM"]
  },
  "include": [
    "src/**/*"
  ],
  "exclude": [
    "node_modules",
    "build",
    "**/*.test.ts"
  ]
}


================================================
FILE: .env.example
================================================
# Neo4j Database Configuration
NEO4J_URI=bolt://localhost:7687
NEO4J_USER=neo4j
NEO4J_PASSWORD=your_password

# Project Configuration
PROJECT_ISOLATION_STRATEGY=shared_db
DEFAULT_PROJECT_ID=default
CROSS_PROJECT_ANALYSIS=false
MAX_PROJECTS_SHARED_DB=100

# Semantic Search Configuration
# Options: openai, ollama, disabled
SEMANTIC_SEARCH_PROVIDER=openai

# ============================================
# OPENAI PROVIDER CONFIGURATION
# ============================================
# Required if SEMANTIC_SEARCH_PROVIDER=openai
OPENAI_API_KEY=sk-your-openai-api-key-here

# Optional: Custom OpenAI API base URL (for LLM Studio, Azure OpenAI, etc.)
# OPENAI_BASE_URL=http://localhost:1234/v1

# ============================================
# OLLAMA PROVIDER CONFIGURATION  
# ============================================
# Required if SEMANTIC_SEARCH_PROVIDER=ollama
# OLLAMA_BASE_URL=http://localhost:11434

# ============================================
# UNIFIED MODEL CONFIGURATION
# ============================================
# Model name - auto-detected defaults based on provider:
# OpenAI: text-embedding-3-small, text-embedding-3-large, text-embedding-ada-002
# Ollama: nomic-embed-text, mxbai-embed-large
EMBEDDING_MODEL=text-embedding-3-small

# Optional: Override default dimensions (auto-detected based on model and provider)
# OpenAI text-embedding-3-small: 1536, text-embedding-3-large: 3072
# Ollama nomic-embed-text: 768, mxbai-embed-large: 1024
# EMBEDDING_DIMENSIONS=1536

# ============================================
# PROCESSING CONFIGURATION
# ============================================
EMBEDDING_MAX_TOKENS=8000
EMBEDDING_BATCH_SIZE=100
SIMILARITY_THRESHOLD=0.7

# MCP Response Configuration
# Maximum tokens for MCP tool responses (default: 10000)
MCP_TOKEN_LIMIT=10000


================================================
FILE: docs/ai-integration.md
================================================
# AI Tool Integration Guide

CodeRAG integrates with AI coding assistants through two connection methods:

## 🌟 SSE Mode (Recommended)
**Full MCP tools + REST API + Web-friendly**
- All 24 MCP tools via HTTP Server-Sent Events
- Additional REST API endpoints for direct access
- Works with web-based tools and modern MCP clients
- Better for production deployments

## STDIO Mode  
**Traditional MCP via stdin/stdout**
- Direct process communication
- Simpler for basic setups
- Limited to command-line MCP clients

---

## Quick Start with Claude Code

### SSE Mode (Recommended)

**Step 1: Start CodeRAG Server**
```bash
npm start -- --sse --port 3000
```

**Step 2: Configure Claude Code**

Add to your MCP configuration file:
- **macOS/Linux:** `~/.claude/mcp_servers.json`
- **Windows:** `%APPDATA%\Claude\mcp_servers.json`

```json
{
  "mcpServers": {
    "coderag": {
      "url": "http://localhost:3000/sse",
      "transport": "sse",
      "env": {
        "NEO4J_URI": "bolt://localhost:7687",
        "NEO4J_USER": "neo4j",
        "NEO4J_PASSWORD": "your_password"
      }
    }
  }
}
```

**Step 3: Restart Claude Code**

Test the connection:
```
Use the get_project_summary tool to show me an overview of my codebase.
```

**Example Workflow - Analyzing a Remote Repository:**
```
# Scan a remote repository
Use scan_remote_repo to analyze https://github.com/microsoft/vscode.git

# Get project overview
Use get_project_summary to show the codebase structure

# Find architectural issues
Use find_architectural_issues to identify potential problems

# Analyze key classes
Use search_nodes to find classes containing "Editor" and then use calculate_ck_metrics on interesting classes
```

### STDIO Mode (Alternative)

**Step 1: Configure Claude Code**
```json
{
  "mcpServers": {
    "coderag": {
      "command": "node",
      "args": ["/path/to/CodeRAG/build/index.js"],
      "env": {
        "NEO4J_URI": "bolt://localhost:7687",
        "NEO4J_USER": "neo4j",
        "NEO4J_PASSWORD": "your_password"
      }
    }
  }
}
```

**Step 2: Restart Claude Code**

---

## Tool Integration by Platform

### Windsurf

**SSE Mode (Recommended)**
1. Start CodeRAG: `npm start -- --sse --port 3000`
2. Configure Windsurf MCP settings:
```json
{
  "servers": {
    "coderag": {
      "url": "http://localhost:3000/sse",
      "transport": "sse",
      "env": {
        "NEO4J_URI": "bolt://localhost:7687",
        "NEO4J_USER": "neo4j",
        "NEO4J_PASSWORD": "your_password"
      }
    }
  }
}
```

**STDIO Mode (Alternative)**
```json
{
  "servers": {
    "coderag": {
      "command": "node",
      "args": ["/path/to/CodeRAG/build/index.js"],
      "cwd": "/path/to/CodeRAG",
      "env": {
        "NEO4J_URI": "bolt://localhost:7687",
        "NEO4J_USER": "neo4j",
        "NEO4J_PASSWORD": "your_password"
      }
    }
  }
}
```

### Cursor

**SSE Mode (Recommended)**
1. Start CodeRAG: `npm start -- --sse --port 3000`
2. Configure Cursor MCP settings:
```json
{
  "mcpServers": {
    "coderag": {
      "url": "http://localhost:3000/sse",
      "transport": "sse",
      "env": {
        "NEO4J_URI": "bolt://localhost:7687",
        "NEO4J_USER": "neo4j",
        "NEO4J_PASSWORD": "your_password"
      }
    }
  }
}
```

**STDIO Mode (Alternative)**
```json
{
  "mcpServers": {
    "coderag": {
      "command": "node",
      "args": ["/path/to/CodeRAG/build/index.js"],
      "env": {
        "NEO4J_URI": "bolt://localhost:7687",
        "NEO4J_USER": "neo4j",
        "NEO4J_PASSWORD": "your_password"
      }
    }
  }
}
```

### VS Code (Native MCP Support)

VS Code now supports MCP servers natively without requiring Continue.dev or other extensions.

> **Requirements:** VS Code version 1.99+ (March 2025) with GitHub Copilot extension

**SSE Mode (Recommended)**
1. Start CodeRAG: `npm start -- --sse --port 3000`
2. Create `.vscode/mcp.json` in your workspace:
```json
{
  "inputs": [
    {
      "type": "promptString",
      "id": "neo4j-password",
      "description": "Neo4J Database Password",
      "password": true
    }
  ],
  "servers": {
    "coderag": {
      "type": "sse",
      "url": "http://localhost:3000/sse",
      "env": {
        "NEO4J_URI": "bolt://localhost:7687",
        "NEO4J_USER": "neo4j",
        "NEO4J_PASSWORD": "${input:neo4j-password}"
      }
    }
  }
}
```

**STDIO Mode (Alternative)**
Create `.vscode/mcp.json` in your workspace:
```json
{
  "inputs": [
    {
      "type": "promptString",
      "id": "neo4j-password",
      "description": "Neo4J Database Password",
      "password": true
    }
  ],
  "servers": {
    "coderag": {
      "type": "stdio",
      "command": "node",
      "args": ["/path/to/CodeRAG/build/index.js"],
      "env": {
        "NEO4J_URI": "bolt://localhost:7687",
        "NEO4J_USER": "neo4j",
        "NEO4J_PASSWORD": "${input:neo4j-password}"
      }
    }
  }
}
```

**User Settings (Global Configuration)**
Alternatively, add to your VS Code user settings (`settings.json`):
```json
{
  "mcp": {
    "servers": {
      "coderag": {
        "type": "sse",
        "url": "http://localhost:3000/sse",
        "env": {
          "NEO4J_URI": "bolt://localhost:7687",
          "NEO4J_USER": "neo4j",
          "NEO4J_PASSWORD": "your_password"
        }
      }
    }
  }
}
```

**Automatic Discovery (Optional)**
VS Code can automatically discover MCP servers from other tools:
1. Enable: `"chat.mcp.discovery.enabled": true` in settings
2. VS Code will find servers configured in Claude Desktop and other MCP clients

**Using CodeRAG in VS Code**
1. Open GitHub Copilot Chat
2. Use the **MCP: List Servers** command to verify CodeRAG is connected
3. Start using CodeRAG tools: "Use CodeRAG to analyze my project structure"

---

## Available Tools & Endpoints

### MCP Tools (24 Available)
When connected via MCP (SSE or STDIO), you get access to all CodeRAG tools:

**Core Analysis:**
- `get_project_summary` - Project overview and metrics
- `scan_dir` - Scan local codebase and populate graph
- `scan_remote_repo` - Scan remote repositories (GitHub, GitLab, Bitbucket)
- `find_architectural_issues` - Detect design problems

**Code Structure:**
- `search_nodes` - Find classes, methods, interfaces
- `find_nodes_by_type` - Filter by entity type
- `get_inheritance_hierarchy` - Class inheritance chains

**Quality Metrics:**
- `calculate_ck_metrics` - Class complexity metrics
- `calculate_package_metrics` - Package design metrics
- `find_deprecated_code` - Locate deprecated elements

**Framework Analysis:**
- `find_nodes_by_annotation` - Find annotated code
- `get_framework_usage` - Framework usage statistics
- `analyze_testing_annotations` - Test coverage analysis

### REST API Endpoints (SSE Mode Only)
Direct HTTP access when using SSE mode:

| Method | Endpoint | Description |
|--------|----------|-------------|
| GET | `/health` | Server health check |
| GET | `/api/metrics/summary` | Project summary |
| GET | `/api/metrics/issues` | Architectural issues |
| GET | `/api/nodes?type=class` | Find classes |
| GET | `/api/nodes?search=UserService` | Search entities |
| POST | `/api/parse/directory` | Scan codebase |

**Example REST Usage:**
```bash
# Get project summary
curl http://localhost:3000/api/metrics/summary

# Scan current directory
curl -X POST http://localhost:3000/api/parse/directory \
  -H "Content-Type: application/json" \
  -d '{
    "project": "my-project",
    "directory_path": ".",
    "clear_existing": true
  }'

# Scan remote repository
curl -X POST http://localhost:3000/api/scan/remote \
  -H "Content-Type: application/json" \
  -d '{
    "repository_url": "https://github.com/owner/repo.git",
    "branch": "main",
    "clear_existing": true
  }'
```

---

## Environment Configuration

Both modes require these environment variables:

```bash
NEO4J_URI=bolt://localhost:7687
NEO4J_USER=neo4j
NEO4J_PASSWORD=your_password
```

**Optional - Remote Repository Authentication:**
```bash
# GitHub
GITHUB_TOKEN=ghp_xxxxxxxxxxxxxxxx

# GitLab
GITLAB_TOKEN=glpat-xxxxxxxxxxxxxxxx
GITLAB_HOST=gitlab.company.com  # Optional, for self-hosted GitLab

# Bitbucket
BITBUCKET_USERNAME=your_username
BITBUCKET_APP_PASSWORD=your_app_password
```

Set them either:
1. In your shell: `export NEO4J_PASSWORD=yourpassword`
2. In a `.env` file in the CodeRAG directory
3. In the MCP configuration (as shown above)

---

## Troubleshooting

### Common Issues

**"Neo4J connection failed"**
- Verify Neo4J is running: `docker ps` or check Neo4J Desktop
- Test connection: `curl http://localhost:7474`
- Check credentials in configuration

**"CodeRAG tools not available"**
- Restart your MCP client after configuration changes
- Check the MCP configuration file path
- Verify CodeRAG server is running (SSE mode)
- VS Code: Use **MCP: List Servers** command to verify connection
- VS Code: Ensure GitHub Copilot extension is enabled

**"Port already in use" (SSE mode)**
- Change port: `npm start -- --sse --port 3001`
- Update configurations to use the new port

### Getting Help

1. Check server logs for error messages
2. Test with basic tools like `get_project_summary`
3. Verify Neo4J database has data (scan a project first)

---

## Next Steps

- **[Scanner Usage](scanner-usage.md)** - Learn how to scan your codebase
- **[Available Tools](available-tools.md)** - Explore all CodeRAG tools
- **[MCP Prompts Guide](mcp-prompts.md)** - Use guided prompts for effective analysis


================================================
FILE: docs/available-tools.md
================================================
# Available Tools Reference

CodeRAG provides 23 powerful tools for code analysis:

## Core CRUD Operations

### `add_node`
**Description:** Add a new code node (class, method, field, etc.)

**Parameters:**
- `type`: Node type (class, method, interface, field, package)
- `id`: Unique identifier
- `name`: Display name
- `properties`: Additional properties object
- `project_id`: Project identifier (optional, auto-detected if single project)

**Example:**
```json
{
  "type": "class",
  "id": "com.example.UserService",
  "name": "UserService", 
  "properties": {
    "package": "com.example",
    "access_modifier": "public",
    "is_abstract": false
  }
}
```

### `update_node`
**Description:** Update an existing node's properties

**Parameters:**
- `node_id`: ID of node to update
- `properties`: Properties to update
- `project_id`: Project identifier (optional)

### `get_node`
**Description:** Retrieve a node by ID

**Parameters:**
- `node_id`: Unique node identifier
- `project_id`: Project identifier (optional)

### `delete_node`
**Description:** Delete a node and its relationships

**Parameters:**
- `node_id`: ID of node to delete
- `project_id`: Project identifier (optional)

### `add_edge`
**Description:** Add a relationship edge between nodes

**Parameters:**
- `source_id`: Source node ID
- `target_id`: Target node ID
- `relationship_type`: Type of relationship (extends, implements, calls, etc.)
- `properties`: Additional edge properties
- `project_id`: Project identifier (optional)

**Common relationship types:**
- `EXTENDS`: Inheritance
- `IMPLEMENTS`: Interface implementation
- `CALLS`: Method/function calls
- `REFERENCES`: Field/variable references
- `CONTAINS`: Containment (class contains method)
- `BELONGS_TO`: Package membership

### `get_edge`
**Description:** Retrieve an edge by ID

**Parameters:**
- `edge_id`: Unique edge identifier
- `project_id`: Project identifier (optional)

### `delete_edge`
**Description:** Delete a relationship edge

**Parameters:**
- `edge_id`: ID of edge to delete
- `project_id`: Project identifier (optional)

## Search & Discovery

### `find_nodes_by_type`
**Description:** Find all nodes of a specific type

**Parameters:**
- `node_type`: Type to search for (class, interface, method, field, package)
- `limit`: Maximum results to return (default: 100)
- `project_id`: Project identifier (optional)

**Example:**
```json
{
  "node_type": "class",
  "limit": 50,
  "project_id": "my-project"
}
```

### `search_nodes`
**Description:** Search nodes by name or description

**Parameters:**
- `search_term`: Text to search for
- `node_type`: Optional type filter
- `limit`: Maximum results (default: 100)
- `project_id`: Project identifier (optional)

**Search capabilities:**
- Partial name matching
- Case-insensitive search
- Searches name and description fields
- Supports wildcard patterns

### `find_edges_by_source`
**Description:** Find all edges from a source node

**Parameters:**
- `source_node_id`: Source node identifier
- `relationship_type`: Optional relationship filter
- `limit`: Maximum results (default: 100)
- `project_id`: Project identifier (optional)

## Semantic Search

### `semantic_search`
**Description:** Search for code using natural language queries to find functionality by meaning

**Parameters:**
- `query`: Natural language description of functionality to search for
- `project_id`: Optional project identifier to scope search
- `node_types`: Optional array of node types to filter (class, method, function, etc.)
- `limit`: Maximum results (default: 10)
- `similarity_threshold`: Minimum similarity score 0.0-1.0 (default: 0.7)
- `include_graph_context`: Include related entities in results (default: false)
- `max_hops`: Maximum relationship hops for context (default: 2)

**Example:**
```json
{
  "query": "functions that validate email addresses",
  "project_id": "my-web-app",
  "node_types": ["function", "method"],
  "limit": 5,
  "similarity_threshold": 0.8,
  "include_graph_context": true
}
```

### `get_similar_code`
**Description:** Find code entities semantically similar to a specific node

**Parameters:**
- `node_id`: ID of the reference code entity
- `project_id`: Project containing the reference node
- `limit`: Maximum results (default: 5)

**Example:**
```json
{
  "node_id": "UserValidator.validateEmail",
  "project_id": "my-web-app",
  "limit": 10
}
```

### `update_embeddings`
**Description:** Generate or refresh semantic embeddings for code entities

**Parameters:**
- `project_id`: Optional project identifier to scope update
- `node_types`: Optional array of node types to update

**Example:**
```json
{
  "project_id": "my-web-app",
  "node_types": ["class", "method", "function"]
}
```

### `initialize_semantic_search`
**Description:** Initialize semantic search infrastructure and vector indexes

**Parameters:** None

**Usage:** Run once per database to set up vector search capabilities

## Relationship Analysis

### `find_classes_calling_method`
**Description:** Find classes that call a specific method

**Parameters:**
- `method_name`: Name of the method to search for
- `target_class`: Optional class that owns the method
- `project_id`: Project identifier (optional)

**Use cases:**
- Impact analysis for method changes
- Finding usage patterns
- Dependency analysis
- Refactoring planning

### `find_classes_implementing_interface`
**Description:** Find classes implementing an interface

**Parameters:**
- `interface_name`: Name of the interface
- `project_id`: Project identifier (optional)

**Returns:**
- List of implementing classes
- Implementation details
- Inheritance hierarchy information

### `get_inheritance_hierarchy`
**Description:** Get complete inheritance hierarchy for a class

**Parameters:**
- `class_name`: Name of the class
- `direction`: "up" (ancestors), "down" (descendants), or "both" (default)
- `max_depth`: Maximum hierarchy depth (default: 10)
- `project_id`: Project identifier (optional)

**Output format:**
```json
{
  "root_class": "BaseEntity",
  "hierarchy": {
    "ancestors": [
      {"name": "Object", "depth": 0},
      {"name": "BaseEntity", "depth": 1}
    ],
    "descendants": [
      {"name": "User", "depth": 1},
      {"name": "Product", "depth": 1},
      {"name": "AdminUser", "depth": 2}
    ]
  }
}
```

## Quality & Metrics

### `calculate_ck_metrics`
**Description:** Calculate Chidamber & Kemerer metrics for a class

**Parameters:**
- `class_id`: Unique class identifier
- `project_id`: Project identifier (optional)

**Metrics calculated:**
- **WMC** (Weighted Methods per Class): Complexity measure
- **DIT** (Depth of Inheritance Tree): Inheritance depth
- **NOC** (Number of Children): Direct subclasses
- **CBO** (Coupling Between Objects): Class dependencies
- **RFC** (Response for Class): Total method calls
- **LCOM** (Lack of Cohesion in Methods): Method cohesion

**Output includes:**
- Raw metric values
- Quality classifications (Good/Warning/Critical)
- Interpretation guidance
- Improvement recommendations

### `calculate_package_metrics`
**Description:** Calculate package-level metrics

**Parameters:**
- `package_name`: Package/module name
- `project_id`: Project identifier (optional)

**Metrics calculated:**
- **Ca** (Afferent Coupling): Incoming dependencies
- **Ce** (Efferent Coupling): Outgoing dependencies
- **I** (Instability): Change resilience (Ce/(Ca+Ce))
- **A** (Abstractness): Abstract classes ratio
- **D** (Distance from Main Sequence): Balance measure

### `find_architectural_issues`
**Description:** Detect architectural problems

**Parameters:**
- `project_id`: Project identifier (optional)
- `severity`: Filter by severity (low, medium, high, critical)

**Issues detected:**
- **Circular Dependencies**: Package dependency cycles
- **God Classes**: Classes with excessive responsibilities
- **High Coupling**: Classes with too many dependencies
- **Unstable Dependencies**: Architectural violations
- **Dead Code**: Unused classes and methods
- **Long Parameter Lists**: Methods with too many parameters

### `get_project_summary`
**Description:** Get overall project quality summary

**Parameters:**
- `project_id`: Project identifier (optional)
- `include_metrics`: Include detailed metrics (default: true)

**Summary includes:**
- Entity counts by type
- Relationship statistics
- Quality score and grade
- Top architectural issues
- Recommendations for improvement
- Trend analysis (if historical data available)

## Scanning Tools

### `add_file`
**Description:** Parse and add a single source file

**Parameters:**
- `file_path`: Absolute path to source file
- `language`: Programming language (optional, auto-detected)
- `clear_existing`: Clear existing file data (default: false)
- `project_id`: Project identifier (optional)

**Supported languages:**
- TypeScript (`.ts`, `.tsx`)
- JavaScript (`.js`, `.jsx`)
- Java (`.java`)
- Python (`.py`)

### `scan_dir`
**Description:** Scan entire directory/project

**Parameters:**
- `directory_path`: Path to project root
- `languages`: Array of languages to scan (optional, auto-detected)
- `exclude_paths`: Directories to exclude (default: ["node_modules", "dist", "build"])
- `include_tests`: Include test files (default: false)
- `clear_existing`: Clear existing project data (default: false)
- `max_depth`: Maximum directory depth (default: 10)
- `project_id`: Project identifier (optional, derived from directory name)

**Example:**
```json
{
  "directory_path": "/path/to/my-project",
  "languages": ["typescript", "javascript"],
  "exclude_paths": ["node_modules", "dist", "coverage"],
  "include_tests": true,
  "clear_existing": true,
  "max_depth": 8
}
```

## Multi-Project Management

### `list_projects`
**Description:** List all projects with optional statistics and filtering

**Parameters:**
- `include_stats`: Include entity/relationship counts (default: false)
- `sort_by`: Sort criteria (name, created_at, updated_at, entity_count)
- `limit`: Maximum projects to return (1-1000, default: 100)
- `name_filter`: Filter projects by name pattern (optional)

**Example:**
```json
{
  "include_stats": true,
  "sort_by": "entity_count",
  "limit": 20,
  "name_filter": "*service*"
}
```

**Output includes:**
- Project metadata (ID, name, description)
- Creation and update timestamps
- Entity and relationship statistics
- Supported languages
- Quality summary

## Tool Usage Patterns

### 1. Initial Project Analysis

```bash
# 1. Scan the project
scan_dir -> directory_path: "/path/to/project"

# 2. Get overview
get_project_summary

# 3. Find issues
find_architectural_issues

# 4. Analyze key classes
calculate_ck_metrics -> class_id: "com.example.UserService"
```

### 2. Dependency Investigation

```bash
# 1. Find the class
search_nodes -> search_term: "UserService"

# 2. Get its dependencies
find_edges_by_source -> source_node_id: "com.example.UserService"

# 3. Find what depends on it
find_classes_calling_method -> method_name: "authenticate"

# 4. Calculate coupling metrics
calculate_ck_metrics -> class_id: "com.example.UserService"
```

### 3. Architecture Analysis

```bash
# 1. Map inheritance hierarchies
get_inheritance_hierarchy -> class_name: "BaseEntity"

# 2. Find interface implementations
find_classes_implementing_interface -> interface_name: "Repository"

# 3. Analyze package structure
calculate_package_metrics -> package_name: "com.example.service"

# 4. Identify architectural issues
find_architectural_issues
```

### 4. Multi-Project Management

```bash
# 1. List all projects
list_projects -> include_stats: true

# 2. Compare projects
get_project_summary -> project_id: "project-a"
get_project_summary -> project_id: "project-b"

# 3. Cross-project analysis
search_nodes -> search_term: "Controller"  # Searches all projects
```

### 5. Semantic Code Discovery

```bash
# 1. Initialize semantic search (one-time setup)
initialize_semantic_search

# 2. Generate embeddings for existing project
update_embeddings -> project_id: "my-project"

# 3. Search by functionality
semantic_search -> query: "functions that validate email addresses"

# 4. Find similar code
get_similar_code -> node_id: "UserValidator.validateEmail", project_id: "my-project"

# 5. Search with context
semantic_search -> query: "database connection utilities", include_graph_context: true
```

## Error Handling

All tools return standardized error responses:

```json
{
  "error": {
    "code": "NODE_NOT_FOUND",
    "message": "Node with ID 'com.example.Missing' not found",
    "details": {
      "node_id": "com.example.Missing",
      "project_id": "my-project"
    }
  }
}
```

**Common error codes:**
- `NODE_NOT_FOUND`: Requested node doesn't exist
- `EDGE_NOT_FOUND`: Requested edge doesn't exist
- `PROJECT_NOT_FOUND`: Project doesn't exist
- `INVALID_PARAMETERS`: Invalid or missing parameters
- `DATABASE_ERROR`: Neo4J connection or query error
- `SCAN_ERROR`: File scanning or parsing error

## Performance Considerations

### Query Optimization

**Large result sets:**
- Use `limit` parameter to control result size
- Filter by `project_id` when possible
- Use specific node types rather than broad searches

**Complex analysis:**
- Break large hierarchies into smaller queries
- Use targeted searches instead of full scans
- Consider caching results for repeated analysis

### Batch Operations

**Multiple file scanning:**
- Use `scan_dir` instead of multiple `add_file` calls
- Exclude unnecessary directories to improve performance
- Process large projects in stages if needed

**Bulk analysis:**
- Group related queries together
- Use project-specific queries when possible
- Cache frequently accessed results

## Next Steps

- [Quality Metrics](quality-metrics.md) - Detailed explanation of metrics and thresholds
- [MCP Prompts Guide](mcp-prompts.md) - Guided workflows using these tools
- [Troubleshooting](troubleshooting.md) - Solving common tool issues



================================================
FILE: docs/installation-setup.md
================================================
# Installation & Setup Guide

This guide covers the prerequisites, installation, and configuration of CodeRAG.

## Prerequisites

- **Node.js**: Version 18 or higher
- **Neo4J Database**: Version 5.11 or higher (required for vector indexes and semantic search)
- **Git**: For cloning the repository

## Installation

### 1. Clone and Install

```bash
# Clone the repository
git clone https://github.com/JonnoC/CodeRAG.git
cd CodeRAG

# Install dependencies
npm install

# Build the project
npm run build
```

### 2. Environment Configuration

Create a `.env` file in the project root:

```env
# Neo4j Database Configuration
NEO4J_URI=bolt://localhost:7687
NEO4J_USER=neo4j
NEO4J_PASSWORD=your_neo4j_password

# Project Configuration
PROJECT_ISOLATION_STRATEGY=shared_db
DEFAULT_PROJECT_ID=default
CROSS_PROJECT_ANALYSIS=false
MAX_PROJECTS_SHARED_DB=100

# Semantic Search Configuration (Optional)
# Options: openai, local, disabled
SEMANTIC_SEARCH_PROVIDER=disabled

# OpenAI Configuration (required if SEMANTIC_SEARCH_PROVIDER=openai)
# OPENAI_API_KEY=sk-your-openai-api-key-here

# Embedding Model Configuration
# EMBEDDING_MODEL=text-embedding-3-small
# EMBEDDING_MAX_TOKENS=8000
# EMBEDDING_BATCH_SIZE=100
# SIMILARITY_THRESHOLD=0.7

# Remote Repository Authentication (Optional)
# GitHub
# GITHUB_TOKEN=ghp_xxxxxxxxxxxxxxxx

# GitLab
# GITLAB_TOKEN=glpat-xxxxxxxxxxxxxxxx
# GITLAB_HOST=gitlab.company.com  # Optional, for self-hosted GitLab

# Bitbucket
# BITBUCKET_USERNAME=your_username
# BITBUCKET_APP_PASSWORD=your_app_password

# Optional: Server configuration
SERVER_PORT=3000
LOG_LEVEL=info
```

### Semantic Search Setup (Optional)

To enable semantic code search with natural language queries:

1. **Get an OpenAI API key** from [OpenAI Platform](https://platform.openai.com/api-keys)

2. **Update your `.env` file:**
   ```env
   SEMANTIC_SEARCH_PROVIDER=openai
   OPENAI_API_KEY=sk-your-openai-api-key-here
   EMBEDDING_MODEL=text-embedding-3-small
   ```

3. **Ensure Neo4j 5.11+** for vector index support (required for semantic search)

4. **Initialize semantic search** after first project scan:
   ```bash
   npm run build
   node build/index.js --tool initialize_semantic_search
   ```

For detailed semantic search configuration, see the [Semantic Search Guide](semantic-search.md).

### Remote Repository Authentication Setup (Optional)

CodeRAG can directly analyze remote repositories from GitHub, GitLab, and Bitbucket without requiring local cloning. To access private repositories, configure authentication tokens:

#### GitHub Authentication

1. **Create a Personal Access Token**:
   - Go to [GitHub Settings > Developer settings > Personal access tokens](https://github.com/settings/tokens)
   - Click "Generate new token (classic)"
   - Select scopes: `repo` (for private repos) or `public_repo` (for public repos only)
   - Copy the generated token

2. **Configure in `.env`**:
   ```env
   GITHUB_TOKEN=ghp_xxxxxxxxxxxxxxxx
   ```

#### GitLab Authentication

1. **Create a Personal Access Token**:
   - Go to GitLab Settings > Access Tokens
   - Create token with `read_repository` scope
   - Copy the generated token

2. **Configure in `.env`**:
   ```env
   GITLAB_TOKEN=glpat-xxxxxxxxxxxxxxxx
   # For self-hosted GitLab:
   GITLAB_HOST=gitlab.company.com
   ```

#### Bitbucket Authentication

1. **Create an App Password**:
   - Go to Bitbucket Settings > Personal Bitbucket settings > App passwords
   - Create password with `Repositories: Read` permission
   - Copy the generated password

2. **Configure in `.env`**:
   ```env
   BITBUCKET_USERNAME=your_username
   BITBUCKET_APP_PASSWORD=your_app_password
   ```

#### Usage Examples

Once authentication is configured, you can scan remote repositories directly:

```bash
# Public repositories (no authentication needed)
npm run scan https://github.com/owner/repo.git

# Private repositories (uses configured tokens)
npm run scan https://github.com/private/repo.git
npm run scan https://gitlab.com/private/repo.git
npm run scan https://bitbucket.org/private/repo.git

# Specific branches
npm run scan https://github.com/owner/repo.git -- --branch develop
```

## Neo4J Database Setup

CodeRAG requires a running Neo4J instance. Here are several setup options:

### Option 1: Neo4J Desktop (Recommended for Development)

1. Download [Neo4J Desktop](https://neo4j.com/download/)
2. Install and create a new project
3. Create a new database with:
   - Name: `coderag` (or your preference)
   - Password: Set a secure password
   - Version: 5.11+
4. Start the database
5. Note the connection details (usually `bolt://localhost:7687`)

### Option 2: Docker

```bash
# Run Neo4J in Docker
docker run \
    --name neo4j-coderag \
    -p 7474:7474 -p 7687:7687 \
    -d \
    -v $HOME/neo4j/data:/data \
    -v $HOME/neo4j/logs:/logs \
    -v $HOME/neo4j/import:/var/lib/neo4j/import \
    -v $HOME/neo4j/plugins:/plugins \
    --env NEO4J_AUTH=neo4j/your_password \
    neo4j:5.12
```

### Option 3: Neo4J AuraDB (Cloud)

1. Sign up at [Neo4J Aura](https://neo4j.com/cloud/aura/)
2. Create a free instance
3. Note the connection URI and credentials
4. Update your `.env` file with the cloud connection details

## Running CodeRAG

CodeRAG supports two modes of operation:

### STDIO Mode (Default - for MCP Clients)

This mode is used when integrating with MCP-compatible AI tools:

```bash
# Start in STDIO mode
npm start

# Or use the built version
npm run start:built
```

### HTTP/SSE Mode (for HTTP API access)

This mode provides an HTTP endpoint for web-based access:

```bash
# Start HTTP server on port 3000
npm start -- --sse --port 3000

# Or specify a different port
npm start -- --sse --port 8080
```

### Development Mode

For development with auto-reload:

```bash
npm run dev
```

## Verification

To verify your installation:

1. **Test Neo4J Connection**: Ensure your Neo4J instance is running and accessible
2. **Build Success**: Run `npm run build` without errors
3. **STDIO Mode**: Run `npm start` and verify it starts without connection errors
4. **HTTP Mode**: Run `npm start -- --sse --port 3000` and visit `http://localhost:3000/health`

## Next Steps

- [Integration with AI Tools](ai-integration.md) - Connect CodeRAG to your preferred AI assistant
- [Scanner Usage](scanner-usage.md) - Learn how to scan your codebase
- [Multi-Project Management](multi-project-management.md) - Manage multiple codebases



================================================
FILE: docs/list-projects-tool.md
================================================
# List Projects MCP Tool

The `list_projects` tool provides a comprehensive way to view and analyze all projects stored in the CodeRAG graph database.

## Overview

This tool lists all projects with optional detailed statistics, making it perfect for:
- **Project Discovery**: See what projects are available in your graph
- **Project Overview**: Get a quick summary of all scanned codebases
- **Size Analysis**: Compare projects by entity count and complexity
- **Management**: Monitor project growth and updates over time

## Parameters

| Parameter | Type | Required | Default | Description |
|-----------|------|----------|---------|-------------|
| `include_stats` | boolean | No | `false` | Include detailed statistics for each project |
| `sort_by` | string | No | `name` | Sort field: `name`, `created_at`, `updated_at`, `entity_count` |
| `limit` | number | No | `100` | Maximum projects to return (1-1000) |

## Usage Examples

### Basic Project List
```json
{
  "name": "list_projects"
}
```

**Response:**
```json
{
  "projects": [
    {
      "project_id": "my-app",
      "name": "My Application",
      "description": "Scanned from /path/to/my-app",
      "created_at": "2024-01-15T10:30:00.000Z",
      "updated_at": "2024-01-15T10:35:00.000Z"
    }
  ],
  "total_count": 1
}
```

### Projects with Statistics
```json
{
  "name": "list_projects",
  "arguments": {
    "include_stats": true,
    "sort_by": "entity_count",
    "limit": 10
  }
}
```

**Response:**
```json
{
  "projects": [
    {
      "project_id": "large-project",
      "name": "Large Project",
      "description": "Scanned from /path/to/large-project", 
      "created_at": "2024-01-15T10:30:00.000Z",
      "updated_at": "2024-01-15T10:35:00.000Z",
      "stats": {
        "entity_count": 1250,
        "relationship_count": 3400,
        "entity_types": ["class", "interface", "method", "field"],
        "relationship_types": ["IMPLEMENTS", "EXTENDS", "CALLS", "CONTAINS"]
      }
    }
  ],
  "total_count": 1,
  "summary": {
    "total_projects": 1,
    "total_entities": 1250,
    "total_relationships": 3400
  }
}
```

## Response Format

### Basic Response
- `projects`: Array of project objects
- `total_count`: Total number of projects

### Enhanced Response (with stats)
- `projects`: Array of project objects with stats
- `total_count`: Total number of projects  
- `summary`: Aggregate statistics across all projects

### Project Object
- `project_id`: Unique project identifier
- `name`: Human-readable project name
- `description`: Project description
- `created_at`: Project creation timestamp
- `updated_at`: Last update timestamp
- `stats` (if requested): Detailed project statistics

### Statistics Object
- `entity_count`: Total code entities (classes, methods, etc.)
- `relationship_count`: Total relationships between entities
- `entity_types`: Array of entity types found in project
- `relationship_types`: Array of relationship types found in project

## Use Cases

### 1. Project Discovery
```bash
# Find all available projects
mcp call list_projects
```

### 2. Project Size Comparison
```bash
# Compare projects by size
mcp call list_projects --include_stats true --sort_by entity_count
```

### 3. Recent Projects
```bash
# See recently updated projects
mcp call list_projects --sort_by updated_at --limit 5
```

### 4. Project Portfolio Overview
```bash
# Get complete portfolio statistics
mcp call list_projects --include_stats true
```

## Integration

The tool integrates seamlessly with the multi-project CodeRAG architecture:

- **Project Context**: Works with the new project separation system
- **Performance**: Efficient queries using project-aware indexes
- **Statistics**: Leverages project-scoped entity and relationship counts
- **Sorting**: Supports multiple sort criteria for different analysis needs

## Error Handling

The tool handles common error scenarios:
- **Database Connection**: Clear error messages for connection issues
- **No Projects**: Returns empty array with helpful guidance
- **Invalid Parameters**: Validates sort fields and limits
- **Statistics Errors**: Graceful fallback if stats calculation fails

## Next Steps

This tool complements the multi-project infrastructure and enables:
- Project management workflows
- Cross-project analysis preparation
- Database health monitoring
- User interface integration for project selection


================================================
FILE: docs/mcp-prompts.md
================================================
# MCP Prompts Guide

CodeRAG includes 4 guided prompts to help you effectively use the tools:

## 1. `analyze_codebase` - Comprehensive Analysis Guide

**Purpose:** Get step-by-step guidance for analyzing your codebase

**Usage:**
```
Use the analyze_codebase prompt for my TypeScript project
```

**What it provides:**
- Instructions for exploring existing graph data
- Steps to understand codebase structure
- Relationship analysis guidance
- Quality assessment workflow

**Best for:**
- First-time codebase exploration
- Comprehensive quality assessment
- Understanding unfamiliar codebases
- Preparing architecture documentation

**Example workflow:**
1. Prompt guides you to scan the project
2. Shows how to get overview with `get_project_summary`
3. Explains finding architectural issues
4. Demonstrates class-level analysis
5. Provides guidance on interpreting results

## 2. `setup_code_graph` - Project Setup Guide

**Purpose:** Step-by-step guide to set up a code graph for a new project

**Usage:**
```
Use the setup_code_graph prompt for language=java
```

**What it provides:**
- Scanning instructions
- Validation steps
- Structure analysis guidance
- Relationship exploration tips

**Best for:**
- New CodeRAG users
- Setting up analysis for new projects
- Ensuring proper configuration
- Learning the basic workflow

**Example workflow:**
1. Guides through initial project scanning
2. Shows how to verify scan results
3. Explains basic node and relationship queries
4. Demonstrates essential analysis tools
5. Provides troubleshooting tips

## 3. `find_dependencies` - Dependency Analysis

**Purpose:** Guide to find class dependencies and method calls

**Usage:**
```
Use the find_dependencies prompt for target_class=UserService
```

**What it provides:**
- Instructions to find what a class depends on
- Steps to find what depends on the class
- Coupling analysis guidance
- Visualization approaches

**Best for:**
- Analyzing specific classes or components
- Understanding coupling and dependencies
- Planning refactoring efforts
- Impact analysis for changes

**Example workflow:**
1. Shows how to find outgoing dependencies
2. Demonstrates finding incoming dependencies
3. Explains coupling metrics interpretation
4. Guides through relationship visualization
5. Provides refactoring recommendations

## 4. `analyze_inheritance` - Inheritance Analysis

**Purpose:** Guide to analyze inheritance hierarchies and interface implementations

**Usage:**
```
Use the analyze_inheritance prompt for class_or_interface=BaseRepository
```

**What it provides:**
- Hierarchy mapping instructions
- Implementation discovery steps
- Design pattern identification
- Architecture evaluation guidance

**Best for:**
- Object-oriented design analysis
- Understanding inheritance structures
- Identifying design patterns
- Evaluating abstraction levels

**Example workflow:**
1. Maps complete inheritance hierarchy
2. Finds all implementations of interfaces
3. Analyzes depth and breadth of inheritance
4. Identifies potential design issues
5. Suggests architectural improvements

## Using Prompts Effectively

### 1. Choose the Right Prompt

**Start with `setup_code_graph`** when:
- New to CodeRAG
- Working with a new project
- Need to verify setup

**Use `analyze_codebase`** when:
- Want comprehensive analysis
- Need to understand overall architecture
- Preparing quality reports

**Use `find_dependencies`** when:
- Investigating specific classes
- Planning refactoring
- Understanding coupling

**Use `analyze_inheritance`** when:
- Working with OOP codebases
- Analyzing design patterns
- Evaluating abstraction layers

### 2. Sequential Usage

**Recommended Order for New Projects:**
1. `setup_code_graph` - Initial setup and validation
2. `analyze_codebase` - Overall understanding
3. `find_dependencies` - Specific class investigation
4. `analyze_inheritance` - OOP structure analysis

### 3. Interactive Guidance

**Each prompt provides:**
- Clear step-by-step instructions
- Tool recommendations with exact parameters
- Interpretation guidance for results
- Follow-up suggestions
- Troubleshooting tips

**Example interaction:**
```
User: Use the analyze_codebase prompt for my TypeScript project

Assistant: I'll guide you through a comprehensive codebase analysis...

Step 1: First, let's scan your project
Use: scan_dir with your project path

Step 2: Get project overview
Use: get_project_summary

Step 3: Identify issues
Use: find_architectural_issues

[Continues with detailed guidance]
```

## Prompt Parameters

### Common Parameters

**Language-specific prompts:**
- `language`: Programming language (typescript, java, python, etc.)
- Affects tool recommendations and best practices

**Class-specific prompts:**
- `target_class`: Specific class to analyze
- `class_or_interface`: Class or interface name for inheritance analysis

**Project context:**
- `project_id`: Specific project in multi-project setup
- Automatically inferred if only one project exists

### Example Parameters

```
# Language-specific setup
analyze_codebase prompt for language=java

# Class-specific analysis
find_dependencies prompt for target_class=com.example.UserService

# Interface hierarchy analysis
analyze_inheritance prompt for class_or_interface=Repository

# Multi-project context
setup_code_graph prompt for language=typescript project_id=frontend-app
```

## Advanced Prompt Usage

### 1. Combining Prompts

**Sequential Analysis:**
```
1. setup_code_graph for language=java
2. analyze_codebase for comprehensive review
3. find_dependencies for UserService
4. analyze_inheritance for BaseEntity
```

**Focused Investigation:**
```
1. find_dependencies for problem class
2. analyze_inheritance for base classes
3. analyze_codebase for quality metrics
```

### 2. Multi-Project Workflows

**Portfolio Analysis:**
```
1. setup_code_graph for each project
2. analyze_codebase for each project  
3. Compare results across projects
```

**Migration Planning:**
```
1. analyze_codebase for legacy system
2. find_dependencies for core components
3. analyze_inheritance for key abstractions
```

### 3. Team Collaboration

**Code Review Preparation:**
```
1. analyze_codebase for overview
2. find_dependencies for changed classes
3. Share results with team
```

**Onboarding New Developers:**
```
1. setup_code_graph for project setup
2. analyze_codebase for architecture understanding
3. analyze_inheritance for design patterns
```

## Prompt Output and Follow-up

### Understanding Prompt Results

**Prompts provide:**
- Specific tool calls to make
- Expected output explanation
- Interpretation guidance
- Next step recommendations

**Example output structure:**
```
=== CodeRAG Guided Analysis ===

Step 1: Project Scanning
> Use tool: scan_dir
> Parameters: {"directory_path": "/path/to/project"}
> Expected: Project entities and relationships

Step 2: Overview Analysis  
> Use tool: get_project_summary
> Expected: Quality metrics and statistics
> Look for: High complexity classes, architectural issues

[Continues with detailed guidance]
```

### Follow-up Actions

**After using prompts:**
1. Execute recommended tool calls
2. Review and interpret results
3. Follow suggested next steps
4. Use additional prompts as needed
5. Document findings and decisions

## Troubleshooting Prompts

### Common Issues

**Prompt doesn't provide expected guidance:**
- Verify prompt name and parameters
- Check project context (single vs multi-project)
- Ensure project is properly scanned

**Tools mentioned in prompt not available:**
- Verify CodeRAG MCP server is connected
- Check tool permissions and configuration
- Restart AI assistant if needed

**Results don't match prompt expectations:**
- Verify project was scanned successfully
- Check for scanning errors or warnings
- Consider re-scanning with different options

### Getting Help

**When prompts aren't helpful:**
1. Check the [Available Tools](available-tools.md) guide
2. Review [Scanner Usage](scanner-usage.md) for setup issues
3. Consult [Troubleshooting](troubleshooting.md) for common problems
4. Try a different prompt that might be more appropriate

## Best Practices

### 1. Prompt Selection
- Start with setup prompts for new projects
- Use specific prompts for focused analysis
- Combine prompts for comprehensive understanding

### 2. Parameter Usage
- Provide specific class names when possible
- Include language context for better guidance
- Use project_id in multi-project environments

### 3. Result Interpretation
- Follow prompt guidance for interpreting results
- Look for patterns and trends, not just individual metrics
- Consider architectural context when evaluating findings

### 4. Documentation
- Document key findings from prompt-guided analysis
- Share insights with team members
- Use results to plan improvements and refactoring

## Next Steps

- [Available Tools](available-tools.md) - Detailed reference for all CodeRAG tools
- [Quality Metrics](quality-metrics.md) - Understanding analysis results
- [Troubleshooting](troubleshooting.md) - Solving common issues



================================================
FILE: docs/multi-project-management.md
================================================
# Multi-Project Management

CodeRAG supports managing multiple codebases in a single Neo4J database, enabling powerful cross-project analysis and portfolio management capabilities.

## Understanding Multi-Project Architecture

CodeRAG uses a **project isolation strategy** where:
- Each scanned codebase gets a unique `project_id`
- All nodes and relationships are tagged with their `project_id`
- Projects are isolated by default but can enable cross-project analysis
- Each project maintains separate quality metrics and statistics

## Project Identification & Auto-Detection

CodeRAG now automatically extracts project information from build files and metadata:

```bash
# Auto-detects project name from package.json, pom.xml, etc.
npm run scan /path/to/my-react-app
# Detects: TypeScript, React framework, project name "my-react-app" v1.2.0

npm run scan /path/to/spring-backend
# Detects: Java, Spring Boot framework, project name from pom.xml

npm run scan /path/to/python-service
# Detects: Python, Django framework, project name from setup.py/pyproject.toml
```

**Project Detection Features:**
- **Build File Analysis**: Extracts metadata from package.json, pom.xml, build.gradle, setup.py, pyproject.toml
- **Framework Detection**: Identifies React, Spring Boot, Django, Express, etc. from dependencies
- **Multi-Language Support**: Handles projects with multiple languages (frontend + backend)
- **Sub-Project Detection**: Automatically discovers mono-repositories with multiple sub-projects
- **Automatic Naming**: Uses project name from build files, falls back to directory name
- **Version Tracking**: Extracts version information from build files

## Managing Multiple Projects

### 1. Scanning Multiple Projects with Auto-Detection

```bash
# Scan first project (auto-detects TypeScript/React)
npm run scan /path/to/react-frontend -- --clear-all
# Output: ✅ TypeScript project detected, Framework: React, Name: "my-frontend" v2.1.0

# Scan backend (auto-detects Java/Spring Boot)
npm run scan /path/to/spring-backend
# Output: ✅ Java project detected, Framework: Spring Boot, Name: "api-service" v1.0.0

# Scan Python service (auto-detects Python/Django)
npm run scan /path/to/python-api
# Output: ✅ Python project detected, Framework: Django, Name: "data-processor" v0.3.2

# Scan mono-repository (auto-detects multiple languages)
npm run scan /path/to/fullstack-monorepo
# Output: 🏗️ Mono-repository detected: TypeScript (frontend), Java (backend), Python (scripts)

# Re-scan with updated code (preserves project metadata)
npm run scan /path/to/react-frontend -- --clear-graph
```

### 2. Listing All Projects

Use the `list_projects` tool to discover and manage your projects:

**Basic Project List:**
```json
{
  "name": "list_projects"
}
```

**Enhanced List with Statistics:**
```json
{
  "name": "list_projects",
  "arguments": {
    "include_stats": true,
    "sort_by": "entity_count",
    "limit": 10
  }
}
```

**Parameters:**
- `include_stats` (boolean): Include entity counts and relationship statistics
- `sort_by` (string): Sort by `name`, `created_at`, `updated_at`, or `entity_count`
- `limit` (number): Maximum projects to return (1-1000, default: 100)

**Example Response:**
```json
{
  "projects": [
    {
      "project_id": "my-awesome-app",
      "name": "My Awesome App",
      "description": "Scanned from /path/to/my-awesome-app",
      "created_at": "2024-01-15T10:30:00.000Z",
      "updated_at": "2024-01-15T10:35:00.000Z",
      "stats": {
        "entity_count": 127,
        "relationship_count": 89,
        "entity_types": ["class", "method", "interface", "field"],
        "relationship_types": ["CONTAINS", "IMPLEMENTS", "EXTENDS"]
      }
    }
  ],
  "total_count": 1,
  "summary": {
    "total_projects": 1,
    "total_entities": 127,
    "total_relationships": 89
  }
}
```

## Project-Aware Tool Usage

Most CodeRAG tools support project filtering to focus analysis on specific codebases:

### Explicit Project Specification

When you have multiple projects, you can specify which project to analyze:

```bash
# Analyze specific project
mcp call get_project_summary --arguments '{"project_id": "my-awesome-app"}'

# Find architectural issues in specific project
mcp call find_architectural_issues --arguments '{"project_id": "legacy-system"}'

# Calculate metrics for class in specific project
mcp call calculate_ck_metrics --arguments '{
  "class_id": "com.example.UserService",
  "project_id": "my-awesome-app"
}'
```

### Default Project Behavior

When `project_id` is not specified:
- **Single Project Database**: Tools automatically use the only project
- **Multi-Project Database**: Tools may return results across all projects or prompt for project specification
- **Current Context**: Some tools remember the last specified project

## Multi-Project Workflows

### 1. Portfolio Analysis

Compare multiple projects side-by-side:

```bash
# Get overview of all projects
mcp call list_projects --arguments '{"include_stats": true, "sort_by": "entity_count"}'

# Compare quality across projects
for project in project-a project-b project-c; do
  mcp call get_project_summary --arguments "{\"project_id\": \"$project\"}"
done
```

### 2. Migration Analysis

When modernizing legacy systems:

```bash
# Scan legacy system
npm run scan /path/to/legacy-system -- --clear-graph

# Scan new system
npm run scan /path/to/new-system

# Compare architectures
mcp call find_architectural_issues --arguments '{"project_id": "legacy-system"}'
mcp call find_architectural_issues --arguments '{"project_id": "new-system"}'
```

### 3. Microservices Analysis

Analyze microservices architecture:

```bash
# Scan each service
npm run scan /path/to/user-service -- --clear-graph
npm run scan /path/to/order-service
npm run scan /path/to/payment-service
npm run scan /path/to/notification-service

# Analyze coupling between services
mcp call list_projects --arguments '{"include_stats": true}'

# Find shared patterns
mcp call search_nodes --arguments '{"search_term": "Controller"}'
```

## Cross-Project Analysis

When enabled, CodeRAG can analyze patterns across multiple projects:

### Finding Common Patterns

```bash
# Find all classes implementing specific interface across projects
mcp call find_classes_implementing_interface --arguments '{
  "interface_name": "Repository"
  // Omit project_id for cross-project search
}'

# Search for naming patterns across all projects
mcp call search_nodes --arguments '{
  "search_term": "Service",
  "type": "class"
}'
```

### Portfolio Quality Assessment

```bash
# Get quality summary for all projects
mcp call list_projects --arguments '{"include_stats": true, "sort_by": "entity_count"}'

# Identify projects needing attention
for project in $(mcp call list_projects | jq -r '.projects[].project_id'); do
  echo "=== Analysis for $project ==="
  mcp call find_architectural_issues --arguments "{\"project_id\": \"$project\"}"
done
```

## Project Management Best Practices

### 1. Naming Conventions

**Good project directory names:**
- `user-management-api`
- `react-frontend` 
- `payment-processor`
- `legacy-monolith`

**Avoid:**
- Generic names like `app`, `system`, `code`
- Version numbers like `v1`, `v2` (use git tags instead)
- Special characters that don't translate well

### 2. Scanning Strategy

**Clean Slate Approach:**
```bash
# Clear database and start fresh
npm run scan /path/to/main-project -- --clear-graph
npm run scan /path/to/other-projects...
```

**Incremental Approach:**
```bash
# Add projects one by one
npm run scan /path/to/new-project  # Preserves existing projects
```

**Update Existing Project:**
```bash
# Re-scan with same project name to update
npm run scan /path/to/existing-project -- --clear-existing
```

### 3. Project Lifecycle Management

**Regular Updates:**
- Re-scan projects after major changes
- Monitor quality trends over time
- Archive old project versions

**Quality Gates:**
- Set quality thresholds per project type
- Monitor architectural drift
- Track technical debt accumulation

## Common Multi-Project Scenarios

### Scenario 1: Comparing Frontend Frameworks

```bash
# Scan different implementations
npm run scan /path/to/react-app
npm run scan /path/to/vue-app  
npm run scan /path/to/angular-app

# Compare complexity
mcp call list_projects --arguments '{"include_stats": true, "sort_by": "entity_count"}'
```

### Scenario 2: Legacy Migration Tracking

```bash
# Baseline legacy system
npm run scan /path/to/legacy-monolith -- --clear-graph

# Track new microservices
npm run scan /path/to/user-service
npm run scan /path/to/order-service

# Monitor progress
mcp call get_project_summary --arguments '{"project_id": "legacy-monolith"}'
```

### Scenario 3: Multi-Language Portfolio with Auto-Detection

```bash
# Automatically detect and scan different language projects
npm run scan /path/to/java-backend
# Output: ✅ Java project detected, Framework: Spring Boot, Build: Maven

npm run scan /path/to/python-ml-service  
# Output: ✅ Python project detected, Frameworks: FastAPI, scikit-learn, Build: Poetry

npm run scan /path/to/typescript-frontend
# Output: ✅ TypeScript project detected, Framework: Next.js, Build: npm

# Compare frameworks and architectural patterns across languages
mcp call find_architectural_issues  # Cross-project analysis
mcp call list_projects --arguments '{"include_stats": true}'
# Shows detected frameworks, languages, and quality metrics for each project
```

## Troubleshooting Multi-Project Issues

### Issue: Duplicate project IDs
- **Solution**: Rename project directories or use different scan paths
- **Workaround**: Clear specific project before re-scanning

### Issue: Can't find specific project
- **Check**: Use `list_projects` to see available project IDs
- **Verify**: Project was scanned successfully
- **Confirm**: Correct spelling and case sensitivity

### Issue: Cross-project analysis not working
- **Check**: Omit `project_id` parameter for cross-project tools
- **Verify**: Database contains multiple projects
- **Confirm**: Tools support cross-project analysis mode

## Database Schema for Multi-Project

### Project Isolation

All nodes include a `project_id` property:

```cypher
// Example node structure
CREATE (c:Class {
  id: "com.example.UserService",
  name: "UserService",
  project_id: "my-awesome-app",
  package: "com.example",
  // ... other properties
})
```

### Project Context Nodes

```cypher
// ProjectContext node stores project metadata
CREATE (p:ProjectContext {
  project_id: "my-awesome-app",
  name: "My Awesome App",
  description: "Scanned from /path/to/my-awesome-app",
  created_at: datetime(),
  updated_at: datetime(),
  languages: ["typescript", "javascript"],
  total_entities: 127,
  total_relationships: 89
})
```

### Optimized Queries

```cypher
// Project-aware queries use project_id in WHERE clauses
MATCH (c:Class)
WHERE c.project_id = $project_id
RETURN c

// Cross-project queries omit project_id filtering
MATCH (c:Class)
WHERE c.name CONTAINS $search_term
RETURN c.project_id, c.name
```

## Next Steps

- [Available Tools](available-tools.md) - Explore project-aware analysis tools
- [Quality Metrics](quality-metrics.md) - Understand project-specific metrics
- [MCP Prompts Guide](mcp-prompts.md) - Use guided prompts for multi-project analysis



================================================
FILE: docs/quality-metrics.md
================================================
# Code Quality Metrics Guide

CodeRAG provides comprehensive code quality analysis through multiple metric suites. These metrics help identify design issues, complexity problems, and architectural concerns in your codebase.

## Understanding Metric Classifications

CodeRAG uses a three-tier classification system for all metrics:

- **🟢 Good (Green)**: Optimal range indicating healthy code design
- **🟡 Warning (Yellow)**: Acceptable but should be monitored; consider improvement
- **🔴 Critical (Red)**: Problematic values requiring immediate attention

## CK Metrics Suite (Chidamber & Kemerer)

The CK metrics suite is a widely-accepted set of object-oriented design quality metrics introduced by Chidamber and Kemerer in 1994.

### WMC (Weighted Methods per Class)

**What it measures:** The complexity of a class based on the number and complexity of its methods.

**How it's calculated:**
- Counts all methods in a class (public, private, protected)
- Each method contributes 1 to the weight (simplified McCabe complexity)
- Formula: `WMC = Σ(complexity of each method)`

**Interpretation:**
- **🟢 Good: < 15** - Class has focused responsibilities and manageable complexity
- **🟡 Warning: 15-30** - Class is getting complex, consider refactoring
- **🔴 Critical: > 30** - Class likely violates Single Responsibility Principle

**Why it matters:**
- High WMC indicates classes that are difficult to understand, test, and maintain
- Classes with high WMC are more prone to bugs
- Affects testing effort (more methods = more test cases needed)

**Example:**
```java
// Good WMC (≈ 8)
class UserValidator {
    public boolean isValidEmail(String email) { ... }
    public boolean isValidPassword(String password) { ... }
    public boolean isValidAge(int age) { ... }
    private boolean checkDomain(String domain) { ... }
    // ... 4 more focused methods
}

// Critical WMC (≈ 35)
class UserManager {
    // 35+ methods handling user creation, validation, authentication,
    // email sending, logging, caching, etc.
}
```

### DIT (Depth of Inheritance Tree)

**What it measures:** The maximum depth of inheritance hierarchy from a class to the root class.

**How it's calculated:**
- Counts the number of ancestor classes up to the root
- Root classes (Object, base classes) have DIT = 0
- Each level of inheritance adds 1

**Interpretation:**
- **🟢 Good: < 3** - Shallow hierarchy, easy to understand and maintain
- **🟡 Warning: 3-4** - Moderate depth, acceptable for complex domains
- **🔴 Critical: > 4** - Deep hierarchy, difficult to understand and modify

**Why it matters:**
- Deep inheritance makes code harder to understand
- Changes to base classes affect many derived classes
- Increases complexity of method resolution
- Can indicate over-engineering

**Example:**
```java
// Good DIT = 2
Object -> Animal -> Dog

// Critical DIT = 6  
Object -> Vehicle -> MotorVehicle -> Car -> Sedan -> LuxurySedan -> BMWSedan
```

### NOC (Number of Children)

**What it measures:** The number of immediate subclasses that inherit from a class.

**How it's calculated:**
- Counts direct subclasses only (not grandchildren)
- Formula: `NOC = count(immediate subclasses)`

**Interpretation:**
- **🟢 Good: < 5** - Reasonable number of specializations
- **🟡 Warning: 5-7** - Many subclasses, ensure they're all necessary
- **🔴 Critical: > 7** - Too many subclasses, consider composition or interfaces

**Why it matters:**
- High NOC indicates a class may be too general or abstract
- Many subclasses increase testing complexity
- Changes to parent class affect many children
- May indicate improper abstraction level

**Example:**
```java
// Good NOC = 3
abstract class Shape {
    // Rectangle, Circle, Triangle inherit from Shape
}

// Critical NOC = 12
abstract class DatabaseConnection {
    // MySQL, PostgreSQL, Oracle, SQLServer, MongoDB, 
    // Redis, Cassandra, Neo4j, etc. all inherit directly
}
```

### CBO (Coupling Between Objects)

**What it measures:** The number of other classes that a class depends on or is coupled to.

**How it's calculated:**
- Counts classes referenced in field declarations, method parameters, return types
- Includes inheritance, composition, and association relationships
- Excludes primitive types and standard library classes (configurable)

**Interpretation:**
- **🟢 Good: < 5** - Low coupling, class is relatively independent
- **🟡 Warning: 5-10** - Moderate coupling, acceptable for complex functionality
- **🔴 Critical: > 10** - High coupling, class is tightly bound to many others

**Why it matters:**
- High coupling makes classes harder to test in isolation
- Changes ripple through highly coupled classes
- Reduces reusability and increases maintenance cost
- Indicates potential violation of dependency principles

**Example:**
```java
// Good CBO = 3
class EmailService {
    private EmailTemplate template;    // +1
    private EmailValidator validator;  // +1
    
    public void send(User user) { ... } // +1 for User
}

// Critical CBO = 15
class OrderProcessor {
    // Uses 15+ different classes: User, Product, PaymentGateway,
    // ShippingService, InventoryManager, EmailService, SMSService,
    // AuditLogger, SecurityManager, ConfigManager, etc.
}
```

### RFC (Response for Class)

**What it measures:** The total number of methods that can potentially be executed in response to a message received by an object of the class.

**How it's calculated:**
- Includes all methods in the class
- Plus all methods in other classes that are called by methods in this class
- Formula: `RFC = |{M}| + |{R}|` where M = methods in class, R = remote methods called

**Interpretation:**
- **🟢 Good: < 20** - Class has reasonable complexity and interactions
- **🟡 Warning: 20-30** - High complexity, consider refactoring
- **🔴 Critical: > 30** - Very high complexity, likely violates SRP

**Why it matters:**
- High RFC indicates complex classes that are hard to test
- Affects debugging difficulty (more potential execution paths)
- Correlates with defect density
- Indicates classes that may need decomposition

### LCOM (Lack of Cohesion in Methods)

**What it measures:** How well the methods in a class work together and share data.

**How it's calculated (LCOM4 variant):**
- Creates a graph where methods are nodes
- Edges connect methods that share instance variables
- Counts connected components in the graph
- Lower values indicate better cohesion

**Interpretation:**
- **🟢 Good: < 0.3** - High cohesion, methods work well together
- **🟡 Warning: 0.3-0.7** - Moderate cohesion, some methods may be unrelated
- **🔴 Critical: > 0.7** - Low cohesion, class likely has multiple responsibilities

**Why it matters:**
- Low cohesion suggests a class has multiple unrelated responsibilities
- High cohesion makes classes easier to understand and maintain
- Helps identify candidates for class decomposition
- Relates to Single Responsibility Principle

## Package Metrics

Package metrics analyze the structure and dependencies at the package/module level, helping identify architectural issues.

### Afferent Coupling (Ca)

**What it measures:** The number of classes outside a package that depend on classes inside the package.

**How it's calculated:**
- Counts external classes that import or use classes from this package
- Only counts direct dependencies

**Interpretation:**
- **High Ca**: Package is stable and widely used (good for libraries)
- **Low Ca**: Package may be unused or too specialized
- **Very High Ca**: Changes to this package will affect many other packages

**Use cases:**
- Identifying core/foundational packages
- Understanding impact of changes
- Planning refactoring priorities

### Efferent Coupling (Ce)

**What it measures:** The number of classes outside a package that classes inside the package depend on.

**How it's calculated:**
- Counts external classes that are imported or used by classes in this package
- Measures outgoing dependencies

**Interpretation:**
- **High Ce**: Package depends on many external packages (potentially unstable)
- **Low Ce**: Package is relatively self-contained
- **Very High Ce**: Package may violate dependency management principles

### Instability (I)

**What it measures:** The resilience to change of a package.

**How it's calculated:**
- Formula: `I = Ce / (Ca + Ce)`
- Ranges from 0 (maximally stable) to 1 (maximally unstable)

**Interpretation:**
- **🟢 I = 0**: Completely stable (only has incoming dependencies)
- **🟡 I = 0.5**: Balanced stability
- **🔴 I = 1**: Completely unstable (only has outgoing dependencies)

**Why it matters:**
- Unstable packages should not be depended upon by stable packages
- Helps identify architectural violations
- Guides dependency management decisions

### Abstractness (A)

**What it measures:** The ratio of abstract classes and interfaces to total classes in a package.

**How it's calculated:**
- Formula: `A = (Abstract Classes + Interfaces) / Total Classes`
- Ranges from 0 (completely concrete) to 1 (completely abstract)

**Interpretation:**
- **A = 0**: Package contains only concrete classes
- **A = 1**: Package contains only abstract classes/interfaces
- **Optimal A**: Depends on package role (utilities ≈ 0, frameworks ≈ 1)

### Distance from Main Sequence (D)

**What it measures:** How well a package balances abstractness and stability.

**How it's calculated:**
- Formula: `D = |A + I - 1|`
- Measures distance from the "main sequence" line where A + I = 1

**Interpretation:**
- **🟢 D ≈ 0**: Package is well-balanced
- **🔴 D ≈ 1**: Package is in "Zone of Pain" (concrete and stable) or "Zone of Uselessness" (abstract and unstable)

**The Main Sequence:**
- **Zone of Pain (I=0, A=0)**: Rigid, hard to change concrete classes
- **Zone of Uselessness (I=1, A=1)**: Abstract classes that nobody uses
- **Main Sequence**: Balanced packages that are either stable+abstract or unstable+concrete

## Architectural Issues Detection

CodeRAG automatically detects common architectural problems:

### Circular Dependencies

**What it detects:** Packages that have mutual dependencies, creating cycles in the dependency graph.

**Why it's problematic:**
- Makes individual testing difficult
- Complicates build processes
- Reduces modularity
- Can cause runtime issues (initialization order problems)

**Example:**
```
Package A depends on Package B
Package B depends on Package C  
Package C depends on Package A  // Creates cycle A → B → C → A
```

### God Classes

**What it detects:** Classes with excessive responsibilities, typically identified by:
- Very high WMC (> 50)
- High number of fields (> 20)
- Large number of methods (> 30)
- High CBO (> 15)

**Why it's problematic:**
- Violates Single Responsibility Principle
- Difficult to understand and maintain
- Hard to test comprehensively
- Becomes a bottleneck for changes

### High Coupling Classes

**What it detects:** Classes with CBO > 15, indicating excessive dependencies.

**Why it's problematic:**
- Changes require updates to many related classes
- Difficult to test in isolation
- Reduces reusability
- Increases maintenance complexity

### Unstable Dependencies

**What it detects:** Stable packages (low I) that depend on unstable packages (high I).

**Why it's problematic:**
- Violates Stable Dependencies Principle
- Stable code becomes affected by unstable code changes
- Can lead to unexpected breaking changes
- Makes the system harder to evolve

## Using Metrics Effectively

### 1. Metric Interpretation Guidelines

**Don't focus on single metrics:**
- Use metrics in combination for better insights
- Consider the context of your application domain
- Some complexity may be inherent to the problem being solved

**Trend analysis is more valuable than absolute values:**
- Track metrics over time to see improvement/degradation
- Focus on classes that are getting worse
- Celebrate improvements in metric trends

### 2. Prioritizing Improvements

**High-impact targets:**
1. **God Classes** with high WMC + high CBO
2. **Circular Dependencies** affecting core packages
3. **Highly Coupled Classes** in frequently changed areas
4. **Deep Inheritance** in business logic classes

**Lower priority:**
1. Slightly elevated metrics in stable, working code
2. Test classes with higher complexity (often acceptable)
3. Generated code or framework classes

### 3. Refactoring Strategies

**For High WMC:**
- Extract Method pattern
- Decompose into multiple classes
- Use Strategy or Command patterns

**For High CBO:**
- Introduce interfaces to reduce concrete dependencies
- Use Dependency Injection
- Apply Facade pattern for complex subsystems

**For Low Cohesion:**
- Split class based on method groupings
- Extract classes for each responsibility
- Use composition instead of inheritance

**For Deep Inheritance:**
- Favor composition over inheritance
- Use interfaces for contracts
- Flatten hierarchies where possible

## Getting Metric Reports

Use these CodeRAG tools to analyze your code quality:

```bash
# Get overall project quality summary
mcp call get_project_summary

# Calculate CK metrics for specific class
mcp call calculate_ck_metrics --arguments '{"class_id": "com.example.UserService"}'

# Analyze package metrics
mcp call calculate_package_metrics --arguments '{"package_name": "com.example.service"}'

# Find architectural issues
mcp call find_architectural_issues

# Compare metrics across projects
mcp call list_projects --arguments '{"include_stats": true, "sort_by": "entity_count"}'
```

## Metric Thresholds Reference

### CK Metrics Thresholds

| Metric | Good (🟢) | Warning (🟡) | Critical (🔴) |
|--------|-----------|--------------|---------------|
| WMC | < 15 | 15-30 | > 30 |
| DIT | < 3 | 3-4 | > 4 |
| NOC | < 5 | 5-7 | > 7 |
| CBO | < 5 | 5-10 | > 10 |
| RFC | < 20 | 20-30 | > 30 |
| LCOM | < 0.3 | 0.3-0.7 | > 0.7 |

### Package Metrics Guidelines

| Metric | Optimal Range | Notes |
|--------|--------------|-------|
| Ca | Context-dependent | High for libraries, low for applications |
| Ce | As low as possible | Indicates external dependencies |
| I | 0.0-1.0 | Stable packages near 0, unstable near 1 |
| A | 0.0-1.0 | Depends on package purpose |
| D | Close to 0 | Distance from main sequence |

### Architectural Issue Severities

| Issue Type | Critical Threshold | Notes |
|------------|-------------------|-------|
| God Classes | WMC > 50 | Combined with high CBO |
| High Coupling | CBO > 15 | Consider context |
| Deep Inheritance | DIT > 4 | Especially in business logic |
| Circular Dependencies | Any cycle | Always problematic |

## Best Practices

### 1. Regular Monitoring
- Include metrics in CI/CD pipelines
- Set up quality gates based on thresholds
- Track trends over time
- Review metrics during code reviews

### 2. Contextual Analysis
- Consider domain complexity
- Account for framework requirements
- Distinguish between business logic and infrastructure code
- Evaluate metrics relative to project phase (early development vs maintenance)

### 3. Gradual Improvement
- Focus on worst offenders first
- Set realistic improvement targets
- Refactor incrementally
- Measure impact of changes

### 4. Team Education
- Share metric meanings with the team
- Discuss architectural principles
- Use metrics to guide design decisions
- Celebrate quality improvements

## Next Steps

- [Available Tools](available-tools.md) - Tools for calculating and analyzing metrics
- [MCP Prompts Guide](mcp-prompts.md) - Guided workflows for quality analysis
- [Troubleshooting](troubleshooting.md) - Solving common metric calculation issues



================================================
FILE: docs/scanner-usage-examples.md
================================================
# Codebase Scanner Usage Examples

## Basic Usage

### 1. Scan a TypeScript Project
```bash
# Basic scan
npm run scan /path/to/your/typescript-project

# Example output:
🚀 CodeRAG Scanner v1.0.0
📁 Project: /Users/dev/my-typescript-app
🔗 Connected to Neo4j: bolt://localhost:7687
🔍 Validating project structure...

📋 Project Analysis:
  ✅ package.json found - Node.js project detected
  ✅ tsconfig.json found - TypeScript project detected

⚙️ Scan Configuration:
  Languages: typescript, javascript
  Include tests: no
  Exclude paths: node_modules, dist, build

🔄 Starting codebase scan...
📁 Found 45 source files
📊 Processed 45/45 files
💾 Storing 127 entities and 89 relationships...
📥 Storing entities...
🔗 Storing relationships...

📊 CODEBASE SCAN REPORT
═══════════════════════

📈 STATISTICS
  Files processed: 45
  Entities found: 127
  Relationships found: 89
  Processing time: 3.24s

🏗️ ENTITY BREAKDOWN
  • class: 23
  • method: 67
  • interface: 12
  • field: 18
  • module: 7

🔗 RELATIONSHIP BREAKDOWN
  • contains: 85
  • implements: 15
  • extends: 8
  • belongs_to: 45

✅ Scan completed successfully!
```

### 2. Scan with Quality Analysis
```bash
npm run scan /path/to/project -- --analyze

# Additional output after scan:
🔬 Running quality analysis...

📊 QUALITY ANALYSIS RESULTS
═══════════════════════════
📈 Project Metrics:
  Total Classes: 23
  Total Methods: 67
  Total Packages: 7
  Average Coupling: 4.2
  Average RFC: 8.7
  Average DIT: 1.8

⚠️ Issues Found: 3
  1. [HIGH] God class detected: UserService (25 methods, 12 couplings)
  2. [HIGH] Highly coupled class: DatabaseManager (18 couplings)
  3. [MEDIUM] Circular dependency detected in package: com.example.utils

💡 Recommendations:
  • Use MCP tools to explore specific classes and metrics
  • Focus on high-coupling classes and god classes first
  • Consider refactoring classes with high CBO (>10) or RFC (>50)
```

## Advanced Usage

### 3. Clear and Rescan
```bash
# Clear this project's data before scanning
npm run scan /path/to/project -- --clear-graph --analyze

# Clear ALL database data before scanning (all projects)
npm run scan /path/to/project -- --clear-all --analyze
```

### 4. Include Test Files
```bash
# Include test files in the analysis
npm run scan /path/to/project -- --include-tests
```

### 5. Project Validation Only
```bash
# Validate project structure without scanning
npm run scan validate /path/to/project

# Output:
📁 Project: /Users/dev/my-project
✅ Valid: Yes
🔤 Languages detected: typescript, javascript

📋 Analysis:
  ✅ package.json found - Node.js project detected
  ✅ tsconfig.json found - TypeScript project detected
  💡 Consider organizing code in a src/ directory for better analysis
```

### 6. Custom Language Selection
```bash
# Scan only JavaScript files
npm run scan /path/to/project -- --languages javascript

# Scan multiple languages (when parsers are available)
npm run scan /path/to/project -- --languages typescript,javascript,java
```

## Integration Workflow

### Complete Analysis Workflow
```bash
# 1. Validate project structure
npm run scan validate /path/to/project

# 2. Clear previous data and scan with analysis
npm run scan /path/to/project -- --clear-graph --analyze --output-report

# 3. Start CodeRAG server
npm start

# 4. Use MCP tools to explore results
mcp call get_project_summary
mcp call find_architectural_issues
mcp call calculate_ck_metrics --arguments '{"class_id": "com.example.UserService"}'
```

## Supported File Types

### Currently Supported
- **TypeScript**: `.ts`, `.tsx`
- **JavaScript**: `.js`, `.jsx`

### Planned Support
- **Java**: `.java`
- **Python**: `.py`
- **C#**: `.cs`

## Common Use Cases

### 1. Legacy Codebase Analysis
```bash
# Analyze a large legacy codebase
npm run scan /path/to/legacy-project -- --clear-graph --analyze --verbose

# Focus on finding architectural issues
mcp call find_architectural_issues
```

### 2. Code Review Preparation
```bash
# Before major refactoring
npm run scan /path/to/project -- --analyze --output-report

# Identify high-risk areas
mcp call calculate_package_metrics --arguments '{"package_name": "com.example.core"}'
```

### 3. Microservices Architecture Analysis
```bash
# Scan each service separately (clear all data for first service)
npm run scan /path/to/service-a -- --clear-all
npm run scan /path/to/service-b
npm run scan /path/to/service-c

# Analyze inter-service dependencies
mcp call find_classes_calling_method --arguments '{"method_name": "sendNotification"}'
```

## Troubleshooting

### Common Issues
1. **"No source files found"**: Check project path and language selection
2. **"Parse errors"**: Use `--verbose` flag to see detailed error messages
3. **Neo4j connection issues**: Verify Neo4j is running and credentials are correct

### Performance Tips
- Use `--exclude` to skip large generated directories
- Consider scanning in smaller batches for very large codebases
- Use `--include-tests` only when needed for complete analysis

## Output Files

### Scan Report
When using `--output-report`, a file `coderag-scan-report.txt` is created in the project directory with:
- Complete scan statistics
- Entity and relationship breakdowns
- Quality analysis results
- Identified issues and recommendations


================================================
FILE: docs/scanner-usage.md
================================================
# Scanner Usage Guide

The codebase scanner automatically detects your project languages and structure, making it easy to populate the Neo4J graph with your code.

## Automatic Language Detection

🎯 **New Feature**: The scanner now automatically detects project languages using:
- **Build file analysis** (package.json, pom.xml, build.gradle, setup.py, pyproject.toml, etc.)
- **Project metadata extraction** (name, version, description, dependencies, frameworks)
- **Multi-language project support** (e.g., TypeScript frontend + Java backend)
- **Sub-project detection** for mono-repositories
- **Fallback to file extension detection** when build files aren't available

## Scanning a Project

### Command Line Scanner

```bash
# Auto-detect languages and scan (recommended)
npm run scan /path/to/your/project

# Manual language specification (optional override)
npm run scan /path/to/your/project -- --languages typescript,javascript

# Include test files
npm run scan /path/to/your/project -- --include-tests

# Clear existing project data before scanning
npm run scan /path/to/your/project -- --clear-graph

# Clear ALL database data before scanning (all projects)
npm run scan /path/to/your/project -- --clear-all

# Exclude specific directories
npm run scan /path/to/your/project -- --exclude node_modules,dist,build
```

### Remote Repository Scanning

🌐 **New Feature**: Scan repositories directly from GitHub, GitLab, and Bitbucket without local cloning:

```bash
# Public repositories
npm run scan https://github.com/owner/repo.git
npm run scan https://gitlab.com/owner/repo.git
npm run scan https://bitbucket.org/owner/repo.git

# Private repositories (requires authentication - see installation guide)
GITHUB_TOKEN=ghp_xxx npm run scan https://github.com/private/repo.git

# Specific branches or tags
npm run scan https://github.com/owner/repo.git -- --branch develop
npm run scan https://github.com/owner/repo.git -- --branch v2.0.0

# SSH URLs (requires SSH key setup)
npm run scan git@github.com:owner/repo.git

# With additional options
npm run scan https://github.com/owner/repo.git -- --languages typescript,java --analyze
```

**Understanding Clear Options:**
- `--clear-graph`: Clears only the current project's data (useful for re-scanning a single project in a multi-project setup)
- `--clear-all`: Clears the entire database (all projects) - use when starting fresh or resolving data conflicts

### Auto-Detection Examples

```bash
# TypeScript project (detects from package.json)
npm run scan /path/to/react-app
# Output: ✅ TypeScript project detected, Framework: React

# Java project (detects from pom.xml or build.gradle)
npm run scan /path/to/spring-app  
# Output: ✅ Java project detected, Build system: Maven, Framework: Spring Boot

# Python project (detects from setup.py or pyproject.toml)
npm run scan /path/to/django-app
# Output: ✅ Python project detected, Build system: Poetry, Framework: Django

# Multi-language project
npm run scan /path/to/fullstack-app
# Output: ✅ Multi-language project detected: TypeScript (frontend), Java (backend)

# Remote repository examples
npm run scan https://github.com/microsoft/vscode.git
# Output: ✅ TypeScript project detected, Build system: npm, Framework: Electron

npm run scan https://github.com/spring-projects/spring-boot.git  
# Output: ✅ Java project detected, Build system: Gradle, Framework: Spring Boot
```

### Via MCP Tools

Once connected to an AI tool, you can use:

```
Use the scan_dir tool to scan my current project at /path/to/project
```

**Parameters for scan_dir:**
- `directory_path`: Path to your project root
- `languages`: Array of languages (auto-detected if not specified)
- `exclude_paths`: Paths to exclude (auto-suggested based on detected languages)
- `include_tests`: Include test files (`true`/`false`, default based on project type)
- `clear_existing`: Clear existing graph data (`true`/`false`)
- `max_depth`: Maximum directory depth to scan (`10`)

**Remote Repository Tools:**

```
Use the scan_remote_repo tool to analyze https://github.com/owner/repo.git
```

**Parameters for scan_remote_repo:**
- `repository_url`: Git repository URL (GitHub, GitLab, Bitbucket)
- `branch`: Branch name to scan (default: main/master)
- `project_id`: Custom project identifier (optional)
- `languages`: Array of languages (auto-detected if not specified)
- `include_tests`: Include test files (`true`/`false`)
- `clear_existing`: Clear existing graph data (`true`/`false`)
- `use_cache`: Use cached repository if available (`true`/`false`)
- `shallow_clone`: Use shallow clone for faster scanning (`true`/`false`)

**Auto-Detection Features:**
- Languages are automatically detected from build files and file extensions
- Project metadata (name, version, description) extracted from build files
- Framework detection (React, Spring Boot, Django, etc.) from dependencies
- Language-specific exclude paths automatically suggested
- Mono-repository and sub-project detection

## Supported Languages

- **TypeScript** (`.ts`, `.tsx`)
- **JavaScript** (`.js`, `.jsx`)
- **Java** (`.java`)
- **Python** (`.py`)
- **C#** (`.cs`) - *Coming soon*

## What Gets Scanned

The scanner extracts:

**Node Types:**
- Classes and interfaces
- Methods and functions
- Fields and properties
- Packages and modules
- Enums and exceptions

**Relationships:**
- Inheritance (`extends`)
- Interface implementation (`implements`)
- Method calls (`calls`)
- Field references (`references`)
- Containment (`contains`)
- Package membership (`belongs_to`)

## Scanner Configuration

### File Inclusion/Exclusion

**Default Exclusions:**
- `node_modules/`
- `dist/`, `build/`, `out/`
- `.git/`
- Test files (unless `--include-tests` is specified)
- Hidden files and directories (starting with `.`)

**Custom Exclusions:**
```bash
# Exclude additional directories
npm run scan /path/to/project -- --exclude vendor,tmp,cache
```

**Include Test Files:**
```bash
# Include test files in analysis
npm run scan /path/to/project -- --include-tests
```

### Language Selection

**Automatic Detection (Recommended):**
The scanner now uses intelligent language detection:

1. **Build File Analysis** - Analyzes package.json, pom.xml, build.gradle, setup.py, pyproject.toml, etc.
2. **Metadata Extraction** - Extracts project name, version, dependencies, and frameworks
3. **Multi-Language Support** - Handles projects with multiple languages (e.g., frontend + backend)
4. **Sub-Project Detection** - Identifies mono-repositories with multiple sub-projects
5. **File Extension Fallback** - Uses file extensions when build files aren't available

**Manual Override (When Needed):**
```bash
# Override auto-detection for specific languages only
npm run scan /path/to/project -- --languages java,python

# Force TypeScript only (useful for mixed projects)
npm run scan /path/to/project -- --languages typescript
```

### Depth Control

```bash
# Limit scan depth to prevent deep recursion
npm run scan /path/to/project -- --max-depth 5
```

## Scanner Output

### Successful Scan with Auto-Detection

```
=== CodeRAG Project Scanner ===
Scanning: /path/to/my-react-app
Project ID: my-react-app

🔍 Auto-detecting project structure...
✅ TypeScript project detected
📋 Project: my-react-app v1.2.0
🏗️ Framework: React
📦 Build system: npm
💡 Recommendations: Include test files, exclude node_modules, dist

📁 Scanning files...
  TypeScript: 45 files
  JavaScript: 12 files
  
📦 Processing entities...
  Classes: 23
  Interfaces: 8
  Methods: 156
  Fields: 89
  
🔗 Building relationships...
  Inheritance: 12
  Implementations: 15
  Calls: 234
  References: 178
  
✅ Scan completed successfully!

Project Summary:
- Project Name: my-react-app
- Version: 1.2.0
- Framework: React
- Total entities: 276
- Total relationships: 439
- Languages: TypeScript, JavaScript
- Scan duration: 2.3s
```

### Scan Errors

**Common Issues:**

1. **File Permission Errors:**
```
⚠️  Warning: Cannot read file /path/to/file.ts (permission denied)
```

2. **Syntax Errors:**
```
⚠️  Warning: Parse error in /path/to/file.ts:line 45
```

3. **Unsupported Files:**
```
📁 Skipping unsupported file: /path/to/file.xml
```

## Best Practices

### 1. Project Preparation

**Before Scanning:**
- Ensure the project compiles successfully
- Fix any major syntax errors
- Consider excluding generated code directories
- Remove or exclude large vendor directories

### 2. Initial Scan Strategy

**New Project (First Time):**
```bash
# Start with a clean database
npm run scan /path/to/project -- --clear-all
```

**Re-scanning Project:**
```bash
# Update existing project data
npm run scan /path/to/project -- --clear-graph
```

**Adding to Multi-Project Database:**
```bash
# Preserve other projects, add new one
npm run scan /path/to/new-project
```

### 3. Performance Optimization

**Large Projects:**
```bash
# Limit depth and exclude unnecessary directories
npm run scan /path/to/large-project -- \
  --max-depth 8 \
  --exclude node_modules,dist,build,vendor,tmp
```

**Incremental Scanning:**
- For large codebases, consider scanning modules separately
- Use project isolation to manage different components
- Monitor scan duration and adjust exclusions as needed

### 4. Multi-Language Projects

**Automatic Multi-Language Detection:**
```bash
# Auto-detects all languages in polyglot projects
npm run scan /path/to/fullstack-project
# Output: ✅ Multi-language project: TypeScript (frontend), Java (backend), Python (scripts)
```

**Manual Multi-Language Specification:**
```bash
# Override auto-detection for specific languages
npm run scan /path/to/polyglot-project -- \
  --languages typescript,java,python \
  --include-tests
```

**Mono-Repository Handling:**
```bash
# Auto-detects sub-projects in mono-repositories
npm run scan /path/to/monorepo
# Output: 🏗️ Mono-repository detected with 3 sub-projects
# Suggestion: Consider scanning sub-projects separately for better organization
```

## Troubleshooting

### Scanner Won't Start

**Check Prerequisites:**
```bash
# Verify Node.js version
node --version  # Should be 18+

# Verify build
npm run build

# Check Neo4J connection
neo4j status  # or check Docker container
```

### Scanner Fails to Parse Files

**Common Solutions:**

1. **Update Dependencies:**
```bash
npm install
npm run build
```

2. **Check File Encoding:**
   - Ensure files are UTF-8 encoded
   - Check for byte order marks (BOM)

3. **Syntax Validation:**
   - Fix syntax errors in source files
   - Consider excluding problematic files

### Performance Issues

**Slow Scanning:**

1. **Reduce Scope:**
```bash
# Exclude large directories
npm run scan /path/to/project -- --exclude node_modules,dist,vendor
```

2. **Limit Depth:**
```bash
# Reduce maximum directory depth
npm run scan /path/to/project -- --max-depth 6
```

3. **Language Filtering:**
```bash
# Scan only specific languages
npm run scan /path/to/project -- --languages typescript
```

### Database Issues

**Connection Failures:**
- Verify Neo4J is running
- Check `.env` configuration
- Test connection manually

**Memory Issues:**
- Increase Neo4J heap size
- Clear database before large scans
- Use `--clear-all` for fresh start

### Remote Repository Issues

**Authentication Failures:**
```bash
# Error: 401 Unauthorized
# Solution: Check your authentication tokens in .env
GITHUB_TOKEN=ghp_xxx npm run scan https://github.com/private/repo.git
```

**Network Issues:**
```bash
# Error: Failed to clone repository
# Solutions:
# 1. Check internet connection
# 2. Verify repository URL
# 3. Try SSH URL if HTTPS fails
npm run scan git@github.com:owner/repo.git
```

**Branch Not Found:**
```bash
# Error: Branch 'feature-branch' not found
# Solution: Verify branch exists
npm run scan https://github.com/owner/repo.git -- --branch main
```

**Large Repository Timeouts:**
```bash
# Solution: Use shallow clone for faster processing
npm run scan https://github.com/large/repo.git -- --shallow-clone
```

## Advanced Usage

### Custom Scanner Configuration

For advanced users, you can modify scanner behavior by:

1. **Environment Variables:**
```bash
# Set custom scan timeout
export SCANNER_TIMEOUT=300000  # 5 minutes

# Enable debug logging
export LOG_LEVEL=debug
```

2. **Programmatic Usage:**
```javascript
// Use scanner in your own scripts
const { Scanner } = require('./build/scanner');

const scanner = new Scanner({
  neo4jConfig: {
    uri: 'bolt://localhost:7687',
    user: 'neo4j',
    password: 'password'
  },
  scanConfig: {
    languages: ['typescript', 'java'],
    excludePaths: ['node_modules', 'dist'],
    includeTests: false,
    maxDepth: 10
  }
});

await scanner.scanDirectory('/path/to/project');
```

### Batch Scanning

```bash
# Scan multiple projects in sequence
for project in /path/to/projects/*; do
  echo "Scanning $project"
  npm run scan "$project"
done
```

## Next Steps

- [Multi-Project Management](multi-project-management.md) - Manage multiple codebases
- [Available Tools](available-tools.md) - Explore analysis tools
- [Quality Metrics](quality-metrics.md) - Understand code quality analysis



================================================
FILE: docs/semantic-search.md
================================================
# Semantic Code Search Guide

CodeRAG's semantic search feature enables natural language code discovery using AI-powered embeddings. Instead of searching for exact text matches, you can find code by functionality and meaning.

## Overview

Semantic search transforms your code into high-dimensional vectors that capture semantic meaning. This allows you to:

- **🔍 Find by Intent**: Search for "functions that validate email addresses" instead of "email" or "validate"
- **🧠 Discover Similar Code**: Find semantically similar functions, classes, and methods
- **🎯 Understand Functionality**: Locate code that performs specific tasks even with different naming conventions
- **⚡ Enhanced Code Discovery**: Combine semantic similarity with existing graph relationships

## Setup

### Prerequisites

- Neo4j 5.11+ (required for vector index support)
- Embedding provider (see provider-specific setup guides)
- CodeRAG project already scanned

### Provider Setup Guides

Choose your preferred embedding provider:

- **🌐 [OpenAI Setup](semantic-search/openai-setup.md)** - Cloud-based, high quality, requires API key
- **🔒 [Ollama Setup](semantic-search/ollama-setup.md)** - Local, privacy-focused, free after setup
- **🏠 [Custom Endpoints](semantic-search/custom-endpoints.md)** - LLM Studio, Azure OpenAI, enterprise deployments

### Quick Configuration Examples

#### OpenAI (Cloud)
```bash
SEMANTIC_SEARCH_PROVIDER=openai
OPENAI_API_KEY=sk-your-openai-api-key-here
EMBEDDING_MODEL=text-embedding-3-small
```

#### Ollama (Local)
```bash
SEMANTIC_SEARCH_PROVIDER=ollama
EMBEDDING_MODEL=nomic-embed-text
OLLAMA_BASE_URL=http://localhost:11434
```

#### LLM Studio (Local with OpenAI API)
```bash
SEMANTIC_SEARCH_PROVIDER=openai
OPENAI_API_KEY=not-needed
OPENAI_BASE_URL=http://localhost:1234/v1
EMBEDDING_MODEL=text-embedding-3-small
```

### Initialize and Generate Embeddings

After configuring your provider:

1. **Initialize vector indexes:**
   ```bash
   npm run build
   node build/index.js --tool initialize_semantic_search
   ```

2. **Generate embeddings for existing code:**
   ```bash
   node build/index.js --tool update_embeddings --project-id your-project
   ```

### Environment Variables

| Variable | Description | Default | Options |
|----------|-------------|---------|---------|
| `SEMANTIC_SEARCH_PROVIDER` | Embedding provider | `disabled` | `openai`, `ollama`, `disabled` |
| `OPENAI_API_KEY` | OpenAI API key | - | Required for OpenAI provider |
| `OPENAI_BASE_URL` | Custom OpenAI endpoint | - | For LLM Studio, Azure OpenAI, etc. |
| `OLLAMA_BASE_URL` | Ollama server URL | `http://localhost:11434` | For Ollama provider |
| `EMBEDDING_MODEL` | Model for embeddings | Auto-detected | See provider-specific guides |
| `EMBEDDING_DIMENSIONS` | Vector dimensions | Auto-detected | Provider and model dependent |
| `EMBEDDING_MAX_TOKENS` | Max tokens per text | 8000 | Any positive integer |
| `EMBEDDING_BATCH_SIZE` | Batch processing size | 100 | 1-1000 |
| `SIMILARITY_THRESHOLD` | Minimum similarity score | 0.7 | 0.0-1.0 |

## Available Tools

### 1. semantic_search

Search for code using natural language queries.

**Parameters:**
- `query` (required): Natural language description of functionality
- `project_id` (optional): Limit search to specific project
- `node_types` (optional): Filter by code entity types
- `limit` (optional): Maximum results (default: 10)
- `similarity_threshold` (optional): Minimum similarity score
- `include_graph_context` (optional): Include related entities in results
- `max_hops` (optional): Maximum relationship hops for context

**Examples:**
```javascript
// Basic search
{
  "query": "functions that validate email addresses",
  "project_id": "my-web-app",
  "limit": 5
}

// Search with filters
{
  "query": "classes that handle user authentication",
  "node_types": ["class", "interface"],
  "similarity_threshold": 0.8
}

// Search with graph context
{
  "query": "database connection management",
  "include_graph_context": true,
  "max_hops": 2
}
```

### 2. get_similar_code

Find code entities semantically similar to a specific node.

**Parameters:**
- `node_id` (required): ID of the reference code entity
- `project_id` (required): Project containing the reference node
- `limit` (optional): Maximum results (default: 5)

**Example:**
```javascript
{
  "node_id": "UserValidator.validateEmail",
  "project_id": "my-web-app",
  "limit": 10
}
```

### 3. update_embeddings

Generate or refresh embeddings for code entities.

**Parameters:**
- `project_id` (optional): Limit to specific project
- `node_types` (optional): Filter by entity types

**Examples:**
```javascript
// Update all embeddings
{}

// Update specific project
{
  "project_id": "my-web-app"
}

// Update only functions and methods
{
  "node_types": ["function", "method"]
}
```

### 4. initialize_semantic_search

Set up vector indexes and semantic search infrastructure.

**Parameters:** None

**Usage:**
Run once per database to initialize vector search capabilities.

## Usage Examples

### Finding Validation Functions

**Query:**
```
"Find all functions that validate user input data"
```

**What it finds:**
- `validateEmail(email: string)`
- `checkPasswordStrength(password: string)`
- `sanitizeUserInput(input: any)`
- `isValidPhoneNumber(phone: string)`

### Discovering Authentication Code

**Query:**
```
"Show me classes that handle user authentication and login"
```

**What it finds:**
- `AuthService`
- `LoginController` 
- `UserAuthenticator`
- `JwtTokenValidator`

### Finding Database Operations

**Query:**
```
"Functions that interact with database or perform CRUD operations"
```

**What it finds:**
- `UserRepository.save()`
- `DatabaseConnection.execute()`
- `OrderService.createOrder()`
- `ProductDAO.findById()`

### Similar Code Discovery

```javascript
// Find code similar to a specific authentication method
{
  "tool": "get_similar_code",
  "node_id": "AuthService.authenticateUser",
  "project_id": "my-app"
}
```

**Results might include:**
- `LoginService.verifyCredentials()`
- `UserValidator.checkPermissions()`
- `TokenService.validateToken()`

## Best Practices

### 1. Writing Effective Queries

**Good queries:**
- `"functions that validate email addresses"`
- `"classes that handle file uploads"`
- `"methods that process payment transactions"`
- `"utilities for string manipulation"`

**Less effective queries:**
- `"email"` (too vague)
- `"UserService"` (specific naming, use regular search)
- `"function"` (too generic)

### 2. Optimizing Performance

- **Batch Updates**: Update embeddings for entire projects rather than individual files
- **Appropriate Thresholds**: Use similarity threshold 0.6-0.8 for best results
- **Selective Updates**: Only update embeddings for relevant entity types (classes, methods, functions)

### 3. Managing Costs

- **Choose Right Model**: `text-embedding-3-small` offers good performance at lower cost
- **Filter Entity Types**: Focus embeddings on important code entities
- **Batch Processing**: Process multiple entities together to reduce API calls

## Integration with AI Assistants

### Claude Code Integration

When using CodeRAG with Claude Code, semantic search provides enhanced code understanding:

```
User: "Find all the validation functions in my codebase"
Assistant: I'll search for validation functions using semantic search.
[Uses semantic_search tool with query="validation functions"]
```

### Custom Workflows

Combine semantic search with other CodeRAG tools:

1. **Discovery → Analysis**:
   ```
   semantic_search → calculate_ck_metrics → find_architectural_issues
   ```

2. **Similarity → Refactoring**:
   ```
   get_similar_code → analyze duplicate functionality → suggest refactoring
   ```

## Troubleshooting

### Common Issues

**No results returned:**
- Check if embeddings are generated: `update_embeddings`
- Lower similarity threshold
- Try broader query terms

**Poor quality results:**
- Increase similarity threshold
- Use more specific queries
- Ensure embeddings are up to date

**Slow performance:**
- Check Neo4j vector index status
- Reduce batch size for embedding generation
- Consider using smaller embedding model

### Debugging Commands

```bash
# Check embedding status
node build/index.js --tool search_nodes --query "embedding"

# Regenerate embeddings
node build/index.js --tool update_embeddings --project-id your-project

# Test basic search
node build/index.js --tool semantic_search --query "test function"
```

## Cost Considerations

### OpenAI API Costs

Embedding costs depend on:
- **Text volume**: ~$0.0001 per 1K tokens for text-embedding-3-small
- **Entity count**: Typical project: 1000-5000 entities
- **Update frequency**: Initial scan + periodic updates

**Example costs:**
- Small project (1K entities): ~$0.50-2.00 one-time
- Medium project (5K entities): ~$2.50-10.00 one-time  
- Large project (20K entities): ~$10.00-40.00 one-time

### Cost Optimization

1. **Selective Scanning**: Only embed important entity types
2. **Incremental Updates**: Update only changed entities
3. **Model Selection**: Use `text-embedding-3-small` vs `text-embedding-3-large`
4. **Batch Processing**: Maximize batch sizes to reduce API overhead

## Advanced Features

### Hybrid Search

Combine semantic search with graph traversal:

```javascript
{
  "query": "user authentication functions",
  "include_graph_context": true,
  "max_hops": 2
}
```

This finds semantically relevant code AND related entities within 2 relationship hops.

### Multi-Project Search

Search across multiple projects simultaneously:

```javascript
{
  "query": "error handling patterns",
  // No project_id = search all projects
  "limit": 20
}
```

### Custom Similarity Thresholds

Adjust precision vs recall:

- **High precision** (0.8+): Very similar results, fewer matches
- **Balanced** (0.7): Good quality, reasonable quantity  
- **High recall** (0.5-0.6): More matches, potentially less relevant

## Future Enhancements

Coming soon:
- **Local embedding models** for privacy-focused deployments
- **Code-specific embedding models** trained on programming languages
- **Semantic code comparison** for refactoring suggestions
- **Integration with code review workflows**


================================================
FILE: docs/troubleshooting.md
================================================
# Troubleshooting Guide

This guide helps you diagnose and resolve common issues with CodeRAG.

## Common Issues

### 1. Neo4J Connection Failed

**Error:** `Failed to connect to Neo4J`

**Symptoms:**
- CodeRAG fails to start
- Tools return database connection errors
- "Connection refused" or "Connection timeout" messages

**Solutions:**

1. **Verify Neo4J is running:**
   ```bash
   # Check Neo4J Desktop status
   # OR check Docker container
   docker ps | grep neo4j
   
   # OR check system service
   systemctl status neo4j  # Linux
   brew services list | grep neo4j  # macOS
   ```

2. **Check connection details in `.env` file:**
   ```env
   NEO4J_URI=bolt://localhost:7687
   NEO4J_USER=neo4j
   NEO4J_PASSWORD=your_actual_password
   ```

3. **Verify firewall isn't blocking port 7687:**
   ```bash
   # Test connection
   telnet localhost 7687
   # OR
   nc -zv localhost 7687
   ```

4. **Test Neo4J browser access:**
   - Open `http://localhost:7474` in your browser
   - Login with your credentials
   - Run a simple query: `MATCH (n) RETURN count(n)`

5. **Check Neo4J logs for errors:**
   ```bash
   # Neo4J Desktop: Check logs in the database panel
   # Docker: docker logs neo4j-container-name
   # System install: Check /var/log/neo4j/
   ```

### 2. MCP Server Not Found

**Error:** AI tool can't find CodeRAG

**Symptoms:**
- AI assistant reports "MCP server not available"
- CodeRAG tools don't appear in tool list
- Connection timeout when starting MCP

**Solutions:**

1. **Verify MCP configuration file path and syntax:**
   ```bash
   # Check file exists
   ls -la ~/.claude/mcp_servers.json  # macOS/Linux
   dir %APPDATA%\Claude\mcp_servers.json  # Windows
   ```

2. **Validate JSON syntax:**
   ```bash
   # Test JSON validity
   cat ~/.claude/mcp_servers.json | jq .
   ```

3. **Check file permissions:**
   ```bash
   # Ensure file is readable
   chmod 644 ~/.claude/mcp_servers.json
   ```

4. **Ensure the built files exist:**
   ```bash
   # Build the project
   cd /path/to/CodeRAG
   npm run build
   
   # Verify build output
   ls -la build/index.js
   ```

5. **Check the path in MCP configuration is absolute:**
   ```json
   {
     "mcpServers": {
       "coderag": {
         "command": "node",
         "args": ["/absolute/path/to/CodeRAG/build/index.js"],
         "env": {
           "NEO4J_URI": "bolt://localhost:7687",
           "NEO4J_USER": "neo4j",
           "NEO4J_PASSWORD": "your_password"
         }
       }
     }
   }
   ```

6. **Test MCP server manually:**
   ```bash
   # Run MCP server directly
   cd /path/to/CodeRAG
   node build/index.js
   # Should start without errors
   ```

### 3. Parsing Errors

**Error:** Scanner fails to parse files

**Symptoms:**
- "Parse error" messages during scanning
- Files skipped during analysis
- Incomplete project representation

**Solutions:**

1. **Check file encoding (should be UTF-8):**
   ```bash
   # Check file encoding
   file -I path/to/file.java
   
   # Convert if needed
   iconv -f ISO-8859-1 -t UTF-8 file.java > file_utf8.java
   ```

2. **Verify file syntax is valid:**
   ```bash
   # For Java files
   javac -classpath . path/to/file.java
   
   # For TypeScript files
   tsc --noEmit path/to/file.ts
   
   # For Python files
   python -m py_compile path/to/file.py
   ```

3. **Check if language is supported:**
   - TypeScript (`.ts`, `.tsx`)
   - JavaScript (`.js`, `.jsx`)
   - Java (`.java`)
   - Python (`.py`)

4. **Review exclude patterns:**
   ```bash
   # Ensure you're not excluding files you want to scan
   npm run scan /path/to/project -- --exclude node_modules,dist
   ```

5. **Enable debug logging:**
   ```bash
   export LOG_LEVEL=debug
   npm run scan /path/to/project
   ```

### 5. Remote Repository Issues

**Error:** Remote repository scanning fails

**Symptoms:**
- Authentication failures (401 Unauthorized)
- Network timeouts
- Branch not found errors
- Clone failures

**Solutions:**

1. **Authentication Failures:**
   ```bash
   # Check if tokens are configured
   echo $GITHUB_TOKEN
   echo $GITLAB_TOKEN
   
   # Test token validity
   curl -H "Authorization: token $GITHUB_TOKEN" https://api.github.com/user
   
   # Use environment variable if not in .env
   GITHUB_TOKEN=ghp_xxx npm run scan https://github.com/private/repo.git
   ```

2. **Repository URL Issues:**
   ```bash
   # Verify repository URL is accessible
   curl -I https://github.com/owner/repo.git
   
   # Try SSH URL instead of HTTPS
   npm run scan git@github.com:owner/repo.git
   
   # Ensure SSH keys are configured
   ssh -T git@github.com
   ```

3. **Branch Not Found:**
   ```bash
   # List available branches
   git ls-remote https://github.com/owner/repo.git
   
   # Use correct branch name
   npm run scan https://github.com/owner/repo.git -- --branch main
   ```

4. **Network and Timeout Issues:**
   ```bash
   # Use shallow clone for large repositories
   npm run scan https://github.com/large/repo.git -- --shallow-clone
   
   # Check network connectivity
   ping github.com
   ping gitlab.com
   
   # Clear git cache if corrupted
   rm -rf /tmp/coderag-git-cache/*
   ```

5. **Private Repository Access:**
   ```bash
   # For GitHub - create token with 'repo' scope
   # For GitLab - create token with 'read_repository' scope
   # For Bitbucket - create app password with 'Repositories: Read'
   
   # Test different authentication methods
   npm run scan https://username:token@github.com/owner/repo.git
   ```

6. **Self-Hosted Git Servers:**
   ```bash
   # Configure custom GitLab host
   export GITLAB_HOST=gitlab.company.com
   npm run scan https://gitlab.company.com/owner/repo.git
   
   # Use SSH for self-hosted servers
   npm run scan git@gitlab.company.com:owner/repo.git
   ```

**Debug Remote Repository Issues:**
```bash
# Enable debug logging for git operations
export LOG_LEVEL=debug
npm run scan https://github.com/owner/repo.git

# Check git cache statistics
node build/index.js --tool git_cache_stats

# Clear git cache if needed
node build/index.js --tool clear_git_cache
```

### 4. Performance Issues

**Error:** Slow scanning or queries

**Symptoms:**
- Scanner takes very long time
- Queries timeout
- High memory usage

**Solutions:**

1. **Add database indexes (automatically created by scanner):**
   ```cypher
   // Verify indexes exist
   SHOW INDEXES
   
   // Create missing indexes if needed
   CREATE INDEX node_id_index FOR (n:Node) ON (n.id)
   CREATE INDEX project_id_index FOR (n) ON (n.project_id)
   ```

2. **Exclude unnecessary directories:**
   ```bash
   # Exclude large directories
   npm run scan /path/to/project -- --exclude node_modules,dist,build,vendor,.git
   ```

3. **Use `max_depth` parameter to limit scan depth:**
   ```bash
   # Limit directory traversal depth
   npm run scan /path/to/project -- --max-depth 6
   ```

4. **Consider scanning in smaller chunks:**
   ```bash
   # Scan modules separately
   npm run scan /path/to/project/src
   npm run scan /path/to/project/lib
   ```

5. **Increase Neo4J memory:**
   ```bash
   # Edit neo4j.conf
   dbms.memory.heap.initial_size=2G
   dbms.memory.heap.max_size=4G
   dbms.memory.pagecache.size=1G
   ```

## Debug Mode

Enable detailed logging to diagnose issues:

```bash
# Set environment variable
export LOG_LEVEL=debug

# Run with debug output
npm run dev

# Or for scanning
LOG_LEVEL=debug npm run scan /path/to/project
```

**Debug output includes:**
- Database connection details
- File parsing progress
- Query execution times
- Error stack traces
- Memory usage statistics

## Database Maintenance

### Clear all data
```cypher
MATCH (n) DETACH DELETE n
```

### View database schema
```cypher
CALL db.schema.visualization()
```

### Check node counts
```cypher
MATCH (n) RETURN labels(n), count(*)
```

### Find orphaned nodes
```cypher
// Nodes with no relationships
MATCH (n)
WHERE NOT (n)--() 
RETURN n
```

### Check database size
```cypher
// Database statistics
CALL dbms.queryJmx("org.neo4j:instance=kernel#0,name=Store file sizes")
```

## HTTP Mode Issues

### Server Won't Start

**Error:** HTTP server fails to start

**Solutions:**

1. **Check port availability:**
   ```bash
   # Check if port is in use
   lsof -i :3000
   netstat -tlnp | grep :3000
   ```

2. **Try different port:**
   ```bash
   npm start -- --sse --port 8080
   ```

3. **Check firewall settings:**
   ```bash
   # Allow port through firewall (Linux)
   sudo ufw allow 3000
   
   # Check macOS firewall settings
   sudo /usr/libexec/ApplicationFirewall/socketfilterfw --getglobalstate
   ```

### API Endpoints Not Working

**Error:** HTTP requests fail or return errors

**Solutions:**

1. **Verify server is running:**
   ```bash
   curl http://localhost:3000/health
   ```

2. **Check request format:**
   ```bash
   # Correct POST request format
   curl -X POST http://localhost:3000/api/parse/directory \
     -H "Content-Type: application/json" \
     -d '{"directory_path": "/path/to/project"}'
   ```

3. **Enable CORS if needed:**
   ```bash
   # For web applications, server includes CORS headers
   # Check browser console for CORS errors
   ```

## Multi-Project Issues

### Duplicate Project IDs

**Error:** Project ID conflicts

**Solutions:**

1. **Rename project directories:**
   ```bash
   # Use unique directory names
   mv project project-v1
   mv project-new project-v2
   ```

2. **Clear specific project before re-scanning:**
   ```bash
   npm run scan /path/to/project -- --clear-graph
   ```

### Can't Find Specific Project

**Error:** Tools can't locate project

**Solutions:**

1. **List available projects:**
   ```bash
   # Use list_projects tool to see all projects
   mcp call list_projects
   ```

2. **Check project ID spelling:**
   - Project IDs are case-sensitive
   - Derived from directory names
   - Special characters become hyphens

3. **Verify project was scanned successfully:**
   ```bash
   # Check scan logs for errors
   npm run scan /path/to/project
   ```

## Installation Issues

### npm install Fails

**Error:** Package installation errors

**Solutions:**

1. **Update Node.js version:**
   ```bash
   # Check version (need 18+)
   node --version
   
   # Update using nvm
   nvm install 18
   nvm use 18
   ```

2. **Clear npm cache:**
   ```bash
   npm cache clean --force
   rm -rf node_modules package-lock.json
   npm install
   ```

3. **Check network connectivity:**
   ```bash
   # Test npm registry access
   npm ping
   
   # Use different registry if needed
   npm install --registry https://registry.npmjs.org/
   ```

### Build Fails

**Error:** TypeScript compilation errors

**Solutions:**

1. **Update dependencies:**
   ```bash
   npm update
   npm run build
   ```

2. **Check TypeScript version:**
   ```bash
   npx tsc --version
   ```

3. **Clean build directory:**
   ```bash
   rm -rf build/
   npm run build
   ```

## Tool-Specific Issues

### Scanner Issues

**Problem:** Files not being scanned

**Check:**
1. File extensions are supported
2. Files aren't in excluded directories
3. Files have proper permissions
4. Syntax is valid

### Metrics Calculation Issues

**Problem:** Metrics return unexpected values

**Check:**
1. Class exists in database
2. Relationships are properly created
3. Project ID is correct
4. Database indexes are created

### Search Issues

**Problem:** Search returns no results

**Check:**
1. Case sensitivity in search terms
2. Node types are correct
3. Project filtering isn't too restrictive
4. Database actually contains data

## Getting Help

### Diagnostic Information

When seeking help, provide:

1. **CodeRAG version:**
   ```bash
   cat package.json | grep version
   ```

2. **Node.js version:**
   ```bash
   node --version
   npm --version
   ```

3. **Neo4J version:**
   ```cypher
   CALL dbms.components()
   ```

4. **Operating system:**
   ```bash
   uname -a  # Linux/macOS
   ver       # Windows
   ```

5. **Error logs:**
   ```bash
   # Enable debug logging and capture output
   LOG_LEVEL=debug npm start 2>&1 | tee coderag.log
   ```

### Self-Diagnosis Steps

1. **Check the logs** for detailed error messages
2. **Verify your setup** against the [Installation Guide](installation-setup.md)
3. **Test with a simple project** first
4. **Check Neo4J logs** for database issues
5. **Review AI tool logs** for MCP connection issues

### Testing Minimal Configuration

```bash
# Test minimal setup
cd /tmp
mkdir test-coderag
cd test-coderag

# Create simple Java file
echo 'public class Test { public void hello() {} }' > Test.java

# Test scanning
cd /path/to/CodeRAG
npm run scan /tmp/test-coderag
```

### Community Resources

- **Documentation**: Review all documentation files
- **Examples**: Check example configurations
- **GitHub Issues**: Search for similar problems
- **Neo4J Community**: For database-specific issues

## Prevention Tips

### Regular Maintenance

1. **Keep dependencies updated:**
   ```bash
   npm audit
   npm update
   ```

2. **Monitor disk space:**
   ```bash
   # Neo4J database can grow large
   du -sh ~/.neo4j/data
   ```

3. **Regular database cleanup:**
   ```cypher
   // Remove old or test data periodically
   MATCH (n:ProjectContext {project_id: 'test-project'})
   DETACH DELETE n
   ```

### Best Practices

1. **Use version control for MCP configurations**
2. **Test changes with small projects first**
3. **Keep backup of working configurations**
4. **Document custom setups and configurations**
5. **Monitor system resources during large scans**

## Next Steps

- [Installation & Setup](installation-setup.md) - Verify your installation
- [AI Integration](ai-integration.md) - Fix MCP connection issues
- [Scanner Usage](scanner-usage.md) - Resolve scanning problems



================================================
FILE: docs/user-guide.md
================================================
# CodeRAG User Guide

CodeRAG is a powerful MCP (Model Context Protocol) Server that creates a graph database representation of your codebase using Neo4J. This enables advanced code analysis, relationship mapping, and AI-powered insights about your code structure.

## Quick Start

For a complete setup guide, see [Installation & Setup](installation-setup.md).

### Essential Steps

1. **Install Prerequisites**: Node.js 18+, Neo4J 5.11+
2. **Clone and Build**: `git clone repo && npm install && npm run build`
3. **Configure Environment**: Create `.env` with Neo4J connection details
4. **Start Neo4J**: Launch your Neo4J database
5. **Integrate with AI Tool**: Configure MCP server in your AI assistant
6. **Scan Your Project**: Use the scanner to populate the graph

## Documentation Structure

This user guide is organized into focused sections:

### 🚀 Getting Started
- **[Installation & Setup](installation-setup.md)** - Prerequisites, installation, and configuration
- **[AI Integration](ai-integration.md)** - Connect CodeRAG to Claude Code, Windsurf, Cursor, and other AI tools

### 🔍 Core Usage
- **[Scanner Usage](scanner-usage.md)** - Scan your codebase and populate the graph database
- **[Available Tools](available-tools.md)** - Complete reference of all 23 CodeRAG tools
- **[Semantic Search](semantic-search.md)** - Natural language code discovery with AI embeddings
- **[MCP Prompts Guide](mcp-prompts.md)** - Guided workflows for effective code analysis

### 📊 Advanced Features  
- **[Multi-Project Management](multi-project-management.md)** - Manage multiple codebases in one database
- **[Quality Metrics](quality-metrics.md)** - Understand CK metrics, package metrics, and architectural analysis

### 🔧 Support
- **[Troubleshooting](troubleshooting.md)** - Diagnose and resolve common issues

## What CodeRAG Does

CodeRAG transforms your codebase into a searchable graph database, enabling:

- **🔍 Advanced Code Analysis** - Find complex relationships and dependencies
- **🧠 Semantic Code Search** - Find code by functionality using natural language queries
- **📊 Quality Metrics** - Calculate industry-standard metrics (CK metrics, package coupling)  
- **🏗️ Architecture Insights** - Detect design patterns, architectural issues, and violations
- **🤖 AI-Powered Exploration** - Use natural language to query your codebase structure
- **📈 Multi-Project Management** - Analyze multiple codebases in a unified view
- **🌐 Remote Repository Analysis** - Scan GitHub, GitLab, and Bitbucket repositories directly
- **🎯 Smart Language Detection** - Automatically detects project languages from build files and metadata
- **🏗️ Mono-Repository Support** - Handles complex projects with multiple languages and sub-projects

## Example Workflows

### Analyzing a New Project

**Local Project:**
1. **Auto-scan the project (languages detected automatically):**
   ```
   Use scan_dir to scan /path/to/my/project with clear_existing=true
   ```
   *The scanner will automatically detect TypeScript, Java, Python, etc. from build files*

**Remote Repository:**
1. **Scan directly from GitHub/GitLab/Bitbucket:**
   ```
   Use scan_remote_repo with repository_url=https://github.com/owner/repo.git
   ```
   *Automatically clones, scans, and cleans up the repository*

2. **Get overview with project metadata:**
   ```
   Use get_project_summary to show me the codebase overview
   ```
   *Includes auto-extracted project name, version, framework information*

3. **Find issues:**
   ```
   Use find_architectural_issues to identify problems
   ```

4. **Analyze key classes:**
   ```
   Use calculate_ck_metrics for the main service classes
   ```

### Understanding Dependencies

1. **Find a specific class:**
   ```
   Use search_nodes to find classes containing "Service"
   ```

2. **Analyze its dependencies:**
   ```
   Use find_dependencies prompt for target_class=UserService
   ```

3. **Check coupling:**
   ```
   Use calculate_ck_metrics for the UserService class
   ```

### Exploring Architecture

1. **Map inheritance:**
   ```
   Use analyze_inheritance prompt for class_or_interface=BaseEntity
   ```

2. **Find implementations:**
   ```
   Use find_classes_implementing_interface for Repository
   ```

3. **Check package structure:**
   ```
   Use calculate_package_metrics for com.myapp.service
   ```

### Semantic Code Discovery

1. **Search by functionality:**
   ```
   Use semantic_search with query="functions that validate user input"
   ```

2. **Find similar code:**
   ```
   Use get_similar_code for node_id="UserValidator.validateEmail"
   ```

3. **Update embeddings after changes:**
   ```
   Use update_embeddings for project_id="my-project"
   ```

## Quick Reference Card

### Essential Commands
```bash
# Setup
npm install && npm run build

# Auto-detect and scan project (recommended)
npm run scan /path/to/project

# Scan remote repository
npm run scan https://github.com/owner/repo.git

# Scan multiple projects (multi-project support)
npm run scan /path/to/project1
npm run scan /path/to/project2

# List all scanned projects
Use list_projects tool to see all projects with statistics

# Start STDIO mode
npm start

# Start HTTP mode
npm start -- --sse --port 3000
```

### Key MCP Tools
- `scan_dir` - Scan local codebase
- `scan_remote_repo` - Scan remote repositories
- `semantic_search` - Natural language code search
- `get_project_summary` - Overview
- `find_architectural_issues` - Find problems
- `calculate_ck_metrics` - Class quality
- `get_similar_code` - Find similar code entities
- `get_inheritance_hierarchy` - Class relationships

### MCP Prompts
- `setup_code_graph` - New project setup
- `analyze_codebase` - General analysis
- `find_dependencies` - Dependency analysis  
- `analyze_inheritance` - Inheritance analysis

## Need More Help?

This overview gets you started quickly. For detailed information:

- 🚀 **New to CodeRAG?** Start with [Installation & Setup](installation-setup.md)
- 🔧 **Having issues?** Check [Troubleshooting](troubleshooting.md)
- 📖 **Want comprehensive info?** Each section above links to detailed guides

The combination of automated scanning, quality metrics, and AI-powered analysis makes CodeRAG a powerful tool for understanding and improving your codebase architecture.


================================================
FILE: docs/semantic-search/custom-endpoints.md
================================================
# Custom OpenAI Endpoint Configuration

This guide explains how to configure CodeRAG to work with OpenAI-compatible APIs, including LLM Studio, Azure OpenAI, and other local or enterprise deployments.

## Overview

Many services provide OpenAI-compatible APIs that can be used with CodeRAG's semantic search:

- **🏠 LLM Studio**: Local OpenAI-compatible server
- **☁️ Azure OpenAI**: Microsoft's enterprise OpenAI service
- **🔧 Ollama with OpenAI compatibility**: Using Ollama's OpenAI-compatible endpoint
- **🏢 Enterprise deployments**: Custom organizational OpenAI proxies

## Supported Endpoints

### LLM Studio
Local LLM serving with OpenAI API compatibility.

```bash
# Download and run LLM Studio
# Default endpoint: http://localhost:1234/v1

SEMANTIC_SEARCH_PROVIDER=openai
OPENAI_API_KEY=not-needed
OPENAI_BASE_URL=http://localhost:1234/v1
EMBEDDING_MODEL=text-embedding-3-small
```

### Azure OpenAI
Microsoft's enterprise OpenAI service.

```bash
SEMANTIC_SEARCH_PROVIDER=openai
OPENAI_API_KEY=your-azure-api-key
OPENAI_BASE_URL=https://your-resource.openai.azure.com
EMBEDDING_MODEL=text-embedding-3-small
```

### Ollama with OpenAI Compatibility
Ollama can serve an OpenAI-compatible endpoint.

```bash
# Start Ollama with OpenAI compatibility
ollama serve --port 11434

SEMANTIC_SEARCH_PROVIDER=openai
OPENAI_API_KEY=ollama
OPENAI_BASE_URL=http://localhost:11434/v1
EMBEDDING_MODEL=nomic-embed-text
```

### Enterprise Proxy
Custom organizational OpenAI proxy or gateway.

```bash
SEMANTIC_SEARCH_PROVIDER=openai
OPENAI_API_KEY=your-enterprise-key
OPENAI_BASE_URL=https://openai-proxy.yourcompany.com/v1
EMBEDDING_MODEL=text-embedding-3-small
```

## Configuration Steps

### 1. Identify Your Endpoint

Determine the base URL and authentication requirements for your service:

- **LLM Studio**: Usually `http://localhost:1234/v1`
- **Azure OpenAI**: `https://YOUR-RESOURCE.openai.azure.com`
- **Custom proxy**: Provided by your administrator

### 2. Configure Environment Variables

Add to your `.env` file:

```bash
# Required: Set provider to openai
SEMANTIC_SEARCH_PROVIDER=openai

# Required: API key (may be placeholder for some services)
OPENAI_API_KEY=your-api-key-here

# Required: Custom base URL
OPENAI_BASE_URL=https://your-custom-endpoint.com/v1

# Required: Model name (must be supported by endpoint)
EMBEDDING_MODEL=text-embedding-3-small
```

### 3. Verify Model Compatibility

Ensure your endpoint supports embedding models:

```bash
# Test endpoint connectivity (replace URL)
curl -H "Authorization: Bearer your-api-key" \
     -H "Content-Type: application/json" \
     -d '{"model": "text-embedding-3-small", "input": "test"}' \
     https://your-endpoint.com/v1/embeddings
```

### 4. Initialize and Test

```bash
# Build and initialize
npm run build
node build/index.js --tool initialize_semantic_search

# Test with a small embedding generation
node build/index.js --tool update_embeddings --project-id test --limit 1
```

## Provider-Specific Configurations

### LLM Studio Setup

1. **Install LLM Studio**: Download from [lmstudio.ai](https://lmstudio.ai)
2. **Load embedding model**: Download a supported embedding model
3. **Start server**: Enable "Local Server" with OpenAI compatibility
4. **Configure CodeRAG**:

```bash
SEMANTIC_SEARCH_PROVIDER=openai
OPENAI_API_KEY=lm-studio
OPENAI_BASE_URL=http://localhost:1234/v1
EMBEDDING_MODEL=text-embedding-3-small  # Or whatever model you loaded
```

### Azure OpenAI Setup

1. **Create Azure OpenAI resource**: Through Azure portal
2. **Deploy embedding model**: Deploy text-embedding-3-small or similar
3. **Get credentials**: Note API key and endpoint URL
4. **Configure CodeRAG**:

```bash
SEMANTIC_SEARCH_PROVIDER=openai
OPENAI_API_KEY=your-azure-key
OPENAI_BASE_URL=https://your-resource.openai.azure.com
EMBEDDING_MODEL=text-embedding-3-small
```

### Local OpenAI Proxy

For organizations running OpenAI proxies:

```bash
SEMANTIC_SEARCH_PROVIDER=openai
OPENAI_API_KEY=your-org-api-key
OPENAI_BASE_URL=https://openai.yourcompany.com/v1
EMBEDDING_MODEL=text-embedding-3-small
```

## Model Compatibility

### Supported Embedding Models

Most OpenAI-compatible endpoints support these models:

| Model | Dimensions | Best For |
|-------|------------|----------|
| `text-embedding-3-small` | 1536 | General use, cost-effective |
| `text-embedding-3-large` | 3072 | Higher quality, more expensive |
| `text-embedding-ada-002` | 1536 | Legacy, widely supported |

### Custom Models

Some endpoints may provide custom models:

```bash
# Use custom model name
EMBEDDING_MODEL=custom-embedding-model

# May need to specify dimensions manually
EMBEDDING_DIMENSIONS=768
```

## Troubleshooting

### Authentication Issues

```bash
# Test API key
curl -H "Authorization: Bearer $OPENAI_API_KEY" \
     $OPENAI_BASE_URL/models

# For Azure, check key format and endpoint
```

### Model Not Found

```bash
# List available models
curl -H "Authorization: Bearer $OPENAI_API_KEY" \
     $OPENAI_BASE_URL/models

# Update EMBEDDING_MODEL to match available model
```

### Connection Errors

```bash
# Verify base URL format (must end with /v1 usually)
OPENAI_BASE_URL=https://your-endpoint.com/v1

# Check network connectivity
ping your-endpoint.com
```

### SSL/Certificate Issues

```bash
# For local development with self-signed certificates
export NODE_TLS_REJECT_UNAUTHORIZED=0

# Better: Add proper certificates or use HTTP for local testing
OPENAI_BASE_URL=http://localhost:1234/v1
```

## Security Considerations

### API Key Management
- Store keys securely using environment variables
- Avoid committing keys to version control
- Use key rotation practices

### Network Security
- Use HTTPS endpoints in production
- Implement proper firewall rules
- Consider VPN for sensitive deployments

### Data Privacy
- Understand where your code is being processed
- Review endpoint provider's privacy policies
- Consider on-premises solutions for sensitive code

## Performance Optimization

### Batching
```bash
# Adjust batch size based on endpoint limits
EMBEDDING_BATCH_SIZE=100  # Default
EMBEDDING_BATCH_SIZE=50   # If rate limited
```

### Rate Limiting
```bash
# Some endpoints have different rate limits
EMBEDDING_MAX_TOKENS=8000  # Adjust if needed
```

### Monitoring
- Monitor API usage and costs
- Set up alerts for quota limits
- Track embedding generation performance

## Example Configurations

### Complete LLM Studio Setup
```bash
# .env file for LLM Studio
SEMANTIC_SEARCH_PROVIDER=openai
OPENAI_API_KEY=not-required
OPENAI_BASE_URL=http://localhost:1234/v1
EMBEDDING_MODEL=text-embedding-3-small
EMBEDDING_DIMENSIONS=1536
EMBEDDING_BATCH_SIZE=50
SIMILARITY_THRESHOLD=0.7
```

### Enterprise Azure Setup
```bash
# .env file for Azure OpenAI
SEMANTIC_SEARCH_PROVIDER=openai
OPENAI_API_KEY=abc123def456ghi789
OPENAI_BASE_URL=https://mycompany.openai.azure.com
EMBEDDING_MODEL=text-embedding-3-small
EMBEDDING_DIMENSIONS=1536
EMBEDDING_BATCH_SIZE=100
SIMILARITY_THRESHOLD=0.7
```

## Next Steps

- [Ollama Setup Guide](ollama-setup.md)
- [Performance Guide](performance-guide.md) *(coming soon)*
- [Main Semantic Search Documentation](../semantic-search.md)


================================================
FILE: docs/semantic-search/IMPLEMENTATION_SUMMARY.md
================================================
# Local LLM and Custom Endpoint Implementation Summary

This document summarizes the implementation completed to add Ollama integration and custom endpoint configuration to CodeRAG's semantic search functionality.

## ✅ Completed Implementation

### 1. Configuration Enhancements

**Updated `src/types.ts`:**
- Extended `SemanticSearchConfig` interface to support `ollama` provider
- Added `base_url` field for custom endpoint configuration

**Updated `src/config.ts`:**
- Added support for `OLLAMA_BASE_URL` environment variable
- Unified model configuration with `EMBEDDING_MODEL` for all providers
- Implemented intelligent default model selection per provider:
  - OpenAI: `text-embedding-3-small`
  - Ollama: `nomic-embed-text`
- Added automatic dimension detection based on model and provider

### 2. Provider Implementations

**New `OllamaEmbeddingProvider` class:**
- HTTP client for Ollama API communication (`/api/embeddings` endpoint)
- Support for custom base URLs (defaults to `http://localhost:11434`)
- Batch processing with controlled concurrency
- Error handling for network and API errors
- Text truncation for token limits

**Enhanced `OpenAIEmbeddingProvider` class:**
- Support for custom base URLs via `OPENAI_BASE_URL`
- Compatible with LLM Studio, Azure OpenAI, and other OpenAI-compatible APIs
- Maintains backward compatibility


### 3. Service Integration

**Updated `EmbeddingService` factory:**
- Added Ollama provider initialization
- Proper error handling for all provider types
- Backward compatibility maintained

### 4. Environment Configuration

**Updated `.env.example`:**
- Comprehensive configuration examples for all providers
- Clear separation of provider-specific settings
- Auto-detection documentation for models and dimensions
- Performance tuning guidance

### 5. Comprehensive Documentation

**Created provider-specific setup guides:**
- `docs/semantic-search/ollama-setup.md` - Complete Ollama installation and configuration
- `docs/semantic-search/custom-endpoints.md` - LLM Studio, Azure OpenAI, enterprise setups
- `docs/semantic-search/openai-setup.md` - Enhanced OpenAI setup with cost management

**Updated main documentation:**
- `docs/semantic-search.md` - Updated with provider selection guide
- Environment variable reference updated
- Configuration examples for all providers

### 6. Test Coverage

**Comprehensive test suite:**
- `OllamaEmbeddingProvider` unit tests (32 test cases)
- Custom base URL support testing
- Error handling verification
- Batch processing validation
- Service initialization tests for all providers

## 🔧 Configuration Examples

### Ollama (Local)
```bash
SEMANTIC_SEARCH_PROVIDER=ollama
EMBEDDING_MODEL=nomic-embed-text
OLLAMA_BASE_URL=http://localhost:11434
```

### LLM Studio (Local with OpenAI API)
```bash
SEMANTIC_SEARCH_PROVIDER=openai
OPENAI_API_KEY=not-needed
OPENAI_BASE_URL=http://localhost:1234/v1
EMBEDDING_MODEL=text-embedding-3-small
```

### Azure OpenAI (Enterprise)
```bash
SEMANTIC_SEARCH_PROVIDER=openai
OPENAI_API_KEY=your-azure-key
OPENAI_BASE_URL=https://your-resource.openai.azure.com
EMBEDDING_MODEL=text-embedding-3-small
```

## 📊 Supported Models

| Provider | Model | Dimensions | Use Case |
|----------|-------|------------|----------|
| **OpenAI** | `text-embedding-3-small` | 1536 | General use, cost-effective |
| **OpenAI** | `text-embedding-3-large` | 3072 | High precision |
| **Ollama** | `nomic-embed-text` | 768 | Balanced local performance |
| **Ollama** | `mxbai-embed-large` | 1024 | Higher quality local |

## 🚀 Benefits Achieved

### Privacy and Cost Benefits
- **🔒 Local Processing**: Ollama enables complete privacy
- **💰 Zero API Costs**: No charges after Ollama setup
- **🌐 Offline Operation**: Works without internet

### Enterprise Integration
- **🏢 Custom Endpoints**: Support for enterprise OpenAI deployments
- **🔧 LLM Studio**: Easy local OpenAI-compatible server
- **☁️ Azure OpenAI**: Enterprise cloud deployment

### Developer Experience
- **⚙️ Unified Configuration**: Single `EMBEDDING_MODEL` for all providers
- **🎯 Auto-Detection**: Automatic model defaults and dimensions
- **📚 Comprehensive Docs**: Step-by-step setup guides
- **🧪 Complete Testing**: Robust test coverage

## 🔄 Migration Guide

### From Previous OpenAI-only Setup
```bash
# Old configuration
SEMANTIC_SEARCH_PROVIDER=openai
OPENAI_API_KEY=sk-your-key
EMBEDDING_MODEL=text-embedding-3-small

# Still works! No changes needed for existing setups
```

### Adding Ollama Support
```bash
# Install Ollama
brew install ollama  # or download from ollama.ai

# Start Ollama
ollama serve

# Download model
ollama pull nomic-embed-text

# Update .env
SEMANTIC_SEARCH_PROVIDER=ollama
EMBEDDING_MODEL=nomic-embed-text
```

## 🎯 Usage Examples

### Initialization
```bash
# Initialize vector indexes (once)
npm run build
node build/index.js --tool initialize_semantic_search

# Generate embeddings
node build/index.js --tool update_embeddings --project-id your-project
```

### Search Operations
```bash
# Natural language search
node build/index.js --tool semantic_search --query "functions that validate email"

# Find similar code
node build/index.js --tool get_similar_code --node-id "project:ClassId" --limit 5
```

## 📈 Performance Characteristics

| Provider | Setup Complexity | Processing Speed | Quality | Privacy |
|----------|------------------|------------------|---------|---------|
| **OpenAI** | Simple | Fast | Excellent | External |
| **Ollama** | Moderate | Hardware-dependent | Good | Complete |
| **LLM Studio** | Moderate | Hardware-dependent | Variable | Complete |
| **Local*** | Complex | Hardware-dependent | Variable | Complete |

## 🔮 Future Enhancements


### Additional Provider Support
- Hugging Face API integration
- AWS Bedrock embedding models
- Google Cloud Vertex AI

## ✅ Quality Assurance

- **402 tests passing** across 31 test suites
- **TypeScript compilation** successful
- **Complete documentation** with examples
- **Backward compatibility** maintained
- **Production-ready** implementation

## 📞 Support and Troubleshooting

Refer to the provider-specific documentation:
- [Ollama Setup Issues](semantic-search/ollama-setup.md#troubleshooting)
- [Custom Endpoint Problems](semantic-search/custom-endpoints.md#troubleshooting)
- [Main Troubleshooting Guide](../troubleshooting.md)

---

**Implementation completed on:** June 15, 2025  
**All tests passing:** ✅  
**Documentation complete:** ✅  
**Ready for production:** ✅


================================================
FILE: docs/semantic-search/ollama-setup.md
================================================
# Ollama Provider Setup Guide

This guide shows how to set up CodeRAG's semantic search with Ollama for privacy-focused, local embedding generation.

## Overview

The Ollama provider enables local semantic search without sending your code to external services. This approach:

- **🔒 Privacy-First**: Code never leaves your machine
- **💰 Cost-Free**: No API charges after initial setup
- **⚡ Performance**: Direct hardware utilization
- **🌐 Offline**: Works without internet connection

## Prerequisites

- **Ollama installed**: [Download from ollama.ai](https://ollama.ai)
- **Neo4j 5.11+**: Vector index support required
- **Sufficient RAM**: 4GB+ recommended for embedding models

## Installation Steps

### 1. Install Ollama

```bash
# macOS
brew install ollama

# Linux (curl install)
curl -fsSL https://ollama.ai/install.sh | sh

# Windows - Download from ollama.ai
```

### 2. Start Ollama Service

```bash
# Start Ollama server (runs on http://localhost:11434 by default)
ollama serve
```

### 3. Download Embedding Model

```bash
# Recommended: Nomic Embed Text (768 dimensions, optimized for code)
ollama pull nomic-embed-text

# Alternative: MxBai Embed Large (1024 dimensions, higher quality)
ollama pull mxbai-embed-large

# Verify model installation
ollama list
```

### 4. Configure CodeRAG

Add to your `.env` file:

```bash
# Ollama Provider Configuration
SEMANTIC_SEARCH_PROVIDER=ollama
EMBEDDING_MODEL=nomic-embed-text

# Optional: Custom Ollama URL (if not using default)
OLLAMA_BASE_URL=http://localhost:11434

# Auto-detected dimensions (nomic-embed-text: 768, mxbai-embed-large: 1024)
# EMBEDDING_DIMENSIONS=768
```

### 5. Initialize and Generate Embeddings

```bash
# Initialize vector indexes
npm run build
node build/index.js --tool initialize_semantic_search

# Generate embeddings for your project
node build/index.js --tool update_embeddings --project-id your-project
```

## Supported Models

| Model | Dimensions | Memory | Quality | Use Case |
|-------|------------|--------|---------|----------|
| `nomic-embed-text` | 768 | ~1.5GB | High | General code search, balanced performance |
| `mxbai-embed-large` | 1024 | ~2.2GB | Higher | Detailed semantic understanding |

## Configuration Examples

### Basic Setup
```bash
SEMANTIC_SEARCH_PROVIDER=ollama
EMBEDDING_MODEL=nomic-embed-text
```

### Custom Ollama Server
```bash
SEMANTIC_SEARCH_PROVIDER=ollama
EMBEDDING_MODEL=nomic-embed-text
OLLAMA_BASE_URL=http://192.168.1.100:11434
```

### Performance Tuning
```bash
SEMANTIC_SEARCH_PROVIDER=ollama
EMBEDDING_MODEL=nomic-embed-text
EMBEDDING_BATCH_SIZE=50          # Reduce for lower memory usage
EMBEDDING_MAX_TOKENS=4000        # Adjust based on model limits
```

## Usage

Once configured, use semantic search tools normally:

```bash
# Natural language search
node build/index.js --tool semantic_search --query "functions that validate email addresses"

# Find similar code
node build/index.js --tool get_similar_code --node-id "your-function-id" --limit 5
```

## Performance Optimization

### Hardware Recommendations
- **RAM**: 8GB+ for optimal performance
- **CPU**: Multi-core preferred for batch processing
- **Storage**: SSD for faster model loading

### Batch Processing
```bash
# Reduce batch size for memory-constrained systems
EMBEDDING_BATCH_SIZE=25

# Increase for powerful hardware
EMBEDDING_BATCH_SIZE=100
```

### Model Selection
- **Small projects**: Use `nomic-embed-text` for fast processing
- **Large codebases**: Consider `mxbai-embed-large` for better quality
- **Memory limited**: Stick with `nomic-embed-text`

## Troubleshooting

### Ollama Not Responding
```bash
# Check if Ollama is running
curl http://localhost:11434/api/version

# Restart Ollama service
pkill ollama
ollama serve
```

### Model Not Found
```bash
# List available models
ollama list

# Pull missing model
ollama pull nomic-embed-text
```

### Memory Issues
```bash
# Reduce batch size in .env
EMBEDDING_BATCH_SIZE=10

# Or use smaller model
EMBEDDING_MODEL=nomic-embed-text  # Instead of mxbai-embed-large
```

### Connection Errors
```bash
# Verify Ollama URL in .env
OLLAMA_BASE_URL=http://localhost:11434

# Check firewall settings if using remote Ollama
```

## Comparison with Other Providers

| Aspect | Ollama | OpenAI |
|--------|--------|--------|
| **Privacy** | ✅ Complete | ❌ External API |
| **Cost** | ✅ Free | ❌ Pay per use |
| **Setup** | 🟡 Moderate | ✅ Simple |
| **Performance** | 🟡 Local hardware | ✅ Optimized |
| **Quality** | 🟡 Good | ✅ Excellent |

## Next Steps

- [Semantic Search Usage Guide](../semantic-search.md)
- [Performance Optimization](performance-guide.md) *(coming soon)*
- [Custom Endpoint Configuration](custom-endpoints.md) *(coming soon)*
- [Troubleshooting Guide](../troubleshooting.md)


================================================
FILE: docs/semantic-search/openai-setup.md
================================================
# OpenAI Provider Setup Guide

This guide shows how to configure CodeRAG's semantic search with OpenAI's embedding API for high-quality, cloud-based semantic search.

## Overview

The OpenAI provider offers:

- **🏆 Highest Quality**: State-of-the-art embedding models
- **⚡ Fast Processing**: Optimized cloud infrastructure  
- **🔄 Easy Setup**: Simple API key configuration
- **📈 Scalable**: Handles large codebases efficiently

## Prerequisites

- **OpenAI Account**: Sign up at [openai.com](https://openai.com)
- **API Key**: Generated from OpenAI dashboard
- **Neo4j 5.11+**: Vector index support required
- **CodeRAG Project**: Already scanned into Neo4j

## Setup Steps

### 1. Get OpenAI API Key

1. **Create Account**: Visit [platform.openai.com](https://platform.openai.com)
2. **Generate API Key**: Go to API Keys section
3. **Set Usage Limits**: Configure spending limits for safety
4. **Copy Key**: Save the key securely (starts with `sk-`)

### 2. Configure CodeRAG

Add to your `.env` file:

```bash
# OpenAI Provider Configuration
SEMANTIC_SEARCH_PROVIDER=openai
OPENAI_API_KEY=sk-your-openai-api-key-here

# Model Selection (optional - defaults to text-embedding-3-small)
EMBEDDING_MODEL=text-embedding-3-small

# Processing Configuration (optional)
EMBEDDING_BATCH_SIZE=100
EMBEDDING_MAX_TOKENS=8000
SIMILARITY_THRESHOLD=0.7
```

### 3. Initialize Vector Indexes

```bash
# Build the project
npm run build

# Initialize Neo4j vector indexes
node build/index.js --tool initialize_semantic_search
```

### 4. Generate Embeddings

```bash
# Generate embeddings for your project
node build/index.js --tool update_embeddings --project-id your-project

# Or update embeddings for all projects
node build/index.js --tool update_embeddings
```

## Model Selection

### Available Models

| Model | Dimensions | Cost | Quality | Best For |
|-------|------------|------|---------|----------|
| `text-embedding-3-small` | 1536 | Lower | Very Good | General use, cost-effective |
| `text-embedding-3-large` | 3072 | Higher | Excellent | High-precision requirements |
| `text-embedding-ada-002` | 1536 | Medium | Good | Legacy compatibility |

### Recommendations

#### For Most Projects
```bash
EMBEDDING_MODEL=text-embedding-3-small
```
- **Cost-effective**: ~5x cheaper than large model
- **Fast processing**: Lower token consumption
- **Excellent quality**: Suitable for most code search tasks

#### For Large Enterprise Codebases
```bash
EMBEDDING_MODEL=text-embedding-3-large
```
- **Highest quality**: Better semantic understanding
- **Complex code**: Better at understanding intricate relationships
- **Critical applications**: When search quality is paramount

#### For Legacy Compatibility
```bash
EMBEDDING_MODEL=text-embedding-ada-002
```
- **Proven stability**: Well-tested model
- **Consistent results**: Predictable behavior
- **Migration path**: Easy upgrade to newer models

## Configuration Options

### Basic Configuration
```bash
SEMANTIC_SEARCH_PROVIDER=openai
OPENAI_API_KEY=sk-your-key-here
EMBEDDING_MODEL=text-embedding-3-small
```

### Performance Tuning
```bash
SEMANTIC_SEARCH_PROVIDER=openai
OPENAI_API_KEY=sk-your-key-here
EMBEDDING_MODEL=text-embedding-3-small

# Optimize for speed
EMBEDDING_BATCH_SIZE=100        # Max batch size
EMBEDDING_MAX_TOKENS=8000       # Max tokens per request

# Adjust similarity threshold
SIMILARITY_THRESHOLD=0.7        # 0.6-0.8 recommended range
```

### Cost Optimization
```bash
SEMANTIC_SEARCH_PROVIDER=openai
OPENAI_API_KEY=sk-your-key-here
EMBEDDING_MODEL=text-embedding-3-small  # Most cost-effective

# Reduce batch size to control costs
EMBEDDING_BATCH_SIZE=50
EMBEDDING_MAX_TOKENS=4000

# Higher threshold = fewer results = lower query costs
SIMILARITY_THRESHOLD=0.8
```

## Usage Examples

### Basic Semantic Search
```bash
# Find functions that validate input
node build/index.js --tool semantic_search --query "validate user input"

# Search for error handling code
node build/index.js --tool semantic_search --query "error handling exception logging"
```

### Advanced Queries
```bash
# Find similar code to a specific function
node build/index.js --tool get_similar_code --node-id "myapp:UserService.validateEmail" --limit 5

# Search within specific node types
node build/index.js --tool semantic_search --query "authentication" --node-types "Method,Function"

# Project-specific search
node build/index.js --tool semantic_search --query "database connection" --project-id "backend-api"
```

## Cost Management

### Understanding Costs

OpenAI charges per token processed:

- **text-embedding-3-small**: $0.00002 / 1K tokens
- **text-embedding-3-large**: $0.00013 / 1K tokens
- **text-embedding-ada-002**: $0.00010 / 1K tokens

### Cost Estimation

For a typical TypeScript project:

```
Medium project (50k lines): ~$2-5 for initial embeddings
Large project (200k lines): ~$8-20 for initial embeddings
Enterprise (1M lines): ~$40-100 for initial embeddings
```

### Cost Optimization Strategies

1. **Use Smaller Model**: `text-embedding-3-small` for most use cases
2. **Batch Processing**: Max batch size for efficiency
3. **Selective Updates**: Only update changed code
4. **Token Limits**: Set appropriate `EMBEDDING_MAX_TOKENS`

```bash
# Cost-optimized configuration
EMBEDDING_MODEL=text-embedding-3-small
EMBEDDING_BATCH_SIZE=100
EMBEDDING_MAX_TOKENS=4000
```

## Performance Optimization

### Batch Processing
```bash
# Optimize batch size based on project size
EMBEDDING_BATCH_SIZE=100  # Large projects
EMBEDDING_BATCH_SIZE=50   # Medium projects  
EMBEDDING_BATCH_SIZE=25   # Small projects or rate limiting
```

### Token Management
```bash
# Balance quality vs cost
EMBEDDING_MAX_TOKENS=8000   # High quality, higher cost
EMBEDDING_MAX_TOKENS=4000   # Balanced
EMBEDDING_MAX_TOKENS=2000   # Cost-optimized
```

### API Rate Limits

OpenAI has rate limits that may affect large projects:

- **Tier 1**: 3 RPM, 40k TPM
- **Tier 2**: 3,500 RPM, 90k TPM  
- **Tier 3+**: Higher limits based on usage

## Troubleshooting

### API Key Issues
```bash
# Test API key
curl -H "Authorization: Bearer $OPENAI_API_KEY" \
     https://api.openai.com/v1/models

# Check key format (should start with sk-)
echo $OPENAI_API_KEY
```

### Rate Limiting
```bash
# Reduce batch size if rate limited
EMBEDDING_BATCH_SIZE=25

# Error: "Rate limit exceeded"
# Solution: Wait and retry, or upgrade OpenAI tier
```

### Model Not Found
```bash
# Verify model name
EMBEDDING_MODEL=text-embedding-3-small  # Correct
EMBEDDING_MODEL=text-embedding-small     # Incorrect

# List available models
curl -H "Authorization: Bearer $OPENAI_API_KEY" \
     https://api.openai.com/v1/models
```

### Connection Issues
```bash
# Check network connectivity
curl https://api.openai.com/v1/models

# Verify firewall settings
# Check proxy configuration if behind corporate firewall
```

## Security Best Practices

### API Key Security
- **Environment Variables**: Never commit keys to code
- **Secure Storage**: Use secure secret management
- **Key Rotation**: Rotate keys regularly
- **Minimal Permissions**: Use API keys with minimal required scope

### Data Privacy
- **Code Transmission**: Your code is sent to OpenAI for embedding
- **Data Retention**: Review OpenAI's data usage policies
- **Sensitive Code**: Consider local alternatives for highly sensitive code

### Network Security
- **HTTPS Only**: OpenAI API uses HTTPS by default
- **Corporate Proxies**: Configure proxy settings if required
- **Firewall Rules**: Allow outbound HTTPS to api.openai.com

## Next Steps

- [Custom Endpoints Guide](custom-endpoints.md) - For LLM Studio, Azure OpenAI
- [Ollama Setup Guide](ollama-setup.md) - For local, privacy-focused alternative
- [Performance Guide](performance-guide.md) *(coming soon)*
- [Main Semantic Search Documentation](../semantic-search.md)

## Comparison with Other Providers

| Feature | OpenAI | Ollama |
|---------|--------|--------|
| **Quality** | ✅ Excellent | 🟡 Good |
| **Setup** | ✅ Simple | 🟡 Moderate |
| **Cost** | ❌ Pay per use | ✅ Free |
| **Privacy** | ❌ External API | ✅ Local |
| **Performance** | ✅ Fast | 🟡 Hardware dependent |
| **Reliability** | ✅ High | 🟡 Good |


================================================
FILE: src/config.ts
================================================
import dotenv from 'dotenv';
import { Neo4jConfig, ProjectConfig, SemanticSearchConfig } from './types.js';

dotenv.config();

export function getConfig(): Neo4jConfig {
  const uri = process.env.NEO4J_URI;
  const user = process.env.NEO4J_USER;
  const password = process.env.NEO4J_PASSWORD;

  if (!uri || !user || !password) {
    throw new Error('Missing required Neo4J configuration. Please set NEO4J_URI, NEO4J_USER, and NEO4J_PASSWORD environment variables.');
  }

  return {
    uri,
    user,
    password
  };
}

export function getProjectConfig(): ProjectConfig {
  return {
    isolation_strategy: (process.env.PROJECT_ISOLATION_STRATEGY as 'shared_db' | 'separate_db') || 'shared_db',
    default_project: process.env.DEFAULT_PROJECT_ID || undefined,
    cross_project_analysis: process.env.CROSS_PROJECT_ANALYSIS === 'true',
    max_projects_shared_db: parseInt(process.env.MAX_PROJECTS_SHARED_DB || '100', 10)
  };
}

// Project context utilities
export class ProjectContextManager {
  private static currentProject: string | undefined;

  static setCurrentProject(projectId: string): void {
    this.currentProject = projectId;
  }

  static getCurrentProject(): string | undefined {
    return this.currentProject;
  }

  static requireCurrentProject(): string {
    if (!this.currentProject) {
      const defaultProject = getProjectConfig().default_project;
      if (defaultProject) {
        this.currentProject = defaultProject;
        return defaultProject;
      }
      throw new Error('No current project set. Use setCurrentProject() or configure DEFAULT_PROJECT_ID.');
    }
    return this.currentProject;
  }

  static clearCurrentProject(): void {
    this.currentProject = undefined;
  }

  // Utility to generate project-scoped IDs
  static generateProjectScopedId(entityId: string, projectId?: string): string {
    const pid = projectId || this.requireCurrentProject();
    return `${pid}:${entityId}`;
  }

  // Utility to parse project-scoped IDs
  static parseProjectScopedId(scopedId: string): { projectId: string; entityId: string } {
    const [projectId, ...entityParts] = scopedId.split(':');
    return {
      projectId,
      entityId: entityParts.join(':')
    };
  }
}

export function getSemanticSearchConfig(): SemanticSearchConfig {
  const provider = (process.env.SEMANTIC_SEARCH_PROVIDER as 'openai' | 'ollama' | 'disabled') || 'disabled';
  const model = process.env.EMBEDDING_MODEL || getDefaultModel(provider);
  const api_key = process.env.OPENAI_API_KEY;
  const base_url = process.env.OPENAI_BASE_URL || process.env.OLLAMA_BASE_URL;
  
  // Default dimensions based on model and provider
  const defaultDimensions = getDefaultDimensions(model, provider);

  return {
    provider,
    model,
    api_key,
    base_url,
    dimensions: parseInt(process.env.EMBEDDING_DIMENSIONS || defaultDimensions.toString(), 10),
    max_tokens: parseInt(process.env.EMBEDDING_MAX_TOKENS || '8000', 10),
    batch_size: parseInt(process.env.EMBEDDING_BATCH_SIZE || '100', 10),
    similarity_threshold: parseFloat(process.env.SIMILARITY_THRESHOLD || '0.7')
  };
}

function getDefaultModel(provider: string): string {
  switch (provider) {
    case 'openai':
      return 'text-embedding-3-small';
    case 'ollama':
      return 'nomic-embed-text';
    default:
      return 'text-embedding-3-small';
  }
}

function getDefaultDimensions(model: string, provider: string): number {
  // OpenAI models
  if (provider === 'openai') {
    switch (model) {
      case 'text-embedding-3-small':
        return 1536;
      case 'text-embedding-3-large':
        return 3072;
      case 'text-embedding-ada-002':
        return 1536;
      default:
        return 1536;
    }
  }
  
  // Ollama models
  if (provider === 'ollama') {
    switch (model) {
      case 'nomic-embed-text':
        return 768;
      case 'mxbai-embed-large':
        return 1024;
      default:
        return 768;
    }
  }
  
  return 1536; // Default fallback
}


================================================
FILE: src/index.ts
================================================
#!/usr/bin/env node

import { getConfig } from './config.js';
import { Neo4jClient } from './graph/neo4j-client.js';
import { StdioHandler } from './mcp/stdio-handler.js';
import { HTTPHandler } from './mcp/http-handler.js';

async function main() {
  try {
    // Get configuration
    const config = getConfig();
    
    // Initialize Neo4J client
    const client = new Neo4jClient(config);
    await client.connect();
    await client.initializeDatabase();

    // Determine server mode from command line arguments
    const args = process.argv.slice(2);
    const mode = args.includes('--http') || args.includes('--sse') ? 'http' : 'stdio';
    const port = args.includes('--port') ? 
      parseInt(args[args.indexOf('--port') + 1]) || 3000 : 3000;

    if (mode === 'http') {
      // Start HTTP server with official MCP SDK
      const httpHandler = new HTTPHandler(client, port);
      await httpHandler.start();
    } else {
      // Start STDIO server (default)
      const stdioHandler = new StdioHandler(client);
      await stdioHandler.start();
    }

    // Handle graceful shutdown
    process.on('SIGINT', async () => {
      console.error('Shutting down...');
      await client.disconnect();
      process.exit(0);
    });

    process.on('SIGTERM', async () => {
      console.error('Shutting down...');
      await client.disconnect();
      process.exit(0);
    });

  } catch (error) {
    console.error('Failed to start server:', error);
    process.exit(1);
  }
}

// Only run if this is the main module
if (import.meta.url === `file://${process.argv[1]}`) {
  main();
}


================================================
FILE: src/types.ts
================================================
export interface AnnotationInfo {
  name: string;                    // e.g., "@Override", "@Component", "@pytest.fixture"
  type: 'annotation' | 'decorator' | 'pragma';
  parameters?: Array<{
    name?: string;                 // Named parameter (e.g., "value" in @RequestMapping(value="/api"))
    value: string;                 // Parameter value
    type?: string;                 // Parameter type if determinable
  }>;
  source_line?: number;           // Line number where annotation appears
  framework?: string;             // e.g., "Spring", "JUnit", "Flask", "Angular"
  category?: string;              // e.g., "testing", "injection", "validation", "lifecycle"
}

export interface CodeNode {
  id: string;
  project_id: string;
  type: 'class' | 'interface' | 'enum' | 'exception' | 'function' | 'method' | 'field' | 'package' | 'module';
  name: string;
  qualified_name: string;
  description?: string;
  source_file?: string;
  start_line?: number;
  end_line?: number;
  modifiers?: string[];
  attributes?: {
    parameters?: Array<{
      name: string;
      type: string;
      description?: string;
    }>;
    return_type?: string;
    annotations?: AnnotationInfo[];
    [key: string]: any;
  };
}

export interface CodeEdge {
  id: string;
  project_id: string;
  type: 'calls' | 'implements' | 'extends' | 'contains' | 'references' | 'throws' | 'belongs_to';
  source: string;
  target: string;
  attributes?: {
    [key: string]: any;
  };
}

export interface Neo4jConfig {
  uri: string;
  user: string;
  password: string;
}

export interface ProjectConfig {
  isolation_strategy: 'shared_db' | 'separate_db';
  default_project?: string;
  cross_project_analysis: boolean;
  max_projects_shared_db: number;
}

export interface ProjectContext {
  project_id: string;
  name?: string;
  description?: string;
  created_at?: Date;
  updated_at?: Date;
}

export interface QueryResult {
  nodes?: CodeNode[];
  edges?: CodeEdge[];
  records?: any[];
}

// Semantic Search Types
export interface SemanticEmbedding {
  vector: number[];
  model: string;
  version: string;
  created_at: Date;
}

export interface SemanticSearchConfig {
  provider: 'openai' | 'ollama' | 'disabled';
  model: string;
  api_key?: string;
  base_url?: string;
  dimensions: number;
  max_tokens: number;
  batch_size: number;
  similarity_threshold: number;
}

export interface SemanticSearchResult {
  node: CodeNode;
  similarity_score: number;
  matched_content: string;
}

export interface SemanticSearchParams {
  query: string;
  project_id?: string;
  node_types?: CodeNode['type'][];
  limit?: number;
  similarity_threshold?: number;
}


================================================
FILE: src/analysis/metrics-manager.ts
================================================
import { Neo4jClient } from '../graph/neo4j-client.js';

export interface CKMetrics {
  classId: string;
  className: string;
  wmc: number;        // Weighted Methods per Class
  dit: number;        // Depth of Inheritance Tree
  noc: number;        // Number of Children
  cbo: number;        // Coupling Between Objects
  rfc: number;        // Response for Class
  lcom: number;       // Lack of Cohesion in Methods (basic version)
}

export interface PackageMetrics {
  packageName: string;
  ca: number;         // Afferent Coupling
  ce: number;         // Efferent Coupling
  instability: number; // I = Ce / (Ce + Ca)
  abstractness: number; // A = abstract classes / total classes
  distance: number;    // D = |A + I - 1|
}

export interface ArchitecturalIssue {
  type: 'circular_dependency' | 'layer_violation' | 'god_class' | 'high_coupling';
  severity: 'low' | 'medium' | 'high' | 'critical';
  description: string;
  entities: string[];
  metrics?: Record<string, number>;
}

export class MetricsManager {
  constructor(private client: Neo4jClient) {}

  async calculateCKMetrics(classId: string): Promise<CKMetrics> {
    const className = await this.getClassName(classId);
    
    const [wmc, dit, noc, cbo, rfc, lcom] = await Promise.all([
      this.calculateWMC(classId),
      this.calculateDIT(classId),
      this.calculateNOC(classId),
      this.calculateCBO(classId),
      this.calculateRFC(classId),
      this.calculateLCOM(classId)
    ]);

    return {
      classId,
      className,
      wmc,
      dit,
      noc,
      cbo,
      rfc,
      lcom
    };
  }

  async calculatePackageMetrics(packageName: string): Promise<PackageMetrics> {
    const [ca, ce, abstractness] = await Promise.all([
      this.calculateAfferentCoupling(packageName),
      this.calculateEfferentCoupling(packageName),
      this.calculateAbstractness(packageName)
    ]);

    const instability = (ca + ce) === 0 ? 0 : ce / (ca + ce);
    const distance = Math.abs(abstractness + instability - 1);

    return {
      packageName,
      ca,
      ce,
      instability,
      abstractness,
      distance
    };
  }

  async findArchitecturalIssues(): Promise<ArchitecturalIssue[]> {
    const issues: ArchitecturalIssue[] = [];

    // Find circular dependencies
    const circularDeps = await this.findCircularDependencies();
    issues.push(...circularDeps);

    // Find god classes
    const godClasses = await this.findGodClasses();
    issues.push(...godClasses);

    // Find highly coupled classes
    const highCoupling = await this.findHighlyCoupledClasses();
    issues.push(...highCoupling);

    return issues;
  }

  async calculateProjectSummary(): Promise<{
    totalClasses: number;
    totalMethods: number;
    totalPackages: number;
    averageMetrics: {
      avgCBO: number;
      avgRFC: number;
      avgDIT: number;
    };
    issueCount: number;
  }> {
    const [
      totalClasses,
      totalMethods,
      totalPackages,
      avgMetrics,
      issues
    ] = await Promise.all([
      this.getTotalClasses(),
      this.getTotalMethods(),
      this.getTotalPackages(),
      this.getAverageMetrics(),
      this.findArchitecturalIssues()
    ]);

    return {
      totalClasses,
      totalMethods,
      totalPackages,
      averageMetrics: avgMetrics,
      issueCount: issues.length
    };
  }

  // CK Metrics Implementation
  private async calculateWMC(classId: string): Promise<number> {
    const query = `
      MATCH (class:CodeNode {id: $classId})-[:CONTAINS]->(method:CodeNode {type: 'method'})
      RETURN count(method) as wmc
    `;
    const result = await this.client.runQuery(query, { classId });
    return result.records[0]?.get('wmc').toNumber() || 0;
  }

  private async calculateDIT(classId: string): Promise<number> {
    const query = `
      MATCH path = (class:CodeNode {id: $classId})-[:EXTENDS*]->(ancestor:CodeNode)
      RETURN max(length(path)) as dit
    `;
    const result = await this.client.runQuery(query, { classId });
    return result.records[0]?.get('dit')?.toNumber() || 0;
  }

  private async calculateNOC(classId: string): Promise<number> {
    const query = `
      MATCH (class:CodeNode {id: $classId})<-[:EXTENDS]-(child:CodeNode)
      RETURN count(child) as noc
    `;
    const result = await this.client.runQuery(query, { classId });
    return result.records[0]?.get('noc').toNumber() || 0;
  }

  private async calculateCBO(classId: string): Promise<number> {
    const query = `
      MATCH (class:CodeNode {id: $classId})
      OPTIONAL MATCH (class)-[:CALLS|REFERENCES]-(other:CodeNode {type: 'class'})
      WHERE other.id <> $classId
      RETURN count(DISTINCT other) as cbo
    `;
    const result = await this.client.runQuery(query, { classId });
    return result.records[0]?.get('cbo').toNumber() || 0;
  }

  private async calculateRFC(classId: string): Promise<number> {
    const query = `
      MATCH (class:CodeNode {id: $classId})-[:CONTAINS]->(method:CodeNode {type: 'method'})
      OPTIONAL MATCH (method)-[:CALLS]->(calledMethod:CodeNode {type: 'method'})
      RETURN count(DISTINCT method) + count(DISTINCT calledMethod) as rfc
    `;
    const result = await this.client.runQuery(query, { classId });
    return result.records[0]?.get('rfc').toNumber() || 0;
  }

  private async calculateLCOM(classId: string): Promise<number> {
    // Simplified LCOM calculation - basic version
    // More sophisticated version would require field usage analysis
    const query = `
      MATCH (class:CodeNode {id: $classId})-[:CONTAINS]->(method:CodeNode {type: 'method'})
      MATCH (class)-[:CONTAINS]->(field:CodeNode {type: 'field'})
      RETURN count(DISTINCT method) as methods, count(DISTINCT field) as fields
    `;
    const result = await this.client.runQuery(query, { classId });
    const record = result.records[0];
    const methods = record?.get('methods').toNumber() || 0;
    const fields = record?.get('fields').toNumber() || 0;
    
    // Basic LCOM approximation
    return methods > 0 && fields > 0 ? Math.max(0, methods - fields) : 0;
  }

  // Package Metrics Implementation
  private async calculateAfferentCoupling(packageName: string): Promise<number> {
    const query = `
      MATCH (external:CodeNode)-[:CALLS|REFERENCES]->(internal:CodeNode)
      WHERE internal.qualified_name STARTS WITH $packagePrefix
      AND NOT external.qualified_name STARTS WITH $packagePrefix
      RETURN count(DISTINCT external) as ca
    `;
    const result = await this.client.runQuery(query, { packagePrefix: packageName + '.' });
    return result.records[0]?.get('ca').toNumber() || 0;
  }

  private async calculateEfferentCoupling(packageName: string): Promise<number> {
    const query = `
      MATCH (internal:CodeNode)-[:CALLS|REFERENCES]->(external:CodeNode)
      WHERE internal.qualified_name STARTS WITH $packagePrefix
      AND NOT external.qualified_name STARTS WITH $packagePrefix
      RETURN count(DISTINCT external) as ce
    `;
    const result = await this.client.runQuery(query, { packagePrefix: packageName + '.' });
    return result.records[0]?.get('ce').toNumber() || 0;
  }

  private async calculateAbstractness(packageName: string): Promise<number> {
    const query = `
      MATCH (class:CodeNode {type: 'class'})
      WHERE class.qualified_name STARTS WITH $packagePrefix
      RETURN 
        count(CASE WHEN 'abstract' IN class.modifiers OR class.type = 'interface' THEN 1 END) as abstractClasses,
        count(class) as totalClasses
    `;
    const result = await this.client.runQuery(query, { packagePrefix: packageName + '.' });
    const record = result.records[0];
    const abstract = record?.get('abstractClasses').toNumber() || 0;
    const total = record?.get('totalClasses').toNumber() || 0;
    
    return total > 0 ? abstract / total : 0;
  }

  // Architectural Analysis
  private async findCircularDependencies(): Promise<ArchitecturalIssue[]> {
    const query = `
      MATCH (p1:CodeNode {type: 'package'})-[:DEPENDS_ON*2..5]->(p2:CodeNode {type: 'package'})
      WHERE p1 = p2
      RETURN DISTINCT p1.name as packageName
    `;
    const result = await this.client.runQuery(query);
    
    return result.records.map(record => ({
      type: 'circular_dependency' as const,
      severity: 'high' as const,
      description: `Circular dependency detected in package: ${record.get('packageName')}`,
      entities: [record.get('packageName')]
    }));
  }

  private async findGodClasses(): Promise<ArchitecturalIssue[]> {
    const query = `
      MATCH (class:CodeNode {type: 'class'})-[:CONTAINS]->(method:CodeNode {type: 'method'})
      WITH class, count(method) as methodCount
      WHERE methodCount > 20
      OPTIONAL MATCH (class)-[:CALLS|REFERENCES]-(other:CodeNode {type: 'class'})
      WITH class, methodCount, count(DISTINCT other) as coupling
      WHERE coupling > 10
      RETURN class.id as classId, class.name as className, methodCount, coupling
    `;
    const result = await this.client.runQuery(query);
    
    return result.records.map(record => ({
      type: 'god_class' as const,
      severity: 'high' as const,
      description: `God class detected: ${record.get('className')} (${record.get('methodCount')} methods, ${record.get('coupling')} couplings)`,
      entities: [record.get('classId')],
      metrics: {
        methodCount: record.get('methodCount').toNumber(),
        coupling: record.get('coupling').toNumber()
      }
    }));
  }

  private async findHighlyCoupledClasses(): Promise<ArchitecturalIssue[]> {
    const query = `
      MATCH (class:CodeNode {type: 'class'})-[:CALLS|REFERENCES]-(other:CodeNode {type: 'class'})
      WITH class, count(DISTINCT other) as coupling
      WHERE coupling > 15
      RETURN class.id as classId, class.name as className, coupling
      ORDER BY coupling DESC
    `;
    const result = await this.client.runQuery(query);
    
    return result.records.map(record => ({
      type: 'high_coupling' as const,
      severity: record.get('coupling').toNumber() > 25 ? 'critical' as const : 'high' as const,
      description: `Highly coupled class: ${record.get('className')} (${record.get('coupling')} couplings)`,
      entities: [record.get('classId')],
      metrics: {
        coupling: record.get('coupling').toNumber()
      }
    }));
  }

  // Helper methods
  private async getClassName(classId: string): Promise<string> {
    const query = 'MATCH (class:CodeNode {id: $classId}) RETURN class.name as name';
    const result = await this.client.runQuery(query, { classId });
    return result.records[0]?.get('name') || 'Unknown';
  }

  private async getTotalClasses(): Promise<number> {
    const query = 'MATCH (class:CodeNode {type: "class"}) RETURN count(class) as total';
    const result = await this.client.runQuery(query);
    return result.records[0]?.get('total').toNumber() || 0;
  }

  private async getTotalMethods(): Promise<number> {
    const query = 'MATCH (method:CodeNode {type: "method"}) RETURN count(method) as total';
    const result = await this.client.runQuery(query);
    return result.records[0]?.get('total').toNumber() || 0;
  }

  private async getTotalPackages(): Promise<number> {
    const query = 'MATCH (pkg:CodeNode {type: "package"}) RETURN count(pkg) as total';
    const result = await this.client.runQuery(query);
    return result.records[0]?.get('total').toNumber() || 0;
  }

  private async getAverageMetrics(): Promise<{ avgCBO: number; avgRFC: number; avgDIT: number }> {
    const query = `
      MATCH (class:CodeNode {type: 'class'})
      OPTIONAL MATCH (class)-[:CALLS|REFERENCES]-(other:CodeNode {type: 'class'})
      WITH class, count(DISTINCT other) as cbo
      OPTIONAL MATCH (class)-[:CONTAINS]->(method:CodeNode {type: 'method'})
      OPTIONAL MATCH (method)-[:CALLS]->(calledMethod:CodeNode {type: 'method'})
      WITH class, cbo, count(DISTINCT method) + count(DISTINCT calledMethod) as rfc
      OPTIONAL MATCH path = (class)-[:EXTENDS*]->(ancestor:CodeNode)
      WITH class, cbo, rfc, max(length(path)) as dit
      RETURN avg(cbo) as avgCBO, avg(rfc) as avgRFC, avg(dit) as avgDIT
    `;
    const result = await this.client.runQuery(query);
    const record = result.records[0];
    
    return {
      avgCBO: record?.get('avgCBO') || 0,
      avgRFC: record?.get('avgRFC') || 0,
      avgDIT: record?.get('avgDIT') || 0
    };
  }
}


================================================
FILE: src/cli/scan.ts
================================================
#!/usr/bin/env node

import { Command } from 'commander';
import * as path from 'path';
import * as fs from 'fs';
import { getConfig } from '../config.js';
import { Neo4jClient } from '../graph/neo4j-client.js';
import { CodebaseScanner } from '../scanner/codebase-scanner.js';
import { MetricsManager } from '../analysis/metrics-manager.js';
import { ScanConfig, Language } from '../scanner/types.js';

const program = new Command();

program
  .name('coderag-scan')
  .description(`Scan a codebase and populate the CodeRAG graph database

Authentication for private repositories:
  Set environment variables:
  - GITHUB_TOKEN for GitHub repositories
  - GITLAB_TOKEN for GitLab repositories  
  - BITBUCKET_USERNAME and BITBUCKET_APP_PASSWORD for Bitbucket
  
Examples:
  coderag-scan ./my-project
  coderag-scan https://github.com/owner/repo.git
  GITHUB_TOKEN=ghp_xxx coderag-scan https://github.com/private/repo.git`)
  .version('1.0.0');

program
  .argument('<project-path>', 'Path to the project directory to scan or Git URL')
  .option('-p, --project-id <id>', 'Project ID for multi-project separation')
  .option('-n, --project-name <name>', 'Project name (defaults to project ID or directory name)')
  .option('-l, --languages <languages>', 'Comma-separated list of languages to scan (auto-detected if not specified)')
  .option('-e, --exclude <paths>', 'Comma-separated list of paths to exclude', 'node_modules,dist,build')
  .option('--include-tests', 'Include test files in the scan', false)
  .option('--clear-graph', 'Clear existing graph data for this project before scanning', false)
  .option('--clear-all', 'Clear ALL graph data (all projects) before scanning', false)
  .option('--analyze', 'Run quality analysis after scanning', false)
  .option('--output-report', 'Generate and save a scan report', false)
  .option('--validate-only', 'Only validate the project structure without scanning', false)
  .option('--branch <branch>', 'Git branch to scan (for remote repositories)', 'main')
  .option('--no-cleanup', 'Keep temporary files after scanning (for debugging)', false)
  .option('--use-cache', 'Enable repository caching for faster subsequent scans', false)
  .option('--clear-cache', 'Clear git repository cache before scanning', false)
  .option('-v, --verbose', 'Show detailed progress information', false)
  .action(async (projectPath: string, options) => {
    try {
      console.log(`🚀 CodeRAG Scanner v1.0.0`);

      // Initialize Neo4j connection first for git URL validation
      const config = getConfig();
      const client = new Neo4jClient(config);
      await client.connect();
      console.log(`🔗 Connected to Neo4j: ${config.uri}`);
      
      // Initialize scanner with authentication configuration
      const scanner = new CodebaseScanner(client);
      
      // Configure git authentication from environment variables
      const gitAuthConfig = {
        github: {
          token: process.env.GITHUB_TOKEN
        },
        gitlab: {
          token: process.env.GITLAB_TOKEN,
          host: process.env.GITLAB_HOST
        },
        bitbucket: {
          username: process.env.BITBUCKET_USERNAME,
          appPassword: process.env.BITBUCKET_APP_PASSWORD
        }
      };
      
      scanner.updateGitAuthConfig(gitAuthConfig);
      
      // Handle cache clearing for remote repositories
      if (options.clearCache && options.useCache) {
        console.log(`🧹 Clearing git repository cache...`);
        await scanner.clearCache();
      }
      
      let resolvedPath: string;
      let isRemote = false;
      let gitUrl: string | undefined;

      // Check if input is a git URL
      if (scanner.isGitUrl(projectPath)) {
        console.log(`🌐 Remote repository detected: ${projectPath}`);
        
        // Validate remote repository
        console.log(`🔍 Validating remote repository...`);
        const isValid = await scanner.validateRemoteRepository(projectPath);
        if (!isValid) {
          console.error(`❌ Remote repository is not accessible: ${projectPath}`);
          await client.disconnect();
          process.exit(1);
        }
        
        isRemote = true;
        gitUrl = projectPath;
        resolvedPath = ''; // Will be set during cloning
        console.log(`✅ Remote repository is accessible`);
      } else {
        // Handle as local path
        resolvedPath = path.resolve(projectPath);
        
        if (!fs.existsSync(resolvedPath)) {
          console.error(`❌ Project path does not exist: ${resolvedPath}`);
          await client.disconnect();
          process.exit(1);
        }
        
        console.log(`📁 Local project: ${resolvedPath}`);
      }

      // Get project ID (for remote repos, extract from URL)
      let projectId = options.projectId;
      if (!projectId) {
        if (isRemote && gitUrl) {
          const parsedUrl = scanner.parseGitUrl(gitUrl);
          projectId = `${parsedUrl.owner}-${parsedUrl.repo}`;
        } else {
          projectId = path.basename(resolvedPath);
        }
      }

      // Get recommended scan configuration with auto-detection
      if (isRemote) {
        console.log(`🔍 Remote repository will be analyzed after cloning...`);
      } else {
        console.log(`🔍 Analyzing project structure and detecting languages...`);
      }
      
      let recommendation;
      if (!isRemote) {
        recommendation = await scanner.getRecommendedScanConfig(resolvedPath, projectId);
        
        console.log(`\n📋 Project Analysis:`);
        recommendation.suggestions.forEach(suggestion => console.log(`  ${suggestion}`));
        
        // Show detected project metadata
        if (recommendation.projectMetadata.length > 0) {
          console.log(`\n📦 Project Metadata:`);
          recommendation.projectMetadata.forEach(meta => {
            console.log(`  📄 ${meta.name || 'Unnamed'} (${meta.language})`);
            if (meta.version) console.log(`    Version: ${meta.version}`);
            if (meta.description) console.log(`    Description: ${meta.description}`);
            if (meta.framework) console.log(`    Framework: ${meta.framework}`);
            if (meta.buildSystem) console.log(`    Build System: ${meta.buildSystem}`);
          });
        }
        
        if (!recommendation.scanConfig.languages?.length) {
          console.error(`\n❌ No supported languages detected. Please check the project structure.`);
          await client.disconnect();
          process.exit(1);
        }
      }
      
      if (options.validateOnly) {
        if (isRemote) {
          console.log(`\n✅ Remote repository validation completed.`);
        } else {
          console.log(`\n✅ Project structure validation completed.`);
        }
        await client.disconnect();
        return;
      }
      
      // Use recommended configuration or defaults for remote repositories
      let languages: Language[];
      let excludePaths: string[];
      let projectName: string;
      
      if (isRemote) {
        // For remote repositories, use CLI options or sensible defaults
        languages = options.languages ? 
          options.languages.split(',').map((l: string) => l.trim()) as Language[] : 
          ['typescript', 'javascript', 'java', 'python']; // Default to all supported languages
          
        excludePaths = options.exclude ? 
          options.exclude.split(',').map((p: string) => p.trim()) :
          ['node_modules', 'dist', 'build', '.git'];
          
        projectName = options.projectName || projectId;
      } else {
        // For local repositories, use recommendation
        languages = options.languages ? 
          options.languages.split(',').map((l: string) => l.trim()) as Language[] : 
          recommendation!.scanConfig.languages || [];
          
        excludePaths = options.exclude ? 
          options.exclude.split(',').map((p: string) => p.trim()) :
          recommendation!.scanConfig.excludePaths || ['node_modules', 'dist', 'build'];
          
        projectName = options.projectName || 
          recommendation!.scanConfig.projectName || 
          projectId;
      }
      
      console.log(`📋 Project ID: ${projectId}`);
      console.log(`📋 Project Name: ${projectName}`);

      // Prepare scan configuration
      const scanConfig: ScanConfig = {
        projectPath: resolvedPath,
        projectId,
        projectName,
        languages,
        excludePaths,
        includeTests: options.includeTests,
        outputProgress: options.verbose,
        // Remote repository settings
        isRemote,
        gitUrl,
        gitBranch: options.branch,
        cleanupTemp: !options.noCleanup,
        useCache: options.useCache,
        cacheOptions: {
          forceRefresh: options.clearCache
        }
      };

      console.log(`\n⚙️ Scan Configuration:`);
      if (isRemote) {
        console.log(`  Git URL: ${gitUrl}`);
        console.log(`  Branch: ${options.branch}`);
      }
      console.log(`  Languages: ${languages.join(', ')}`);
      console.log(`  Include tests: ${options.includeTests ? 'yes' : 'no'}`);
      console.log(`  Exclude paths: ${excludePaths.join(', ')}`);

      // Clear graph if requested
      if (options.clearAll) {
        await scanner.clearGraph(); // Clear all data
      } else if (options.clearGraph) {
        await scanner.clearGraph(projectId); // Clear only this project
      }

      // Initialize database schema
      await client.initializeDatabase();

      // Perform the scan
      console.log(`\n🔄 Starting codebase scan...`);
      const result = await scanner.scanProject(scanConfig);

      // Generate and display report
      const report = await scanner.generateScanReport(result);
      console.log(report);

      // Save report if requested
      if (options.outputReport) {
        const reportPath = path.join(resolvedPath, 'coderag-scan-report.txt');
        await fs.promises.writeFile(reportPath, report);
        console.log(`📄 Report saved to: ${reportPath}`);
      }

      // Run quality analysis if requested
      if (options.analyze) {
        console.log(`\n🔬 Running quality analysis...`);
        const metricsManager = new MetricsManager(client);
        const summary = await metricsManager.calculateProjectSummary();
        const issues = await metricsManager.findArchitecturalIssues();

        console.log(`\n📊 QUALITY ANALYSIS RESULTS`);
        console.log(`═══════════════════════════`);
        console.log(`📈 Project Metrics:`);
        console.log(`  Total Classes: ${summary.totalClasses}`);
        console.log(`  Total Methods: ${summary.totalMethods}`);
        console.log(`  Total Packages: ${summary.totalPackages}`);
        console.log(`  Average Coupling: ${summary.averageMetrics.avgCBO.toFixed(2)}`);
        console.log(`  Average RFC: ${summary.averageMetrics.avgRFC.toFixed(2)}`);
        console.log(`  Average DIT: ${summary.averageMetrics.avgDIT.toFixed(2)}`);

        console.log(`\n⚠️ Issues Found: ${issues.length}`);
        if (issues.length > 0) {
          issues.slice(0, 5).forEach((issue, index) => {
            console.log(`  ${index + 1}. [${issue.severity.toUpperCase()}] ${issue.description}`);
          });
          if (issues.length > 5) {
            console.log(`  ... and ${issues.length - 5} more issues`);
          }
        }

      }


      await client.disconnect();
      console.log(`\n✅ Scan completed successfully!`);

    } catch (error) {
      console.error(`\n❌ Scan failed:`, error instanceof Error ? error.message : String(error));
      if (options.verbose) {
        console.error(error instanceof Error ? error.stack : error);
      }
      process.exit(1);
    }
  });

// Add a command to clear the graph
program
  .command('clear')
  .description('Clear all data from the CodeRAG graph database')
  .option('-f, --force', 'Force clear without confirmation', false)
  .action(async (options) => {
    try {
      if (!options.force) {
        console.log(`⚠️  This will permanently delete all data in your CodeRAG graph database.`);
        console.log(`Use --force flag to confirm this action.`);
        process.exit(1);
      }

      const config = getConfig();
      const client = new Neo4jClient(config);
      await client.connect();

      const scanner = new CodebaseScanner(client);
      await scanner.clearGraph();

      await client.disconnect();
      console.log(`✅ Graph database cleared successfully.`);

    } catch (error) {
      console.error(`❌ Failed to clear graph:`, error instanceof Error ? error.message : String(error));
      process.exit(1);
    }
  });

// Add a command to validate project structure
program
  .command('validate <project-path>')
  .description('Validate project structure and detect languages')
  .action(async (projectPath: string) => {
    try {
      const resolvedPath = path.resolve(projectPath);
      
      const config = getConfig();
      const client = new Neo4jClient(config);
      await client.connect();

      const scanner = new CodebaseScanner(client);
      const validation = await scanner.validateProjectStructure(resolvedPath);

      console.log(`📁 Project: ${resolvedPath}`);
      console.log(`✅ Valid: ${validation.isValid ? 'Yes' : 'No'}`);
      console.log(`🔤 Languages detected: ${validation.detectedLanguages.join(', ') || 'None'}`);
      console.log(`\n📋 Analysis:`);
      validation.suggestions.forEach(suggestion => console.log(`  ${suggestion}`));

      await client.disconnect();

    } catch (error) {
      console.error(`❌ Validation failed:`, error instanceof Error ? error.message : String(error));
      process.exit(1);
    }
  });

// Parse command line arguments
program.parse();

export default program;


================================================
FILE: src/graph/edge-manager.ts
================================================
import { Neo4jClient } from './neo4j-client.js';
import { CodeEdge, QueryResult } from '../types.js';

export class EdgeManager {
  constructor(private client: Neo4jClient) {}

  async addEdge(edge: CodeEdge): Promise<CodeEdge> {
    let query = `
      MATCH (source:CodeNode {id: $source, project_id: $project_id}), 
            (target:CodeNode {id: $target, project_id: $project_id})
      CREATE (source)-[r:${edge.type.toUpperCase()} {
        id: $id,
        project_id: $project_id,
        type: $type,
        attributes_json: $attributes_json
      }]->(target)
      RETURN r, source.id as sourceId, target.id as targetId
    `;

    const params = {
      id: edge.id,
      project_id: edge.project_id,
      type: edge.type,
      source: edge.source,
      target: edge.target,
      attributes_json: JSON.stringify(edge.attributes || {})
    };

    let result = await this.client.runQuery(query, this.ensurePlainObject(params));

    // If the exact target isn't found and this is an implements relationship,
    // try to find the interface by name within the same project
    if (result.records.length === 0 && edge.type === 'implements') {
      const targetName = edge.target.split('.').pop(); // Get just the interface name
      
      const findInterfaceQuery = `
        MATCH (source:CodeNode {id: $source, project_id: $project_id}), 
              (target:Interface {project_id: $project_id})
        WHERE target.name = $targetName
        CREATE (source)-[r:${edge.type.toUpperCase()} {
          id: $id,
          project_id: $project_id,
          type: $type,
          attributes_json: $attributes_json
        }]->(target)
        RETURN r, source.id as sourceId, target.id as targetId
      `;
      
      const findParams = {
        ...params,
        targetName
      };
      
      result = await this.client.runQuery(findInterfaceQuery, this.ensurePlainObject(findParams));
    }

    if (result.records.length === 0) {
      throw new Error('Failed to create edge - source or target node not found');
    }

    return this.recordToEdge(result.records[0]);
  }

  async updateEdge(edgeId: string, projectId: string, updates: Partial<CodeEdge>): Promise<CodeEdge> {
    const setParts: string[] = [];
    const parameters: Record<string, any> = { id: edgeId };

    Object.entries(updates).forEach(([key, value], index) => {
      if (key !== 'id' && key !== 'source' && key !== 'target' && value !== undefined) {
        const paramKey = `update_${index}`;
        setParts.push(`r.${key} = $${paramKey}`);
        parameters[paramKey] = value;
      }
    });

    if (setParts.length === 0) {
      throw new Error('No valid updates provided');
    }

    const query = `
      MATCH (source)-[r {id: $id, project_id: $project_id}]->(target)
      SET ${setParts.join(', ')}
      RETURN r, source.id as sourceId, target.id as targetId
    `;

    parameters.project_id = projectId;

    const result = await this.client.runQuery(query, parameters);

    if (result.records.length === 0) {
      throw new Error(`Edge with id ${edgeId} not found`);
    }

    return this.recordToEdge(result.records[0]);
  }

  async getEdge(edgeId: string, projectId: string): Promise<CodeEdge | null> {
    const query = `
      MATCH (source)-[r {id: $id, project_id: $project_id}]->(target)
      RETURN r, source.id as sourceId, target.id as targetId
    `;
    
    const result = await this.client.runQuery(query, { id: edgeId, project_id: projectId });

    if (result.records.length === 0) {
      return null;
    }

    return this.recordToEdge(result.records[0]);
  }

  async deleteEdge(edgeId: string, projectId: string): Promise<boolean> {
    const query = `
      MATCH ()-[r {id: $id, project_id: $project_id}]->()
      DELETE r
      RETURN count(r) as deleted
    `;

    const result = await this.client.runQuery(query, { id: edgeId, project_id: projectId });
    return result.records[0].get('deleted').toNumber() > 0;
  }

  async findEdgesByType(type: CodeEdge['type'], projectId: string): Promise<CodeEdge[]> {
    const query = `
      MATCH (source)-[r:${type.toUpperCase()} {project_id: $project_id}]->(target)
      RETURN r, source.id as sourceId, target.id as targetId
    `;
    
    const result = await this.client.runQuery(query, { project_id: projectId });
    return result.records.map(record => this.recordToEdge(record));
  }

  async findEdgesBySource(sourceId: string, projectId: string): Promise<CodeEdge[]> {
    const query = `
      MATCH (source {id: $sourceId, project_id: $project_id})-[r {project_id: $project_id}]->(target)
      RETURN r, source.id as sourceId, target.id as targetId
    `;
    
    const result = await this.client.runQuery(query, { sourceId, project_id: projectId });
    return result.records.map(record => this.recordToEdge(record));
  }

  async findEdgesByTarget(targetId: string, projectId: string): Promise<CodeEdge[]> {
    const query = `
      MATCH (source)-[r {project_id: $project_id}]->(target {id: $targetId, project_id: $project_id})
      RETURN r, source.id as sourceId, target.id as targetId
    `;
    
    const result = await this.client.runQuery(query, { targetId, project_id: projectId });
    return result.records.map(record => this.recordToEdge(record));
  }

  async findEdgesBetween(sourceId: string, targetId: string, projectId: string): Promise<CodeEdge[]> {
    const query = `
      MATCH (source {id: $sourceId, project_id: $project_id})-[r {project_id: $project_id}]->(target {id: $targetId, project_id: $project_id})
      RETURN r, source.id as sourceId, target.id as targetId
    `;
    
    const result = await this.client.runQuery(query, { sourceId, targetId, project_id: projectId });
    return result.records.map(record => this.recordToEdge(record));
  }

  async getAllEdges(projectId: string): Promise<CodeEdge[]> {
    const query = `
      MATCH (source)-[r {project_id: $project_id}]->(target)
      RETURN r, source.id as sourceId, target.id as targetId
      LIMIT 1000
    `;
    
    const result = await this.client.runQuery(query, { project_id: projectId });
    return result.records.map(record => this.recordToEdge(record));
  }

  // Complex queries for code analysis
  async findClassesThatCallMethod(methodName: string, projectId: string): Promise<string[]> {
    const query = `
      MATCH (class:CodeNode {type: 'class', project_id: $project_id})-[:CONTAINS {project_id: $project_id}]->(method1:CodeNode {project_id: $project_id})
      -[:CALLS {project_id: $project_id}]->(method2:CodeNode {name: $methodName, project_id: $project_id})
      RETURN DISTINCT class.name as className
      ORDER BY className
    `;
    
    const result = await this.client.runQuery(query, { methodName, project_id: projectId });
    return result.records.map(record => record.get('className'));
  }

  async findClassesThatImplementInterface(interfaceName: string, projectId: string): Promise<string[]> {
    const query = `
      MATCH (class:CodeNode {type: 'class', project_id: $project_id})-[:IMPLEMENTS {project_id: $project_id}]->
      (interface:CodeNode {type: 'interface', name: $interfaceName, project_id: $project_id})
      RETURN class.name as className
      ORDER BY className
    `;
    
    const result = await this.client.runQuery(query, { interfaceName, project_id: projectId });
    return result.records.map(record => record.get('className'));
  }

  async findInheritanceHierarchy(className: string, projectId: string): Promise<string[]> {
    const query = `
      MATCH path = (child:CodeNode {name: $className, project_id: $project_id})-[:EXTENDS* {project_id: $project_id}]->
      (ancestor:CodeNode {project_id: $project_id})
      RETURN [node IN nodes(path) | node.name] as hierarchy
    `;
    
    const result = await this.client.runQuery(query, { className, project_id: projectId });
    return result.records.length > 0 ? result.records[0].get('hierarchy') : [];
  }

  // Cross-project methods (use with caution)
  async findEdgesByTypeAcrossProjects(type: CodeEdge['type']): Promise<CodeEdge[]> {
    const query = `
      MATCH (source)-[r:${type.toUpperCase()}]->(target)
      RETURN r, source.id as sourceId, target.id as targetId
      ORDER BY r.project_id
    `;
    
    const result = await this.client.runQuery(query);
    return result.records.map(record => this.recordToEdge(record));
  }

  async getAllEdgesAcrossProjects(): Promise<CodeEdge[]> {
    const query = `
      MATCH (source)-[r]->(target)
      RETURN r, source.id as sourceId, target.id as targetId
      ORDER BY r.project_id, r.type
      LIMIT 1000
    `;
    
    const result = await this.client.runQuery(query);
    return result.records.map(record => this.recordToEdge(record));
  }

  async findCrossProjectDependencies(): Promise<CodeEdge[]> {
    const query = `
      MATCH (source:CodeNode)-[r]->(target:CodeNode)
      WHERE source.project_id <> target.project_id
      RETURN r, source.id as sourceId, target.id as targetId
      ORDER BY source.project_id, target.project_id
    `;
    
    const result = await this.client.runQuery(query);
    return result.records.map(record => this.recordToEdge(record));
  }

  private recordToEdge(record: any): CodeEdge {
    const relationship = record.get('r');
    const properties = relationship.properties;
    
    return {
      id: properties.id,
      project_id: properties.project_id,
      type: properties.type,
      source: record.get('sourceId'),
      target: record.get('targetId'),
      attributes: properties.attributes_json ? JSON.parse(properties.attributes_json) : {}
    };
  }

  private ensurePlainObject(value: any): any {
    if (value === null || value === undefined) {
      return value;
    }
    
    // Handle Maps first (before JSON serialization)
    if (value instanceof Map) {
      const obj: any = {};
      for (const [k, v] of value.entries()) {
        obj[k] = this.ensurePlainObject(v);
      }
      return obj;
    }
    
    if (Array.isArray(value)) {
      return value.map(item => this.ensurePlainObject(item));
    }
    
    if (value && typeof value === 'object' && value.constructor === Object) {
      const obj: any = {};
      for (const [k, v] of Object.entries(value)) {
        obj[k] = this.ensurePlainObject(v);
      }
      return obj;
    }
    
    // Try JSON serialization for other complex objects
    try {
      return JSON.parse(JSON.stringify(value));
    } catch (error) {
      return value;
    }
  }
}


================================================
FILE: src/graph/neo4j-client.ts
================================================
import neo4j, { Driver, Session, Result } from 'neo4j-driver';
import { Neo4jConfig, ProjectConfig, ProjectContext } from '../types.js';

export class Neo4jClient {
  private driver: Driver | null = null;
  private projectConfig: ProjectConfig;

  constructor(private config: Neo4jConfig, projectConfig?: ProjectConfig) {
    this.projectConfig = projectConfig || {
      isolation_strategy: 'shared_db',
      cross_project_analysis: true,
      max_projects_shared_db: 100
    };
  }

  async connect(): Promise<void> {
    try {
      this.driver = neo4j.driver(
        this.config.uri,
        neo4j.auth.basic(this.config.user, this.config.password)
      );
      
      // Verify connectivity
      await this.driver.verifyConnectivity();
      console.log('Connected to Neo4J database');
    } catch (error) {
      console.error('Failed to connect to Neo4J:', error);
      throw error;
    }
  }

  async disconnect(): Promise<void> {
    if (this.driver) {
      await this.driver.close();
      this.driver = null;
      console.log('Disconnected from Neo4J database');
    }
  }

  getSession(): Session {
    if (!this.driver) {
      throw new Error('Neo4J driver not connected. Call connect() first.');
    }
    return this.driver.session();
  }

  async runQuery(query: string, parameters: Record<string, any> = {}): Promise<Result> {
    const session = this.getSession();
    try {
      return await session.run(query, parameters);
    } finally {
      await session.close();
    }
  }

  async runTransaction<T>(
    work: (tx: any) => Promise<T>
  ): Promise<T> {
    const session = this.getSession();
    try {
      return await session.executeWrite(work);
    } finally {
      await session.close();
    }
  }

  async healthCheck(): Promise<boolean> {
    try {
      const result = await this.runQuery('RETURN 1 as health');
      return result.records.length > 0;
    } catch (error) {
      console.error('Health check failed:', error);
      return false;
    }
  }

  async initializeDatabase(): Promise<void> {
    const session = this.getSession();
    try {
      // Create project-aware constraints and indexes for better performance
      const constraints = [
        // Project-aware core constraints
        'CREATE CONSTRAINT IF NOT EXISTS FOR (n:CodeNode) REQUIRE (n.project_id, n.id) IS UNIQUE',
        'CREATE CONSTRAINT IF NOT EXISTS FOR (e:CodeEdge) REQUIRE (e.project_id, e.id) IS UNIQUE',
        
        // Project context constraints
        'CREATE CONSTRAINT IF NOT EXISTS FOR (p:ProjectContext) REQUIRE p.project_id IS UNIQUE',
        
        // Project-aware indexes for performance
        'CREATE INDEX IF NOT EXISTS FOR (n:CodeNode) ON (n.project_id)',
        'CREATE INDEX IF NOT EXISTS FOR (n:CodeNode) ON (n.project_id, n.type)',
        'CREATE INDEX IF NOT EXISTS FOR (n:CodeNode) ON (n.project_id, n.name)',
        'CREATE INDEX IF NOT EXISTS FOR (n:CodeNode) ON (n.project_id, n.qualified_name)',
        'CREATE INDEX IF NOT EXISTS FOR (e:CodeEdge) ON (e.project_id)',
        'CREATE INDEX IF NOT EXISTS FOR (e:CodeEdge) ON (e.project_id, e.type)',
        
        // Traditional indexes for backward compatibility and cross-project queries
        'CREATE INDEX IF NOT EXISTS FOR (n:CodeNode) ON (n.type)',
        'CREATE INDEX IF NOT EXISTS FOR (n:CodeNode) ON (n.name)',
        'CREATE INDEX IF NOT EXISTS FOR (n:CodeNode) ON (n.qualified_name)',
        'CREATE INDEX IF NOT EXISTS FOR (e:CodeEdge) ON (e.type)'
      ];

      for (const constraint of constraints) {
        await session.run(constraint);
      }
      
      console.log('Database initialized with project-aware constraints and indexes');
    } finally {
      await session.close();
    }
  }

  // Project management methods
  async createProject(project: ProjectContext): Promise<ProjectContext> {
    const query = `
      CREATE (p:ProjectContext {
        project_id: $project_id,
        name: $name,
        description: $description,
        created_at: datetime(),
        updated_at: datetime()
      })
      RETURN p
    `;

    const params = {
      project_id: project.project_id,
      name: project.name || project.project_id,
      description: project.description || null
    };

    const result = await this.runQuery(query, params);
    if (result.records.length === 0) {
      throw new Error('Failed to create project');
    }

    const record = result.records[0].get('p');
    return {
      project_id: record.properties.project_id,
      name: record.properties.name,
      description: record.properties.description,
      created_at: record.properties.created_at.toStandardDate(),
      updated_at: record.properties.updated_at.toStandardDate()
    };
  }

  async getProject(projectId: string): Promise<ProjectContext | null> {
    const query = `
      MATCH (p:ProjectContext {project_id: $project_id})
      RETURN p
    `;

    const result = await this.runQuery(query, { project_id: projectId });
    if (result.records.length === 0) {
      return null;
    }

    const record = result.records[0].get('p');
    return {
      project_id: record.properties.project_id,
      name: record.properties.name,
      description: record.properties.description,
      created_at: record.properties.created_at?.toStandardDate(),
      updated_at: record.properties.updated_at?.toStandardDate()
    };
  }

  async listProjects(): Promise<ProjectContext[]> {
    const query = `
      MATCH (p:ProjectContext)
      RETURN p
      ORDER BY p.created_at DESC
    `;

    const result = await this.runQuery(query);
    return result.records.map(record => {
      const p = record.get('p');
      return {
        project_id: p.properties.project_id,
        name: p.properties.name,
        description: p.properties.description,
        created_at: p.properties.created_at?.toStandardDate(),
        updated_at: p.properties.updated_at?.toStandardDate()
      };
    });
  }

  async deleteProject(projectId: string): Promise<boolean> {
    const query = `
      MATCH (p:ProjectContext {project_id: $project_id})
      OPTIONAL MATCH (n:CodeNode {project_id: $project_id})
      OPTIONAL MATCH (e:CodeEdge {project_id: $project_id})
      DELETE p, n, e
      RETURN count(p) as deleted_projects
    `;

    const result = await this.runQuery(query, { project_id: projectId });
    return result.records[0]?.get('deleted_projects') > 0;
  }

  // Utility methods
  getProjectLabel(projectId: string, nodeType: string): string {
    return `Project_${projectId}_${nodeType.charAt(0).toUpperCase() + nodeType.slice(1)}`;
  }

  generateProjectScopedId(projectId: string, entityId: string): string {
    return `${projectId}:${entityId}`;
  }

  parseProjectScopedId(scopedId: string): { projectId: string; entityId: string } {
    const [projectId, ...entityParts] = scopedId.split(':');
    return {
      projectId,
      entityId: entityParts.join(':')
    };
  }
}


================================================
FILE: src/graph/node-manager.ts
================================================
import { Neo4jClient } from './neo4j-client.js';
import { CodeNode, QueryResult } from '../types.js';

export class NodeManager {
  constructor(private client: Neo4jClient) {}

  async addNode(node: CodeNode): Promise<CodeNode> {
    // Get the proper node label based on type and project
    const nodeLabel = this.getNodeLabel(node.type);
    const projectLabel = this.client.getProjectLabel(node.project_id, node.type);
    
    const query = `
      CREATE (n:${nodeLabel}:${projectLabel}:CodeNode {
        id: $id,
        project_id: $project_id,
        type: $type,
        name: $name,
        qualified_name: $qualified_name,
        description: $description,
        source_file: $source_file,
        start_line: $start_line,
        end_line: $end_line,
        modifiers: $modifiers,
        attributes_json: $attributes_json
      })
      RETURN n
    `;

    const params = {
      id: node.id,
      project_id: node.project_id,
      type: node.type,
      name: node.name,
      qualified_name: node.qualified_name,
      description: node.description || null,
      source_file: node.source_file || null,
      start_line: node.start_line || null,
      end_line: node.end_line || null,
      modifiers: this.ensurePlainObject(node.modifiers || []),
      attributes_json: JSON.stringify(node.attributes || {})
    };

    const result = await this.client.runQuery(query, this.ensurePlainObject(params));

    if (result.records.length === 0) {
      throw new Error('Failed to create node');
    }

    return this.recordToNode(result.records[0].get('n'));
  }

  async updateNode(nodeId: string, projectId: string, updates: Partial<CodeNode>): Promise<CodeNode> {
    const setParts: string[] = [];
    const parameters: Record<string, any> = { id: nodeId };

    Object.entries(updates).forEach(([key, value], index) => {
      if (key !== 'id' && value !== undefined) {
        const paramKey = `update_${index}`;
        setParts.push(`n.${key} = $${paramKey}`);
        parameters[paramKey] = value;
      }
    });

    if (setParts.length === 0) {
      throw new Error('No valid updates provided');
    }

    const query = `
      MATCH (n:CodeNode {id: $id, project_id: $project_id})
      SET ${setParts.join(', ')}
      RETURN n
    `;

    parameters.project_id = projectId;

    const result = await this.client.runQuery(query, parameters);

    if (result.records.length === 0) {
      throw new Error(`Node with id ${nodeId} not found`);
    }

    return this.recordToNode(result.records[0].get('n'));
  }

  async getNode(nodeId: string, projectId: string): Promise<CodeNode | null> {
    const query = 'MATCH (n:CodeNode {id: $id, project_id: $project_id}) RETURN n';
    const result = await this.client.runQuery(query, { id: nodeId, project_id: projectId });

    if (result.records.length === 0) {
      return null;
    }

    return this.recordToNode(result.records[0].get('n'));
  }

  async deleteNode(nodeId: string, projectId: string): Promise<boolean> {
    const query = `
      MATCH (n:CodeNode {id: $id, project_id: $project_id})
      DETACH DELETE n
      RETURN count(n) as deleted
    `;

    const result = await this.client.runQuery(query, { id: nodeId, project_id: projectId });
    return result.records[0].get('deleted').toNumber() > 0;
  }

  async findNodesByType(type: CodeNode['type'], projectId: string): Promise<CodeNode[]> {
    const query = 'MATCH (n:CodeNode {type: $type, project_id: $project_id}) RETURN n ORDER BY n.name';
    const result = await this.client.runQuery(query, { type, project_id: projectId });

    return result.records.map(record => this.recordToNode(record.get('n')));
  }

  async findNodesByName(name: string, projectId: string): Promise<CodeNode[]> {
    const query = 'MATCH (n:CodeNode {project_id: $project_id}) WHERE n.name CONTAINS $name RETURN n ORDER BY n.name';
    const result = await this.client.runQuery(query, { name, project_id: projectId });

    return result.records.map(record => this.recordToNode(record.get('n')));
  }

  async findNodesByQualifiedName(qualifiedName: string, projectId: string): Promise<CodeNode[]> {
    const query = 'MATCH (n:CodeNode {qualified_name: $qualified_name, project_id: $project_id}) RETURN n';
    const result = await this.client.runQuery(query, { qualified_name: qualifiedName, project_id: projectId });

    return result.records.map(record => this.recordToNode(record.get('n')));
  }

  async searchNodes(searchTerm: string, projectId: string): Promise<CodeNode[]> {
    const query = `
      MATCH (n:CodeNode {project_id: $project_id})
      WHERE n.name CONTAINS $searchTerm 
         OR n.qualified_name CONTAINS $searchTerm 
         OR n.description CONTAINS $searchTerm
      RETURN n
      ORDER BY n.name
      LIMIT 100
    `;

    const result = await this.client.runQuery(query, { searchTerm, project_id: projectId });
    return result.records.map(record => this.recordToNode(record.get('n')));
  }

  async getAllNodes(projectId: string): Promise<CodeNode[]> {
    const query = 'MATCH (n:CodeNode {project_id: $project_id}) RETURN n ORDER BY n.type, n.name LIMIT 1000';
    const result = await this.client.runQuery(query, { project_id: projectId });

    return result.records.map(record => this.recordToNode(record.get('n')));
  }

  // Cross-project methods (use with caution)
  async findNodesByTypeAcrossProjects(type: CodeNode['type']): Promise<CodeNode[]> {
    const query = 'MATCH (n:CodeNode {type: $type}) RETURN n ORDER BY n.project_id, n.name';
    const result = await this.client.runQuery(query, { type });
    return result.records.map(record => this.recordToNode(record.get('n')));
  }

  async searchNodesAcrossProjects(searchTerm: string): Promise<CodeNode[]> {
    const query = `
      MATCH (n:CodeNode)
      WHERE n.name CONTAINS $searchTerm 
         OR n.qualified_name CONTAINS $searchTerm 
         OR n.description CONTAINS $searchTerm
      RETURN n
      ORDER BY n.project_id, n.name
      LIMIT 100
    `;

    const result = await this.client.runQuery(query, { searchTerm });
    return result.records.map(record => this.recordToNode(record.get('n')));
  }

  async getAllNodesAcrossProjects(): Promise<CodeNode[]> {
    const query = 'MATCH (n:CodeNode) RETURN n ORDER BY n.project_id, n.type, n.name LIMIT 1000';
    const result = await this.client.runQuery(query);
    return result.records.map(record => this.recordToNode(record.get('n')));
  }

  private recordToNode(record: any): CodeNode {
    const properties = record.properties;
    return {
      id: properties.id,
      project_id: properties.project_id,
      type: properties.type,
      name: properties.name,
      qualified_name: properties.qualified_name,
      description: properties.description,
      source_file: properties.source_file,
      start_line: typeof properties.start_line?.toNumber === 'function' ? properties.start_line.toNumber() : properties.start_line,
      end_line: typeof properties.end_line?.toNumber === 'function' ? properties.end_line.toNumber() : properties.end_line,
      modifiers: properties.modifiers || [],
      attributes: properties.attributes_json ? JSON.parse(properties.attributes_json) : {}
    };
  }

  private getNodeLabel(type: CodeNode['type']): string {
    // Capitalize the first letter and handle special cases
    switch (type) {
      case 'class': return 'Class';
      case 'interface': return 'Interface';
      case 'enum': return 'Enum';
      case 'method': return 'Method';
      case 'function': return 'Function';
      case 'field': return 'Field';
      case 'module': return 'Module';
      case 'package': return 'Package';
      default: return 'CodeNode';
    }
  }

  private ensurePlainObject(value: any): any {
    // Force JSON serialization to ensure completely plain objects
    try {
      if (value === null || value === undefined) {
        return value;
      }
      // JSON serialization will convert Maps, Sets, and other complex objects to plain objects
      return JSON.parse(JSON.stringify(value));
    } catch (error) {
      // Fallback to original logic if JSON serialization fails
      if (value instanceof Map) {
        const obj: any = {};
        for (const [k, v] of value.entries()) {
          obj[k] = this.ensurePlainObject(v);
        }
        return obj;
      }
      if (Array.isArray(value)) {
        return value.map(item => this.ensurePlainObject(item));
      }
      if (value && typeof value === 'object' && value.constructor === Object) {
        const obj: any = {};
        for (const [k, v] of Object.entries(value)) {
          obj[k] = this.ensurePlainObject(v);
        }
        return obj;
      }
      return value;
    }
  }
}


================================================
FILE: src/mcp/base-handler.ts
================================================
import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import {
  ListToolsRequestSchema,
  CallToolRequestSchema,
  ListPromptsRequestSchema,
  GetPromptRequestSchema,
  McpError,
  ErrorCode,
} from '@modelcontextprotocol/sdk/types.js';
import { Neo4jClient } from '../graph/neo4j-client.js';
import { NodeManager } from '../graph/node-manager.js';
import { EdgeManager } from '../graph/edge-manager.js';
import { MetricsManager } from '../analysis/metrics-manager.js';
import { CodebaseScanner } from '../scanner/codebase-scanner.js';
import { SemanticSearchManager } from '../services/semantic-search-manager.js';
import { EmbeddingService } from '../services/embedding-service.js';
import { ScanConfig, Language } from '../scanner/types.js';
import { CodeNode, CodeEdge } from '../types.js';

// Import annotation analysis tools
import { findNodesByAnnotation } from './tools/find-nodes-by-annotation.js';
import { getFrameworkUsage } from './tools/get-framework-usage.js';
import { getAnnotationUsage } from './tools/get-annotation-usage.js';
import { findDeprecatedCode, findUsageOfDeprecatedCode } from './tools/find-deprecated-code.js';
import { analyzeTestingAnnotations, findUntestableCode } from './tools/analyze-testing-annotations.js';
import { listProjects } from './tools/list-projects.js';

// Import extracted tool functions
import { 
  addNode, updateNode, getNode, deleteNode, findNodesByType, searchNodes,
  type AddNodeParams, type UpdateNodeParams, type GetNodeParams, 
  type DeleteNodeParams, type FindNodesByTypeParams, type SearchNodesParams 
} from './tools/node-management.js';
import { 
  addEdge, getEdge, deleteEdge, findEdgesBySource,
  type AddEdgeParams, type GetEdgeParams, type DeleteEdgeParams, type FindEdgesBySourceParams 
} from './tools/edge-management.js';
import { 
  findMethodCallers, findImplementations, findInheritanceHierarchy,
  type FindMethodCallersParams, type FindImplementationsParams, type FindInheritanceHierarchyParams 
} from './tools/relationship-analysis.js';
import { 
  calculateCKMetrics, calculatePackageMetrics, findArchitecturalIssues, getProjectSummary,
  type CalculateCKMetricsParams, type CalculatePackageMetricsParams, type GetProjectSummaryParams 
} from './tools/metrics-analysis.js';
import { 
  addFile, scanDir,
  type AddFileParams, type ScanDirParams 
} from './tools/scanner-tools.js';
import { 
  semanticSearch, updateEmbeddings, getSimilarCode, initializeSemanticSearch,
  type SemanticSearchToolParams, type UpdateEmbeddingsParams, type GetSimilarCodeParams 
} from './tools/semantic-search.js';
import { 
  createRemoteScannerTools, handleRemoteScannerTool
} from './tools/remote-scanner-tools.js';

export abstract class BaseHandler {
  protected server: Server;
  protected nodeManager: NodeManager;
  protected edgeManager: EdgeManager;
  protected metricsManager: MetricsManager;
  protected codebaseScanner: CodebaseScanner;
  protected semanticSearchManager: SemanticSearchManager;
  protected embeddingService: EmbeddingService;
  protected detailLevel: 'simple' | 'detailed' = 'detailed';

  constructor(
    protected client: Neo4jClient,
    serverName: string = 'coderag-mcp-server',
    serverVersion: string = '1.0.0',
    detailLevel: 'simple' | 'detailed' = 'detailed'
  ) {
    this.server = new Server(
      {
        name: serverName,
        version: serverVersion,
      },
      {
        capabilities: {
          tools: {},
          prompts: {},
        },
      }
    );

    this.detailLevel = detailLevel;
    this.nodeManager = new NodeManager(client);
    this.edgeManager = new EdgeManager(client);
    this.metricsManager = new MetricsManager(client);
    this.codebaseScanner = new CodebaseScanner(client);
    this.embeddingService = new EmbeddingService();
    this.semanticSearchManager = new SemanticSearchManager(client, this.embeddingService);
    this.setupToolHandlers();
    this.setupPromptHandlers();
  }

  protected setupToolHandlers(): void {
    // List available tools
    this.server.setRequestHandler(ListToolsRequestSchema, async () => ({
      tools: this.getToolSchemas()
    }));

    // Handle tool calls
    this.server.setRequestHandler(CallToolRequestSchema, async (request) => {
      try {
        switch (request.params.name) {
          case 'add_node':
            return await this.handleAddNode(request.params.arguments);
          case 'update_node':
            return await this.handleUpdateNode(request.params.arguments);
          case 'get_node':
            return await this.handleGetNode(request.params.arguments);
          case 'delete_node':
            return await this.handleDeleteNode(request.params.arguments);
          case 'find_nodes_by_type':
            return await this.handleFindNodesByType(request.params.arguments);
          case 'search_nodes':
            return await this.handleSearchNodes(request.params.arguments);
          case 'add_edge':
            return await this.handleAddEdge(request.params.arguments);
          case 'get_edge':
            return await this.handleGetEdge(request.params.arguments);
          case 'delete_edge':
            return await this.handleDeleteEdge(request.params.arguments);
          case 'find_edges_by_source':
            return await this.handleFindEdgesBySource(request.params.arguments);
          case 'find_classes_calling_method':
            return await this.handleFindClassesCallingMethod(request.params.arguments);
          case 'find_classes_implementing_interface':
            return await this.handleFindClassesImplementingInterface(request.params.arguments);
          case 'get_inheritance_hierarchy':
            return await this.handleGetInheritanceHierarchy(request.params.arguments);
          case 'calculate_ck_metrics':
            return await this.handleCalculateCKMetrics(request.params.arguments);
          case 'calculate_package_metrics':
            return await this.handleCalculatePackageMetrics(request.params.arguments);
          case 'find_architectural_issues':
            return await this.handleFindArchitecturalIssues(request.params.arguments);
          case 'get_project_summary':
            return await this.handleGetProjectSummary(request.params.arguments);
          case 'add_file':
            return await this.handleAddFile(request.params.arguments);
          case 'scan_dir':
            return await this.handleScanDir(request.params.arguments);
          case 'find_nodes_by_annotation':
            return await this.handleFindNodesByAnnotation(request.params.arguments);
          case 'get_framework_usage':
            return await this.handleGetFrameworkUsage(request.params.arguments);
          case 'get_annotation_usage':
            return await this.handleGetAnnotationUsage(request.params.arguments);
          case 'find_deprecated_code':
            return await this.handleFindDeprecatedCode(request.params.arguments);
          case 'find_usage_of_deprecated_code':
            return await this.handleFindUsageOfDeprecatedCode(request.params.arguments);
          case 'analyze_testing_annotations':
            return await this.handleAnalyzeTestingAnnotations(request.params.arguments);
          case 'find_untestable_code':
            return await this.handleFindUntestableCode(request.params.arguments);
          case 'list_projects':
            return await this.handleListProjects(request.params.arguments);
          case 'semantic_search':
            return await this.handleSemanticSearch(request.params.arguments);
          case 'update_embeddings':
            return await this.handleUpdateEmbeddings(request.params.arguments);
          case 'get_similar_code':
            return await this.handleGetSimilarCode(request.params.arguments);
          case 'initialize_semantic_search':
            return await this.handleInitializeSemanticSearch(request.params.arguments);
          case 'scan_remote_repo':
          case 'validate_remote_repo':
          case 'git_cache_stats':
          case 'clear_git_cache':
            return await handleRemoteScannerTool(request.params.name, request.params.arguments, this.client);
          default:
            throw new McpError(ErrorCode.MethodNotFound, `Unknown tool: ${request.params.name}`);
        }
      } catch (error) {
        if (error instanceof McpError) {
          throw error;
        }
        throw new McpError(ErrorCode.InternalError, `Tool execution failed: ${error instanceof Error ? error.message : String(error)}`);
      }
    });
  }

  protected setupPromptHandlers(): void {
    // List available prompts
    this.server.setRequestHandler(ListPromptsRequestSchema, async () => ({
      prompts: [
        {
          name: 'analyze_codebase',
          description: 'Get guidance on analyzing a codebase using CodeRAG tools',
          arguments: [
            {
              name: 'project_type',
              description: 'Type of project (java, typescript, python, etc.)',
              required: false
            }
          ]
        },
        {
          name: 'setup_code_graph',
          description: 'Step-by-step guide to set up a code graph for a new project',
          arguments: [
            {
              name: 'language',
              description: 'Programming language of the project',
              required: true
            }
          ]
        },
        {
          name: 'find_dependencies',
          description: 'Guide to find class dependencies and method calls',
          arguments: [
            {
              name: 'target_class',
              description: 'The class to analyze dependencies for',
              required: false
            }
          ]
        },
        {
          name: 'analyze_inheritance',
          description: 'Guide to analyze inheritance hierarchies and interface implementations',
          arguments: [
            {
              name: 'class_or_interface',
              description: 'Name of class or interface to analyze',
              required: false
            }
          ]
        }
      ]
    }));

    // Handle prompt requests
    this.server.setRequestHandler(GetPromptRequestSchema, async (request) => {
      const { name, arguments: args } = request.params;
      
      switch (name) {
        case 'analyze_codebase':
          return this.getAnalyzeCodebasePrompt(args);
        case 'setup_code_graph':
          return this.getSetupCodeGraphPrompt(args);
        case 'find_dependencies':
          return this.getFindDependenciesPrompt(args);
        case 'analyze_inheritance':
          return this.getAnalyzeInheritancePrompt(args);
        default:
          throw new McpError(ErrorCode.InvalidParams, `Unknown prompt: ${name}`);
      }
    });
  }

  protected getToolSchemas() {
    return [
      {
        name: 'add_node',
        description: 'Add a new code node (class, interface, method, etc.) to the graph',
        inputSchema: {
          type: 'object',
          properties: {
            project: { type: 'string', description: 'Project name or identifier to add the node to' },
            id: { type: 'string', description: 'Unique identifier for the node' },
            type: { 
              type: 'string', 
              enum: ['class', 'interface', 'enum', 'exception', 'function', 'method', 'field', 'package', 'module'],
              description: 'Type of code entity'
            },
            name: { type: 'string', description: 'Name of the entity' },
            qualified_name: { type: 'string', description: 'Fully qualified name' },
            description: { type: 'string', description: 'Description or documentation' },
            source_file: { type: 'string', description: 'Source file path' },
            start_line: { type: 'number', description: 'Starting line number' },
            end_line: { type: 'number', description: 'Ending line number' },
            modifiers: { type: 'array', items: { type: 'string' }, description: 'Access modifiers' },
            attributes: { type: 'object', description: 'Additional attributes' }
          },
          required: ['project', 'id', 'type', 'name', 'qualified_name']
        }
      },
      {
        name: 'update_node',
        description: 'Update an existing code node',
        inputSchema: {
          type: 'object',
          properties: {
            project: { type: 'string', description: 'Project name or identifier to scope the operation to' },
            id: { type: 'string', description: 'Node ID to update' },
            updates: { type: 'object', description: 'Fields to update' }
          },
          required: ['project', 'id', 'updates']
        }
      },
      {
        name: 'get_node',
        description: 'Get a code node by ID',
        inputSchema: {
          type: 'object',
          properties: {
            project: { type: 'string', description: 'Project name or identifier to scope the operation to' },
            id: { type: 'string', description: 'Node ID' }
          },
          required: ['project', 'id']
        }
      },
      {
        name: 'delete_node',
        description: 'Delete a code node by ID',
        inputSchema: {
          type: 'object',
          properties: {
            project: { type: 'string', description: 'Project name or identifier to scope the operation to' },
            id: { type: 'string', description: 'Node ID to delete' }
          },
          required: ['project', 'id']
        }
      },
      {
        name: 'find_nodes_by_type',
        description: 'Find nodes by their type',
        inputSchema: {
          type: 'object',
          properties: {
            project: { type: 'string', description: 'Project name or identifier to scope the operation to' },
            type: { 
              type: 'string',
              enum: ['class', 'interface', 'enum', 'exception', 'function', 'method', 'field', 'package', 'module']
            },
            limit: {
              type: 'number',
              description: 'Maximum number of results to return',
              minimum: 1,
              maximum: 1000
            },
            offset: {
              type: 'number',
              description: 'Number of results to skip (for pagination)',
              minimum: 0
            }
          },
          required: ['project', 'type']
        }
      },
      {
        name: 'search_nodes',
        description: 'Search nodes by name, qualified name, or description',
        inputSchema: {
          type: 'object',
          properties: {
            project: { type: 'string', description: 'Project name or identifier to scope the operation to' },
            search_term: { type: 'string', description: 'Search term' },
            limit: {
              type: 'number',
              description: 'Maximum number of results to return',
              minimum: 1,
              maximum: 1000
            },
            offset: {
              type: 'number',
              description: 'Number of results to skip (for pagination)',
              minimum: 0
            }
          },
          required: ['project', 'search_term']
        }
      },
      {
        name: 'add_edge',
        description: 'Add a relationship edge between two nodes',
        inputSchema: {
          type: 'object',
          properties: {
            project: { type: 'string', description: 'Project name or identifier to scope the operation to' },
            id: { type: 'string', description: 'Unique identifier for the edge' },
            type: {
              type: 'string',
              enum: ['calls', 'implements', 'extends', 'contains', 'references', 'throws', 'belongs_to'],
              description: 'Type of relationship'
            },
            source: { type: 'string', description: 'Source node ID' },
            target: { type: 'string', description: 'Target node ID' },
            attributes: { type: 'object', description: 'Additional edge attributes' }
          },
          required: ['project', 'id', 'type', 'source', 'target']
        }
      },
      {
        name: 'get_edge',
        description: 'Get an edge by ID',
        inputSchema: {
          type: 'object',
          properties: {
            project: { type: 'string', description: 'Project name or identifier to scope the operation to' },
            id: { type: 'string', description: 'Edge ID' }
          },
          required: ['project', 'id']
        }
      },
      {
        name: 'delete_edge',
        description: 'Delete an edge by ID',
        inputSchema: {
          type: 'object',
          properties: {
            project: { type: 'string', description: 'Project name or identifier to scope the operation to' },
            id: { type: 'string', description: 'Edge ID to delete' }
          },
          required: ['project', 'id']
        }
      },
      {
        name: 'find_edges_by_source',
        description: 'Find all edges originating from a source node',
        inputSchema: {
          type: 'object',
          properties: {
            project: { type: 'string', description: 'Project name or identifier to scope the operation to' },
            source_id: { type: 'string', description: 'Source node ID' },
            limit: {
              type: 'number',
              description: 'Maximum number of results to return',
              minimum: 1,
              maximum: 1000
            },
            offset: {
              type: 'number',
              description: 'Number of results to skip (for pagination)',
              minimum: 0
            }
          },
          required: ['project', 'source_id']
        }
      },
      {
        name: 'find_classes_calling_method',
        description: 'Find all classes that call a specific method',
        inputSchema: {
          type: 'object',
          properties: {
            project: { type: 'string', description: 'Project name or identifier to scope the operation to' },
            method_name: { type: 'string', description: 'Method name to search for' },
            limit: {
              type: 'number',
              description: 'Maximum number of results to return',
              minimum: 1,
              maximum: 1000
            },
            offset: {
              type: 'number',
              description: 'Number of results to skip (for pagination)',
              minimum: 0
            }
          },
          required: ['project', 'method_name']
        }
      },
      {
        name: 'find_classes_implementing_interface',
        description: 'Find all classes that implement a specific interface',
        inputSchema: {
          type: 'object',
          properties: {
            project: { type: 'string', description: 'Project name or identifier to scope the operation to' },
            interface_name: { type: 'string', description: 'Interface name' },
            limit: {
              type: 'number',
              description: 'Maximum number of results to return',
              minimum: 1,
              maximum: 1000
            },
            offset: {
              type: 'number',
              description: 'Number of results to skip (for pagination)',
              minimum: 0
            }
          },
          required: ['project', 'interface_name']
        }
      },
      {
        name: 'get_inheritance_hierarchy',
        description: 'Get the inheritance hierarchy for a class',
        inputSchema: {
          type: 'object',
          properties: {
            project: { type: 'string', description: 'Project name or identifier to scope the operation to' },
            class_name: { type: 'string', description: 'Class name' }
          },
          required: ['project', 'class_name']
        }
      },
      {
        name: 'calculate_ck_metrics',
        description: 'Calculate Chidamber & Kemerer metrics for a class (WMC, DIT, NOC, CBO, RFC, LCOM)',
        inputSchema: {
          type: 'object',
          properties: {
            project: { type: 'string', description: 'Project name or identifier to scope the operation to' },
            class_id: { type: 'string', description: 'Class ID to analyze' }
          },
          required: ['project', 'class_id']
        }
      },
      {
        name: 'calculate_package_metrics',
        description: 'Calculate package metrics (Afferent/Efferent Coupling, Instability, Abstractness, Distance)',
        inputSchema: {
          type: 'object',
          properties: {
            project: { type: 'string', description: 'Project name or identifier to scope the operation to' },
            package_name: { type: 'string', description: 'Package name to analyze' }
          },
          required: ['project', 'package_name']
        }
      },
      {
        name: 'find_architectural_issues',
        description: 'Find architectural issues (circular dependencies, god classes, high coupling)',
        inputSchema: {
          type: 'object',
          properties: {
            project: { type: 'string', description: 'Project name or identifier to scope the operation to' },
            limit: {
              type: 'number',
              description: 'Maximum number of results to return',
              minimum: 1,
              maximum: 1000
            },
            offset: {
              type: 'number',
              description: 'Number of results to skip (for pagination)',
              minimum: 0
            }
          },
          required: ['project']
        }
      },
      {
        name: 'get_project_summary',
        description: 'Get overall project metrics summary and quality assessment',
        inputSchema: {
          type: 'object',
          properties: {
            project: { type: 'string', description: 'Project name or identifier to analyze (optional - if not provided, analyzes all projects)', required: false }
          },
          required: []
        }
      },
      {
        name: 'add_file',
        description: 'Parse a single source file and add its entities to the graph',
        inputSchema: {
          type: 'object',
          properties: {
            project: { type: 'string', description: 'Project name or identifier to add the file to' },
            file_path: { type: 'string', description: 'Path to the source file to parse' },
            clear_existing: { 
              type: 'boolean', 
              description: 'Clear existing entities from this file before adding new ones',
              default: false
            }
          },
          required: ['project', 'file_path']
        }
      },
      {
        name: 'scan_dir',
        description: 'Scan a directory for source files and populate the graph',
        inputSchema: {
          type: 'object',
          properties: {
            project: { type: 'string', description: 'Project name or identifier to assign to scanned content' },
            directory_path: { type: 'string', description: 'Path to the directory to scan' },
            languages: { 
              type: 'array', 
              items: { 
                type: 'string',
                enum: ['typescript', 'javascript', 'java', 'python', 'csharp']
              },
              description: 'Programming languages to include (default: auto-detect)',
              default: []
            },
            exclude_paths: {
              type: 'array',
              items: { type: 'string' },
              description: 'Paths to exclude from scanning',
              default: []
            },
            include_tests: {
              type: 'boolean',
              description: 'Include test files in the scan',
              default: false
            },
            clear_existing: {
              type: 'boolean',
              description: 'Clear existing project data before scanning',
              default: false
            },
            max_depth: {
              type: 'number',
              description: 'Maximum directory depth to scan',
              default: 10
            }
          },
          required: ['project', 'directory_path']
        }
      },
      // Annotation analysis tools
      {
        name: 'find_nodes_by_annotation',
        description: 'Find code nodes (classes, methods, etc.) that have specific annotations/decorators',
        inputSchema: {
          type: 'object',
          properties: {
            project: { type: 'string', description: 'Project name or identifier to scope the operation to' },
            annotation_name: {
              type: 'string',
              description: 'The annotation/decorator name to search for (e.g., @Component, @Override, staticmethod)'
            },
            framework: {
              type: 'string',
              description: 'Optional: Filter by framework (e.g., Spring, Angular, Flask, Django)'
            },
            category: {
              type: 'string',
              description: 'Optional: Filter by annotation category (e.g., web, testing, injection, persistence)'
            },
            node_type: {
              type: 'string',
              enum: ['class', 'interface', 'enum', 'exception', 'function', 'method', 'field', 'package', 'module'],
              description: 'Optional: Filter by node type'
            },
            limit: {
              type: 'number',
              description: 'Maximum number of results to return',
              minimum: 1,
              maximum: 1000
            },
            offset: {
              type: 'number',
              description: 'Number of results to skip (for pagination)',
              minimum: 0
            }
          },
          required: ['project', 'annotation_name']
        }
      },
      {
        name: 'get_framework_usage',
        description: 'Get statistics on framework usage based on annotations/decorators across the codebase',
        inputSchema: {
          type: 'object',
          properties: {
            project: { type: 'string', description: 'Project name or identifier to scope the operation to' },
            include_parameters: {
              type: 'boolean',
              description: 'Whether to include annotation parameters in the results',
              default: false
            },
            min_usage_count: {
              type: 'number',
              description: 'Minimum usage count to include in results',
              default: 1,
              minimum: 1
            }
          },
          required: ['project']
        }
      },
      {
        name: 'get_annotation_usage',
        description: 'Get comprehensive statistics on annotation/decorator usage patterns across the codebase',
        inputSchema: {
          type: 'object',
          properties: {
            project: { type: 'string', description: 'Project name or identifier to scope the operation to' },
            category: {
              type: 'string',
              description: 'Optional: Filter by annotation category (e.g., web, testing, injection, persistence)'
            },
            framework: {
              type: 'string',
              description: 'Optional: Filter by framework (e.g., Spring, Angular, Flask, Django)'
            },
            include_deprecated: {
              type: 'boolean',
              description: 'Whether to include deprecated annotations in results',
              default: true
            },
            group_by: {
              type: 'string',
              enum: ['annotation', 'category', 'framework'],
              description: 'How to group the results',
              default: 'annotation'
            }
          },
          required: ['project']
        }
      },
      {
        name: 'find_deprecated_code',
        description: 'Find all code elements marked as deprecated and optionally their dependencies',
        inputSchema: {
          type: 'object',
          properties: {
            project: { type: 'string', description: 'Project name or identifier to scope the operation to' },
            include_dependencies: {
              type: 'boolean',
              description: 'Whether to include information about what depends on deprecated code',
              default: false
            },
            node_type: {
              type: 'string',
              enum: ['class', 'interface', 'enum', 'exception', 'function', 'method', 'field', 'package', 'module'],
              description: 'Optional: Filter by node type'
            },
            limit: {
              type: 'number',
              description: 'Maximum number of results to return',
              minimum: 1,
              maximum: 1000
            },
            offset: {
              type: 'number',
              description: 'Number of results to skip (for pagination)',
              minimum: 0
            }
          },
          required: ['project']
        }
      },
      {
        name: 'find_usage_of_deprecated_code',
        description: 'Find code that uses deprecated elements and assess migration impact',
        inputSchema: {
          type: 'object',
          properties: {
            project: { type: 'string', description: 'Project name or identifier to scope the operation to' },
            include_usage_details: {
              type: 'boolean',
              description: 'Whether to include detailed information about each usage',
              default: false
            },
            limit: {
              type: 'number',
              description: 'Maximum number of results to return',
              minimum: 1,
              maximum: 1000
            },
            offset: {
              type: 'number',
              description: 'Number of results to skip (for pagination)',
              minimum: 0
            }
          },
          required: ['project']
        }
      },
      {
        name: 'analyze_testing_annotations',
        description: 'Analyze testing patterns and coverage based on test annotations/decorators',
        inputSchema: {
          type: 'object',
          properties: {
            project: { type: 'string', description: 'Project name or identifier to scope the operation to' },
            framework: {
              type: 'string',
              description: 'Optional: Filter by testing framework (e.g., JUnit, Pytest, Jest)'
            },
            include_coverage_analysis: {
              type: 'boolean',
              description: 'Whether to include test coverage analysis',
              default: false
            }
          },
          required: ['project']
        }
      },
      {
        name: 'find_untestable_code',
        description: 'Find code patterns that may be difficult to test (private methods, static methods, etc.)',
        inputSchema: {
          type: 'object',
          properties: {
            project: { type: 'string', description: 'Project name or identifier to scope the operation to' },
            limit: {
              type: 'number',
              description: 'Maximum number of results to return',
              minimum: 1,
              maximum: 1000
            },
            offset: {
              type: 'number',
              description: 'Number of results to skip (for pagination)',
              minimum: 0
            }
          },
          required: ['project']
        }
      },
      {
        name: 'list_projects',
        description: 'List all projects in the CodeRAG graph database with optional statistics',
        inputSchema: {
          type: 'object',
          properties: {
            include_stats: {
              type: 'boolean',
              description: 'Include detailed statistics for each project (entity counts, types, etc.)',
              default: false
            },
            sort_by: {
              type: 'string',
              enum: ['name', 'created_at', 'updated_at', 'entity_count'],
              description: 'Sort projects by the specified field',
              default: 'name'
            },
            limit: {
              type: 'number',
              description: 'Maximum number of projects to return',
              default: 100,
              minimum: 1,
              maximum: 1000
            }
          },
          required: []
        }
      },
      {
        name: 'semantic_search',
        description: 'Search for code using natural language queries to find functionality by meaning rather than syntax',
        inputSchema: {
          type: 'object',
          properties: {
            query: { 
              type: 'string', 
              description: 'Natural language description of the functionality to search for (e.g., "functions that validate email addresses")' 
            },
            project_id: { 
              type: 'string', 
              description: 'Optional: Project identifier to scope the search to' 
            },
            node_types: {
              type: 'array',
              items: {
                type: 'string',
                enum: ['class', 'interface', 'enum', 'exception', 'function', 'method', 'field', 'package', 'module']
              },
              description: 'Optional: Filter results by node types'
            },
            limit: {
              type: 'number',
              description: 'Maximum number of results to return',
              default: 10,
              minimum: 1,
              maximum: 100
            },
            similarity_threshold: {
              type: 'number',
              description: 'Minimum similarity score (0.0 to 1.0)',
              default: 0.7,
              minimum: 0.0,
              maximum: 1.0
            },
            include_graph_context: {
              type: 'boolean',
              description: 'Include related code entities in results for better context',
              default: false
            },
            max_hops: {
              type: 'number',
              description: 'Maximum relationship hops for graph context (when include_graph_context is true)',
              default: 2,
              minimum: 1,
              maximum: 3
            }
          },
          required: ['query']
        }
      },
      {
        name: 'update_embeddings',
        description: 'Generate or update semantic embeddings for code entities to enable semantic search',
        inputSchema: {
          type: 'object',
          properties: {
            project_id: { 
              type: 'string', 
              description: 'Optional: Project identifier to scope the embedding update to' 
            },
            node_types: {
              type: 'array',
              items: {
                type: 'string',
                enum: ['class', 'interface', 'enum', 'exception', 'function', 'method', 'field', 'package', 'module']
              },
              description: 'Optional: Filter which node types to update embeddings for'
            }
          },
          required: []
        }
      },
      {
        name: 'get_similar_code',
        description: 'Find code entities that are semantically similar to a specific node',
        inputSchema: {
          type: 'object',
          properties: {
            node_id: { 
              type: 'string', 
              description: 'ID of the code entity to find similar items for' 
            },
            project_id: { 
              type: 'string', 
              description: 'Project identifier containing the node' 
            },
            limit: {
              type: 'number',
              description: 'Maximum number of similar items to return',
              default: 5,
              minimum: 1,
              maximum: 50
            }
          },
          required: ['node_id', 'project_id']
        }
      },
      {
        name: 'initialize_semantic_search',
        description: 'Initialize semantic search infrastructure including vector indexes',
        inputSchema: {
          type: 'object',
          properties: {},
          required: []
        }
      },
      ...createRemoteScannerTools(this.client)
    ];
  }

  // Prompt response methods
  protected async getAnalyzeCodebasePrompt(args: any) {
    const projectType = args?.project_type || 'any';
    const detail = this.detailLevel === 'detailed' ? this.getDetailedAnalysisPrompt(projectType) : this.getSimpleAnalysisPrompt(projectType);
    
    return {
      description: `Guide for analyzing a ${projectType} codebase using CodeRAG`,
      messages: [
        {
          role: 'user' as const,
          content: {
            type: 'text' as const,
            text: detail
          }
        }
      ]
    };
  }

  protected async getSetupCodeGraphPrompt(args: any) {
    const language = args?.language || 'any';
    const detail = this.detailLevel === 'detailed' ? this.getDetailedSetupPrompt(language) : this.getSimpleSetupPrompt(language);

    return {
      description: `Step-by-step guide to set up a code graph for a ${language} project`,
      messages: [
        {
          role: 'user' as const,
          content: {
            type: 'text' as const,
            text: detail
          }
        }
      ]
    };
  }

  protected async getFindDependenciesPrompt(args: any) {
    const targetClass = args?.target_class || 'your target class';
    const detail = this.detailLevel === 'detailed' ? this.getDetailedDependenciesPrompt(targetClass) : this.getSimpleDependenciesPrompt(targetClass);

    return {
      description: `Guide to find dependencies for ${targetClass}`,
      messages: [
        {
          role: 'user' as const,
          content: {
            type: 'text' as const,
            text: detail
          }
        }
      ]
    };
  }

  protected async getAnalyzeInheritancePrompt(args: any) {
    const target = args?.class_or_interface || 'your class or interface';
    const detail = this.detailLevel === 'detailed' ? this.getDetailedInheritancePrompt(target) : this.getSimpleInheritancePrompt(target);

    return {
      description: `Guide to analyze inheritance for ${target}`,
      messages: [
        {
          role: 'user' as const,
          content: {
            type: 'text' as const,
            text: detail
          }
        }
      ]
    };
  }

  // Tool handler methods
  protected async handleAddNode(args: any) {
    return await addNode(this.nodeManager, args as AddNodeParams);
  }

  protected async handleUpdateNode(args: any) {
    return await updateNode(this.nodeManager, args as UpdateNodeParams);
  }

  protected async handleGetNode(args: any) {
    return await getNode(this.nodeManager, args as GetNodeParams);
  }

  protected async handleDeleteNode(args: any) {
    return await deleteNode(this.nodeManager, args as DeleteNodeParams);
  }

  protected async handleFindNodesByType(args: any) {
    return await findNodesByType(this.nodeManager, args as FindNodesByTypeParams);
  }

  protected async handleSearchNodes(args: any) {
    return await searchNodes(this.nodeManager, args as SearchNodesParams);
  }

  protected async handleAddEdge(args: any) {
    return await addEdge(this.edgeManager, args as AddEdgeParams);
  }

  protected async handleGetEdge(args: any) {
    return await getEdge(this.edgeManager, args as GetEdgeParams);
  }

  protected async handleDeleteEdge(args: any) {
    return await deleteEdge(this.edgeManager, args as DeleteEdgeParams);
  }

  protected async handleFindEdgesBySource(args: any) {
    return await findEdgesBySource(this.edgeManager, args as FindEdgesBySourceParams);
  }

  protected async handleFindClassesCallingMethod(args: any) {
    return await findMethodCallers(this.edgeManager, args as FindMethodCallersParams);
  }

  protected async handleFindClassesImplementingInterface(args: any) {
    return await findImplementations(this.edgeManager, args as FindImplementationsParams);
  }

  protected async handleGetInheritanceHierarchy(args: any) {
    return await findInheritanceHierarchy(this.edgeManager, args as FindInheritanceHierarchyParams);
  }

  protected async handleCalculateCKMetrics(args: any) {
    return await calculateCKMetrics(this.metricsManager, args as CalculateCKMetricsParams, this.detailLevel);
  }

  protected async handleCalculatePackageMetrics(args: any) {
    return await calculatePackageMetrics(this.metricsManager, args as CalculatePackageMetricsParams, this.detailLevel);
  }

  protected async handleFindArchitecturalIssues(args: any) {
    return await findArchitecturalIssues(this.metricsManager);
  }

  protected async handleGetProjectSummary(args: any) {
    return await getProjectSummary(this.metricsManager, args as GetProjectSummaryParams, this.detailLevel);
  }

  protected async handleAddFile(args: any) {
    return await addFile(this.codebaseScanner, this.nodeManager, this.edgeManager, this.client, args as AddFileParams);
  }

  protected async handleScanDir(args: any) {
    return await scanDir(this.codebaseScanner, args as ScanDirParams);
  }


  // Prompt content generators
  protected getDetailedAnalysisPrompt(projectType: string): string {
    return `I want to analyze my ${projectType} codebase. Here's how to use CodeRAG effectively:

## 1. First, explore what's already in the graph:
Use \`search_nodes\` with broad terms to see existing code entities:
- Search for package names or module names
- Search for main class names
- Use \`find_nodes_by_type\` to see all classes, interfaces, etc.

## 2. Understand the codebase structure:
- Use \`get_project_summary\` for overall metrics
- Use \`calculate_ck_metrics\` on key classes
- Use \`find_architectural_issues\` to spot problems

## 3. Explore relationships:
- Use \`get_inheritance_hierarchy\` for inheritance chains
- Use \`find_classes_implementing_interface\` for interface usage
- Use \`find_classes_calling_method\` for method dependencies

## 4. Focus on quality:
- Review CK metrics for complex classes (WMC > 15, CBO > 10)
- Check package metrics for architectural balance
- Address architectural issues found

What aspect would you like to explore first?`;
  }

  protected getSimpleAnalysisPrompt(projectType: string): string {
    return `Quick ${projectType} analysis guide:
1. \`get_project_summary\` - Overview
2. \`search_nodes\` - Find entities  
3. \`get_inheritance_hierarchy\` - Class relationships
4. \`find_architectural_issues\` - Spot problems`;
  }

  protected getDetailedSetupPrompt(language: string): string {
    return `Setting up a code graph for ${language} project:

## Step 1: Scan your codebase
Use \`scan_dir\` with your project path:
- Point to your source directory
- Include test files if desired
- Exclude build/dist directories

## Step 2: Validate the scan
- Check \`get_project_summary\` for overview
- Use \`search_nodes\` to spot-check entities
- Verify relationships with \`find_nodes_by_type\`

## Step 3: Analyze structure  
- Run \`find_architectural_issues\`
- Check key classes with \`calculate_ck_metrics\`
- Review package design with \`calculate_package_metrics\`

## Step 4: Explore relationships
- Map inheritance with \`get_inheritance_hierarchy\`
- Find interface usage patterns
- Trace method calls and dependencies

Ready to start scanning?`;
  }

  protected getSimpleSetupPrompt(language: string): string {
    return `${language} setup steps:
1. \`scan_dir\` - Scan your project
2. \`get_project_summary\` - Check results
3. \`find_architectural_issues\` - Find problems
4. Explore with other tools as needed`;
  }

  protected getDetailedDependenciesPrompt(targetClass: string): string {
    return `Finding dependencies for ${targetClass}:

## 1. Find what ${targetClass} depends on:
Use \`find_edges_by_source\` with ${targetClass} ID to see:
- What methods it calls (\`calls\` edges)
- What interfaces it implements (\`implements\` edges)  
- What classes it extends (\`extends\` edges)
- What it references (\`references\` edges)

## 2. Find what depends on ${targetClass}:
- Use \`find_classes_calling_method\` for methods in ${targetClass}
- Look for \`implements\` edges if ${targetClass} is an interface
- Check inheritance with \`get_inheritance_hierarchy\`

## 3. Analyze coupling:
- Use \`calculate_ck_metrics\` for ${targetClass} CBO score
- High CBO (>10) indicates tight coupling
- Review each dependency's necessity

## 4. Visualization approach:
Create a dependency map by following the edge chains to understand the full dependency network.

Which direction would you like to explore first?`;
  }

  protected getSimpleDependenciesPrompt(targetClass: string): string {
    return `Find ${targetClass} dependencies:
1. \`find_edges_by_source\` - What it uses
2. \`find_classes_calling_method\` - What uses it
3. \`calculate_ck_metrics\` - Check coupling score
4. Follow the edge chains for full picture`;
  }

  protected getDetailedInheritancePrompt(target: string): string {
    return `Analyzing inheritance for ${target}:

## 1. Map the hierarchy:
Use \`get_inheritance_hierarchy\` for ${target} to see:
- All parent classes/interfaces
- All child classes (if any)
- Inheritance depth and breadth

## 2. Find implementations:
If ${target} is an interface:
- Use \`find_classes_implementing_interface\`
- Check for multiple implementations
- Look for strategy or factory patterns

## 3. Find children:
Search for edges with type "extends" targeting ${target}:
- Use \`find_edges_by_target\` with ${target} ID
- Filter for \`type: "extends"\`

## 4. Analyze Design Patterns
Look for common patterns:

**Strategy Pattern**: 
- Interface with multiple implementations
- Use \`find_classes_implementing_interface\`

**Template Method**:
- Abstract class with concrete subclasses
- Check inheritance hierarchy depth

**Polymorphism Usage**:
- Find which methods call interface methods
- Use \`find_classes_calling_method\` on interface methods

## 5. Architecture Analysis
Evaluate your inheritance design:
- **Deep hierarchies** (>3 levels): Consider composition
- **Wide hierarchies** (>7 implementations): Consider breaking interfaces
- **Diamond inheritance**: Check for interface conflicts

What aspect of inheritance would you like to explore first?`;
  }

  protected getSimpleInheritancePrompt(target: string): string {
    return `Analyze ${target} inheritance:
1. \`get_inheritance_hierarchy\` - See ancestry
2. \`find_classes_implementing_interface\` - See implementations  
3. \`search_nodes\` with interface name - Find related entities
4. \`find_classes_calling_method\` - See usage patterns`;
  }

  // Annotation analysis handler methods
  protected async handleFindNodesByAnnotation(args: any) {
    const result = await findNodesByAnnotation(this.client, args);
    return {
      content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
    };
  }

  protected async handleGetFrameworkUsage(args: any) {
    const result = await getFrameworkUsage(this.client, args);
    return {
      content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
    };
  }

  protected async handleGetAnnotationUsage(args: any) {
    const result = await getAnnotationUsage(this.client, args);
    return {
      content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
    };
  }

  protected async handleFindDeprecatedCode(args: any) {
    const result = await findDeprecatedCode(this.client, args);
    return {
      content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
    };
  }

  protected async handleFindUsageOfDeprecatedCode(args: any) {
    const result = await findUsageOfDeprecatedCode(this.client, args);
    return {
      content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
    };
  }

  protected async handleAnalyzeTestingAnnotations(args: any) {
    const result = await analyzeTestingAnnotations(this.client, args);
    return {
      content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
    };
  }

  protected async handleFindUntestableCode(args: any) {
    const result = await findUntestableCode(this.client, args);
    return {
      content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
    };
  }

  protected async handleListProjects(args: any) {
    const result = await listProjects(this.client, args);
    return {
      content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
    };
  }

  protected async handleSemanticSearch(args: any) {
    const params: SemanticSearchToolParams = args;
    const result = await semanticSearch(this.semanticSearchManager, params);
    return {
      content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
    };
  }

  protected async handleUpdateEmbeddings(args: any) {
    const params: UpdateEmbeddingsParams = args;
    const result = await updateEmbeddings(this.semanticSearchManager, params);
    return {
      content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
    };
  }

  protected async handleGetSimilarCode(args: any) {
    const params: GetSimilarCodeParams = args;
    const result = await getSimilarCode(this.semanticSearchManager, params);
    return {
      content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
    };
  }

  protected async handleInitializeSemanticSearch(args: any) {
    const result = await initializeSemanticSearch(this.semanticSearchManager);
    return {
      content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
    };
  }

  // Abstract methods for transport-specific functionality
  abstract start(): Promise<void>;
}


================================================
FILE: src/mcp/http-handler.ts
================================================
import express from 'express';
import { randomUUID } from 'crypto';
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { StreamableHTTPServerTransport } from '@modelcontextprotocol/sdk/server/streamableHttp.js';
import { SSEServerTransport } from '@modelcontextprotocol/sdk/server/sse.js';
import { isInitializeRequest } from '@modelcontextprotocol/sdk/types.js';
import { z } from 'zod';
import { Neo4jClient } from '../graph/neo4j-client.js';
import { NodeManager } from '../graph/node-manager.js';
import { EdgeManager } from '../graph/edge-manager.js';
import { MetricsManager } from '../analysis/metrics-manager.js';

export class HTTPHandler {
  private app: express.Application;
  private port: number;
  private streamableTransports: { [sessionId: string]: StreamableHTTPServerTransport } = {};
  private sseTransports: { [sessionId: string]: SSEServerTransport } = {};
  private client: Neo4jClient;
  private nodeManager: NodeManager;
  private edgeManager: EdgeManager;
  private metricsManager: MetricsManager;


  private setupMiddleware(): void {
    // Basic request logging
    this.app.use((req, res, next) => {
      // Only log non-SSE requests and errors
      if (req.url !== '/sse' && !req.url.startsWith('/sse?')) {
        console.log(`${req.method} ${req.url}`);
      }
      next();
    });

    this.app.use(express.json());
    this.app.use((req, res, next) => {
      res.header('Access-Control-Allow-Origin', '*');
      res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
      res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept, Authorization, mcp-session-id');
      
      if (req.method === 'OPTIONS') {
        res.sendStatus(200);
      } else {
        next();
      }
    });
  }

  private server: McpServer;

  constructor(
    client: Neo4jClient,
    port: number = 3000,
    private serverName: string = 'coderag-mcp-server',
    private serverVersion: string = '1.0.0'
  ) {
    this.client = client;
    this.port = port;
    this.app = express();
    this.nodeManager = new NodeManager(client);
    this.edgeManager = new EdgeManager(client);
    this.metricsManager = new MetricsManager(client);
    
    // Create server once with all tools and prompts
    this.server = this.createServer();
    
    this.setupMiddleware();
    this.setupRoutes();
  }

  private createServer(): McpServer {
    const server = new McpServer({
      name: this.serverName,
      version: this.serverVersion
    });

    // Tool: Find nodes by type
    server.tool(
      'find_nodes_by_type',
      {
        nodeType: z.enum(['Class', 'Interface', 'Enum', 'Exception', 'Method', 'Function', 'Field', 'Package', 'Module']),
        projectId: z.string()
      },
      async ({ nodeType, projectId }) => {
        const nodes = await this.nodeManager.findNodesByType(nodeType as any, projectId);
        return {
          content: [{
            type: 'text',
            text: JSON.stringify(nodes, null, 2)
          }]
        };
      }
    );

    // Tool: Search nodes
    server.tool(
      'search_nodes',
      {
        searchTerm: z.string(),
        projectId: z.string()
      },
      async ({ searchTerm, projectId }) => {
        const nodes = await this.nodeManager.searchNodes(searchTerm, projectId);
        return {
          content: [{
            type: 'text',
            text: JSON.stringify(nodes, null, 2)
          }]
        };
      }
    );

    // Tool: Get node details
    server.tool(
      'get_node',
      {
        nodeId: z.string(),
        projectId: z.string()
      },
      async ({ nodeId, projectId }) => {
        const node = await this.nodeManager.getNode(nodeId, projectId);
        return {
          content: [{
            type: 'text',
            text: JSON.stringify(node, null, 2)
          }]
        };
      }
    );

    // Tool: Find inheritance hierarchy
    server.tool(
      'find_inheritance_hierarchy',
      {
        className: z.string(),
        projectId: z.string()
      },
      async ({ className, projectId }) => {
        const hierarchy = await this.edgeManager.findInheritanceHierarchy(className, projectId);
        return {
          content: [{
            type: 'text',
            text: JSON.stringify(hierarchy, null, 2)
          }]
        };
      }
    );

    // Tool: Find implementations
    server.tool(
      'find_implementations',
      {
        interfaceName: z.string(),
        projectId: z.string()
      },
      async ({ interfaceName, projectId }) => {
        const implementations = await this.edgeManager.findClassesThatImplementInterface(interfaceName, projectId);
        return {
          content: [{
            type: 'text',
            text: JSON.stringify(implementations, null, 2)
          }]
        };
      }
    );

    // Tool: Find method callers
    server.tool(
      'find_method_callers',
      {
        methodName: z.string(),
        projectId: z.string()
      },
      async ({ methodName, projectId }) => {
        const callers = await this.edgeManager.findClassesThatCallMethod(methodName, projectId);
        return {
          content: [{
            type: 'text',
            text: JSON.stringify(callers, null, 2)
          }]
        };
      }
    );

    // Tool: Calculate CK metrics
    server.tool(
      'calculate_ck_metrics',
      {
        classId: z.string()
      },
      async ({ classId }) => {
        const metrics = await this.metricsManager.calculateCKMetrics(classId);
        return {
          content: [{
            type: 'text',
            text: JSON.stringify(metrics, null, 2)
          }]
        };
      }
    );

    // Tool: Calculate package metrics
    server.tool(
      'calculate_package_metrics',
      {
        packageName: z.string()
      },
      async ({ packageName }) => {
        const metrics = await this.metricsManager.calculatePackageMetrics(packageName);
        return {
          content: [{
            type: 'text',
            text: JSON.stringify(metrics, null, 2)
          }]
        };
      }
    );

    // Tool: Find architectural issues
    server.tool(
      'find_architectural_issues',
      {},
      async () => {
        const issues = await this.metricsManager.findArchitecturalIssues();
        return {
          content: [{
            type: 'text',
            text: JSON.stringify(issues, null, 2)
          }]
        };
      }
    );

    // Tool: List projects  
    server.tool(
      'list_projects',
      {
        includeStats: z.boolean().optional(),
        sortBy: z.enum(['name', 'created_at', 'updated_at', 'entity_count']).optional(),
        limit: z.number().optional()
      },
      async ({ includeStats = false, sortBy = 'name', limit = 100 }) => {
        const { listProjects } = await import('./tools/list-projects.js');
        const result = await listProjects(this.client, { 
          include_stats: includeStats, 
          sort_by: sortBy, 
          limit 
        });
        return {
          content: [{
            type: 'text',
            text: JSON.stringify(result, null, 2)
          }]
        };
      }
    );

    // Tool: Add node
    server.tool(
      'add_node',
      {
        project: z.string(),
        id: z.string(),
        type: z.enum(['class', 'interface', 'enum', 'exception', 'function', 'method', 'field', 'package', 'module']),
        name: z.string(),
        qualified_name: z.string(),
        description: z.string().optional(),
        source_file: z.string().optional(),
        start_line: z.number().optional(),
        end_line: z.number().optional(),
        modifiers: z.array(z.string()).optional(),
        attributes: z.object({}).optional()
      },
      async (args) => {
        const node = {
          id: args.id,
          project_id: args.project,
          type: args.type,
          name: args.name,
          qualified_name: args.qualified_name,
          description: args.description,
          source_file: args.source_file,
          start_line: args.start_line,
          end_line: args.end_line,
          modifiers: args.modifiers,
          attributes: args.attributes
        };
        const result = await this.nodeManager.addNode(node);
        return {
          content: [{
            type: 'text',
            text: `Node created successfully: ${JSON.stringify(result, null, 2)}`
          }]
        };
      }
    );

    // Tool: Update node
    server.tool(
      'update_node',
      {
        project: z.string(),
        id: z.string(),
        updates: z.object({})
      },
      async ({ project, id, updates }) => {
        const result = await this.nodeManager.updateNode(id, project, updates);
        return {
          content: [{
            type: 'text',
            text: `Node updated successfully: ${JSON.stringify(result, null, 2)}`
          }]
        };
      }
    );

    // Tool: Delete node
    server.tool(
      'delete_node',
      {
        project: z.string(),
        id: z.string()
      },
      async ({ project, id }) => {
        const result = await this.nodeManager.deleteNode(id, project);
        return {
          content: [{
            type: 'text',
            text: result ? 'Node deleted successfully' : 'Node not found'
          }]
        };
      }
    );

    // Tool: Add edge
    server.tool(
      'add_edge',
      {
        project: z.string(),
        id: z.string(),
        type: z.enum(['calls', 'implements', 'extends', 'contains', 'references', 'throws', 'belongs_to']),
        source: z.string(),
        target: z.string(),
        attributes: z.object({}).optional()
      },
      async (args) => {
        const edge = {
          id: args.id,
          project_id: args.project,
          type: args.type,
          source: args.source,
          target: args.target,
          attributes: args.attributes
        };
        const result = await this.edgeManager.addEdge(edge);
        return {
          content: [{
            type: 'text',
            text: `Edge created successfully: ${JSON.stringify(result, null, 2)}`
          }]
        };
      }
    );

    // Tool: Get edge
    server.tool(
      'get_edge',
      {
        project: z.string(),
        id: z.string()
      },
      async ({ project, id }) => {
        const result = await this.edgeManager.getEdge(id, project);
        return {
          content: [{
            type: 'text',
            text: result ? JSON.stringify(result, null, 2) : 'Edge not found'
          }]
        };
      }
    );

    // Tool: Delete edge
    server.tool(
      'delete_edge',
      {
        project: z.string(),
        id: z.string()
      },
      async ({ project, id }) => {
        const result = await this.edgeManager.deleteEdge(id, project);
        return {
          content: [{
            type: 'text',
            text: result ? 'Edge deleted successfully' : 'Edge not found'
          }]
        };
      }
    );

    // Tool: Find edges by source
    server.tool(
      'find_edges_by_source',
      {
        project: z.string(),
        sourceId: z.string()
      },
      async ({ project, sourceId }) => {
        const result = await this.edgeManager.findEdgesBySource(sourceId, project);
        return {
          content: [{
            type: 'text',
            text: JSON.stringify(result, null, 2)
          }]
        };
      }
    );

    // Tool: Project summary
    server.tool(
      'get_project_summary',
      {
        project: z.string().optional()
      },
      async ({ project }) => {
        const result = await this.metricsManager.calculateProjectSummary();
        return {
          content: [{
            type: 'text',
            text: JSON.stringify(result, null, 2)
          }]
        };
      }
    );

    // Tool: Add file (scanning)
    server.tool(
      'add_file',
      {
        project: z.string(),
        file_path: z.string(),
        clear_existing: z.boolean().optional()
      },
      async (args) => {
        // This would need the full file parsing implementation
        // For now, return a placeholder
        return {
          content: [{
            type: 'text',
            text: `File parsing not yet implemented in new SDK version: ${args.file_path}`
          }]
        };
      }
    );

    // Tool: Scan directory
    server.tool(
      'scan_dir',
      {
        project: z.string(),
        directory_path: z.string(),
        languages: z.array(z.enum(['typescript', 'javascript', 'java', 'python', 'csharp'])).optional(),
        exclude_paths: z.array(z.string()).optional(),
        include_tests: z.boolean().optional(),
        clear_existing: z.boolean().optional(),
        max_depth: z.number().optional()
      },
      async (args) => {
        // This would need the full directory scanning implementation
        // For now, return a placeholder
        return {
          content: [{
            type: 'text',
            text: `Directory scanning not yet implemented in new SDK version: ${args.directory_path}`
          }]
        };
      }
    );

    // Annotation analysis tools
    server.tool(
      'find_nodes_by_annotation',
      {
        project: z.string(),
        annotation_name: z.string(),
        framework: z.string().optional(),
        category: z.string().optional(),
        node_type: z.enum(['class', 'interface', 'enum', 'exception', 'function', 'method', 'field', 'package', 'module']).optional()
      },
      async (args) => {
        const { findNodesByAnnotation } = await import('./tools/find-nodes-by-annotation.js');
        const result = await findNodesByAnnotation(this.client, args);
        return {
          content: [{
            type: 'text',
            text: JSON.stringify(result, null, 2)
          }]
        };
      }
    );

    server.tool(
      'get_framework_usage',
      {
        project: z.string(),
        include_parameters: z.boolean().optional(),
        min_usage_count: z.number().optional()
      },
      async (args) => {
        const { getFrameworkUsage } = await import('./tools/get-framework-usage.js');
        const result = await getFrameworkUsage(this.client, args);
        return {
          content: [{
            type: 'text',
            text: JSON.stringify(result, null, 2)
          }]
        };
      }
    );

    server.tool(
      'get_annotation_usage',
      {
        project: z.string(),
        category: z.string().optional(),
        framework: z.string().optional(),
        include_deprecated: z.boolean().optional(),
        group_by: z.enum(['annotation', 'category', 'framework']).optional()
      },
      async (args) => {
        const { getAnnotationUsage } = await import('./tools/get-annotation-usage.js');
        const result = await getAnnotationUsage(this.client, args);
        return {
          content: [{
            type: 'text',
            text: JSON.stringify(result, null, 2)
          }]
        };
      }
    );

    server.tool(
      'find_deprecated_code',
      {
        project: z.string(),
        include_dependencies: z.boolean().optional(),
        node_type: z.enum(['class', 'interface', 'enum', 'exception', 'function', 'method', 'field', 'package', 'module']).optional()
      },
      async (args) => {
        const { findDeprecatedCode } = await import('./tools/find-deprecated-code.js');
        const result = await findDeprecatedCode(this.client, args);
        return {
          content: [{
            type: 'text',
            text: JSON.stringify(result, null, 2)
          }]
        };
      }
    );

    server.tool(
      'find_usage_of_deprecated_code',
      {
        project: z.string(),
        include_usage_details: z.boolean().optional()
      },
      async (args) => {
        const { findUsageOfDeprecatedCode } = await import('./tools/find-deprecated-code.js');
        const result = await findUsageOfDeprecatedCode(this.client, args);
        return {
          content: [{
            type: 'text',
            text: JSON.stringify(result, null, 2)
          }]
        };
      }
    );

    server.tool(
      'analyze_testing_annotations',
      {
        project: z.string(),
        framework: z.string().optional(),
        include_coverage_analysis: z.boolean().optional()
      },
      async (args) => {
        const { analyzeTestingAnnotations } = await import('./tools/analyze-testing-annotations.js');
        const result = await analyzeTestingAnnotations(this.client, args);
        return {
          content: [{
            type: 'text',
            text: JSON.stringify(result, null, 2)
          }]
        };
      }
    );

    server.tool(
      'find_untestable_code',
      {
        project: z.string()
      },
      async (args) => {
        const { findUntestableCode } = await import('./tools/analyze-testing-annotations.js');
        const result = await findUntestableCode(this.client, args);
        return {
          content: [{
            type: 'text',
            text: JSON.stringify(result, null, 2)
          }]
        };
      }
    );

    // Add prompts
    server.prompt(
      'analyze_codebase',
      'Get guidance on analyzing a codebase using CodeRAG tools',
      {
        project_type: z.string().optional().describe('Type of project (java, typescript, python, etc.)')
      },
      async ({ project_type }) => {
        const projectType = project_type || 'any';
        return {
          description: `Guide for analyzing a ${projectType} codebase using CodeRAG`,
          messages: [{
            role: 'user',
            content: {
              type: 'text',
              text: `I want to analyze my ${projectType} codebase. Here's how to use CodeRAG effectively:

## 1. First, explore what's already in the graph:
Use \`search_nodes\` with broad terms to see existing code entities:
- Search for package names or module names
- Search for main class names
- Use \`find_nodes_by_type\` to see all classes, interfaces, etc.

## 2. Understand the codebase structure:
- Use \`get_project_summary\` for overall metrics
- Use \`calculate_ck_metrics\` on key classes
- Use \`find_architectural_issues\` to spot problems

## 3. Explore relationships:
- Use \`find_inheritance_hierarchy\` for inheritance chains
- Use \`find_implementations\` for interface usage
- Use \`find_method_callers\` for method dependencies

## 4. Focus on quality:
- Review CK metrics for complex classes (WMC > 15, CBO > 10)
- Check package metrics for architectural balance
- Address architectural issues found

What aspect would you like to explore first?`
            }
          }]
        };
      }
    );

    server.prompt(
      'setup_code_graph',
      'Step-by-step guide to set up a code graph for a new project',
      {
        language: z.string().describe('Programming language of the project')
      },
      async ({ language }) => {
        return {
          description: `Step-by-step guide to set up a code graph for a ${language} project`,
          messages: [{
            role: 'user',
            content: {
              type: 'text',
              text: `Setting up a code graph for ${language} project:

## Step 1: Scan your codebase
Use \`scan_dir\` with your project path:
- Point to your source directory
- Include test files if desired
- Exclude build/dist directories

## Step 2: Validate the scan
- Check \`get_project_summary\` for overview
- Use \`search_nodes\` to spot-check entities
- Verify relationships with \`find_nodes_by_type\`

## Step 3: Analyze structure  
- Run \`find_architectural_issues\`
- Check key classes with \`calculate_ck_metrics\`
- Review package design with \`calculate_package_metrics\`

## Step 4: Explore relationships
- Map inheritance with \`find_inheritance_hierarchy\`
- Find interface usage patterns
- Trace method calls and dependencies

Ready to start scanning?`
            }
          }]
        };
      }
    );

    return server;
  }


  private setupRoutes(): void {
    // Health check endpoint
    this.app.get('/health', (req, res) => {
      res.json({ 
        status: 'healthy', 
        server: 'CodeRAG MCP Server',
        timestamp: new Date().toISOString()
      });
    });

    // ================================
    // SSE TRANSPORT ENDPOINTS (Legacy)
    // ================================
    
    // SSE Transport: GET /sse - Establish SSE connection
    this.app.get('/sse', async (req, res) => {
      try {
        // Create SSE transport for this session - let it handle headers and generate session ID
        const transport = new SSEServerTransport('/sse', res);
        
        // Create dedicated server instance for this session
        const dedicatedServer = this.createServer();
        await dedicatedServer.connect(transport);
        
        // Get the session ID that SSEServerTransport generated
        const sessionId = transport.sessionId;
        this.sseTransports[sessionId] = transport;
        
        // Send additional connection event with messageEndpoint (SSEServerTransport already sent endpoint event)
        const messageEndpoint = `/messages`;
        const connectionData = JSON.stringify({
          sessionId: sessionId,
          messageEndpoint: messageEndpoint
        });
        
        const connectionEvent = `event: connection\ndata: ${connectionData}\n\n`;
        const pingEvent = `: ping - ${new Date().toISOString()}\n\n`;
        
        res.write(connectionEvent);
        res.write(pingEvent);
        
        console.log(`🔴 SSE session established: ${sessionId}`);
        
        // Cleanup on connection close
        req.on('close', () => {
          delete this.sseTransports[sessionId];
          console.log(`🔴 SSE session closed: ${sessionId}`);
        });
        
        res.on('close', () => {
          delete this.sseTransports[sessionId];
        });
        
        // Keep alive ping every 15 seconds
        const keepAlive = setInterval(() => {
          if (res.destroyed) {
            clearInterval(keepAlive);
            return;
          }
          res.write(`: ping - ${new Date().toISOString()}\n\n`);
        }, 15000);
        
        req.on('close', () => clearInterval(keepAlive));
        res.on('close', () => clearInterval(keepAlive));
        
      } catch (error) {
        console.error('❌ SSE connection error:', error);
        if (!res.headersSent) {
          res.status(500).json({ error: 'Failed to establish SSE connection' });
        }
      }
    });

    // SSE Transport: POST /sse - Send messages to same endpoint with sessionId
    this.app.post('/sse', async (req, res) => {
      const sessionId = req.query.sessionId as string || req.headers['mcp-session-id'] as string;
      
      if (!sessionId) {
        return res.status(400).json({ error: 'Session ID required' });
      }
      
      let transport = this.sseTransports[sessionId];
      
      // If session doesn't exist, try to find any available SSE transport and map it to this session ID
      if (!transport && Object.keys(this.sseTransports).length > 0) {
        const availableTransports = Object.values(this.sseTransports);
        if (availableTransports.length > 0) {
          transport = availableTransports[0]; // Use the first available transport
          this.sseTransports[sessionId] = transport; // Map client's session ID to this transport
        }
      }
      
      if (!transport) {
        return res.status(404).json({ error: 'No SSE connection available' });
      }
      
      try {
        await transport.handlePostMessage(req, res, req.body);
      } catch (error) {
        console.error('❌ SSE POST message error:', error);
        if (!res.headersSent) {
          res.status(500).json({ error: 'Failed to handle message' });
        }
      }
    });

    // SSE Transport: POST /messages - Send messages to server (correct SSE endpoint)
    this.app.post('/messages', async (req, res) => {
      // Extract sessionId from the message body or headers (as per SSE spec)
      const sessionId = req.headers['x-session-id'] as string || 
                       req.headers['session-id'] as string || 
                       req.body?.sessionId;
      
      if (!sessionId) {
        return res.status(400).json({ error: 'Session ID required in headers or body' });
      }
      
      const transport = this.sseTransports[sessionId];
      if (!transport) {
        return res.status(404).json({ error: 'Session not found' });
      }
      
      try {
        await transport.handlePostMessage(req, res, req.body);
      } catch (error) {
        console.error('❌ SSE POST /messages message error:', error);
        if (!res.headersSent) {
          res.status(500).json({ error: 'Failed to handle message' });
        }
      }
    });

    // ================================
    // STREAMABLE HTTP TRANSPORT ENDPOINTS (New)
    // ================================

    // Streamable HTTP Transport endpoints - exactly following the official SDK example
    this.app.post('/mcp', async (req, res) => {
      try {
        // Check for sessionId in query params or headers
        const querySessionId = req.query.sessionId as string;
        const headerSessionId = req.headers['mcp-session-id'] as string;
        const sessionId = querySessionId || headerSessionId;
        

        let transport: StreamableHTTPServerTransport;
        
        if (headerSessionId && this.streamableTransports[headerSessionId]) {
          // Reuse existing transport
          transport = this.streamableTransports[headerSessionId];
        } else if (!sessionId && isInitializeRequest(req.body)) {
          // New initialization request
          transport = new StreamableHTTPServerTransport({
            sessionIdGenerator: () => randomUUID(),
            onsessioninitialized: (sessionId) => {
              console.log(`🔑 Session initialized with ID: ${sessionId}`);
              this.streamableTransports[sessionId] = transport;
              console.log('📋 Current streamable transports:', Object.keys(this.streamableTransports));
            }
          });
          
          transport.onclose = () => {
            const sid = transport.sessionId;
            if (sid && this.streamableTransports[sid]) {
              console.log(`Transport closed for session ${sid}, removing from transports map`);
              delete this.streamableTransports[sid];
            }
          };
          
          // Connect the transport to the MCP server BEFORE handling the request
          await this.server.connect(transport);
          await transport.handleRequest(req, res, req.body);
          return; // Already handled
        } else {
          // Invalid request - no session ID or not initialization request
          console.log('❌ Bad request - no session ID or not initialize request');
          console.log('  sessionId:', sessionId);
          console.log('  isInitialize:', isInitializeRequest(req.body));
          res.status(400).json({
            jsonrpc: '2.0',
            error: {
              code: -32000,
              message: 'Bad Request: No valid session ID provided',
            },
            id: null,
          });
          return;
        }
        
        // Handle the request with existing transport
        console.log('🔄 Handling request with existing transport');
        await transport.handleRequest(req, res, req.body);
      } catch (error) {
        console.error('Error handling MCP request:', error);
        if (!res.headersSent) {
          res.status(500).json({
            jsonrpc: '2.0',
            error: {
              code: -32603,
              message: 'Internal server error',
            },
            id: null,
          });
        }
      }
    });

    // Streamable HTTP Transport: GET /mcp - Establish SSE stream for existing session
    this.app.get('/mcp', async (req, res) => {
      const headerSessionId = req.headers['mcp-session-id'] as string;
      const querySessionId = req.query.sessionId as string;
      
      console.log('🟢 Streamable HTTP GET /mcp:');
      console.log('  headerSessionId:', headerSessionId);
      console.log('  querySessionId:', querySessionId);
      console.log('  availableStreamableTransports:', Object.keys(this.streamableTransports));
      
      const sessionId = headerSessionId || querySessionId;
      
      if (!sessionId || !this.streamableTransports[sessionId]) {
        console.log('❌ Streamable HTTP GET - missing or invalid session ID');
        res.status(400).send('Invalid or missing session ID');
        return;
      }
      
      console.log(`🌊 Establishing streamable HTTP SSE stream for session ${sessionId}`);
      const transport = this.streamableTransports[sessionId];
      await transport.handleRequest(req, res);
    });

    // Streamable HTTP Transport: DELETE /mcp - Session termination
    this.app.delete('/mcp', async (req, res) => {
      const sessionId = req.headers['mcp-session-id'] as string;
      if (!sessionId || !this.streamableTransports[sessionId]) {
        res.status(400).send('Invalid or missing session ID');
        return;
      }

      const transport = this.streamableTransports[sessionId];
      await transport.handleRequest(req, res);
    });

    // Legacy REST API endpoints for direct access to graph data
    this.app.get('/api/nodes', async (req, res) => {
      try {
        const { type, search, project } = req.query;
        
        if (!project) {
          return res.status(400).json({ error: 'Project parameter is required' });
        }
        
        let result;
        
        if (type) {
          result = await this.nodeManager.findNodesByType(type as any, project as string);
        } else if (search) {
          result = await this.nodeManager.searchNodes(search as string, project as string);
        } else {
          // Get all nodes for project (limit to prevent overwhelming response)
          const query = `MATCH (n {project_id: $project}) RETURN n LIMIT 100`;
          result = await this.client.runQuery(query, { project });
        }
        
        res.json(result);
      } catch (error) {
        res.status(500).json({ error: error instanceof Error ? error.message : String(error) });
      }
    });

    this.app.get('/api/nodes/:id', async (req, res) => {
      try {
        const { project } = req.query;
        
        if (!project) {
          return res.status(400).json({ error: 'Project parameter is required' });
        }
        
        const node = await this.nodeManager.getNode(req.params.id, project as string);
        if (node) {
          res.json(node);
        } else {
          res.status(404).json({ error: 'Node not found' });
        }
      } catch (error) {
        res.status(500).json({ error: error instanceof Error ? error.message : String(error) });
      }
    });

    // Catch-all route to see what URLs Claude Code is trying
    this.app.all('*', (req, res) => {
      console.log(`UNHANDLED REQUEST: ${req.method} ${req.url}`);
      console.log('Headers:', req.headers);
      console.log('Body:', req.body);
      res.status(404).json({ error: `Route not found: ${req.method} ${req.url}` });
    });
  }

  start(): Promise<void> {
    return new Promise((resolve) => {
      this.app.listen(this.port, () => {
        console.log(`CodeRAG MCP Server started on port ${this.port}`);
        console.log(`Health check: http://localhost:${this.port}/health`);
        console.log(`\n🔴 SSE Transport (Legacy):`);
        console.log(`  SSE endpoint: http://localhost:${this.port}/sse`);
        console.log(`  Message endpoint: http://localhost:${this.port}/messages`);
        console.log(`\n🟢 Streamable HTTP Transport (New):`);
        console.log(`  MCP endpoint: http://localhost:${this.port}/mcp`);
        console.log(`\n🔗 Legacy API endpoints: http://localhost:${this.port}/api/`);
        resolve();
      });
    });
  }
}


================================================
FILE: src/mcp/sse-handler.ts
================================================
import express from 'express';
import { randomUUID } from 'crypto';
import { SSEServerTransport } from '@modelcontextprotocol/sdk/server/sse.js';
import { BaseHandler } from './base-handler.js';
import { Neo4jClient } from '../graph/neo4j-client.js';

export class SSEHandler extends BaseHandler {
  private app: express.Application;
  private port: number;
  private sessions: Map<string, SSEServerTransport> = new Map();

  constructor(
    client: Neo4jClient,
    port: number = 3000,
    serverName: string = 'coderag-mcp-server',
    serverVersion: string = '1.0.0'
  ) {
    super(client, serverName, serverVersion, 'simple');
    this.port = port;
    this.app = express();
    this.setupMiddleware();
    this.setupRoutes();
  }

  private setupMiddleware(): void {
    this.app.use(express.json());
    this.app.use((req, res, next) => {
      res.header('Access-Control-Allow-Origin', '*');
      res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
      res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept, Authorization');
      
      if (req.method === 'OPTIONS') {
        res.sendStatus(200);
      } else {
        next();
      }
    });
  }

  private setupRoutes(): void {
    // Health check endpoint
    this.app.get('/health', (req, res) => {
      res.json({ 
        status: 'healthy', 
        server: 'CodeRAG MCP Server',
        timestamp: new Date().toISOString()
      });
    });

    // SSE endpoint for server-to-client communication
    this.app.get('/sse', async (req, res) => {
      try {
        const sessionId = req.query.sessionId as string || randomUUID();
        
        // Create new transport for this session
        const transport = new SSEServerTransport('/sse', res);
        
        // Store transport for POST endpoint access
        this.sessions.set(sessionId, transport);
        
        // Connect server to transport
        await this.server.connect(transport);
        
        // Clean up when connection closes
        req.on('close', () => {
          this.sessions.delete(sessionId);
          console.log(`Session ${sessionId} closed`);
        });
        
        res.on('close', () => {
          this.sessions.delete(sessionId);
          console.log(`Session ${sessionId} closed via response`);
        });
        
        console.log(`SSE session ${sessionId} established`);
        
      } catch (error) {
        console.error('SSE connection error:', error);
        res.status(500).json({ error: 'Failed to establish SSE connection' });
      }
    });

    // POST endpoint for client-to-server messages
    this.app.post('/message', async (req, res) => {
      try {
        const sessionId = req.query.sessionId as string || req.headers['x-session-id'] as string;
        
        if (!sessionId) {
          return res.status(400).json({ error: 'Session ID required' });
        }
        
        const transport = this.sessions.get(sessionId);
        if (!transport) {
          return res.status(404).json({ error: 'Session not found' });
        }
        
        // Use the transport's handlePostMessage method
        await transport.handlePostMessage(req, res);
        
      } catch (error) {
        console.error('POST message error:', error);
        res.status(500).json({ error: 'Failed to handle message' });
      }
    });

    // REST API endpoints for direct access to graph data
    this.app.get('/api/nodes', async (req, res) => {
      try {
        const { type, search, project } = req.query;
        
        if (!project) {
          return res.status(400).json({ error: 'Project parameter is required' });
        }
        
        let result;
        
        if (type) {
          result = await this.nodeManager.findNodesByType(type as any, project as string);
        } else if (search) {
          result = await this.nodeManager.searchNodes(search as string, project as string);
        } else {
          // Get all nodes for project (limit to prevent overwhelming response)
          const query = `MATCH (n {project_id: $project}) RETURN n LIMIT 100`;
          result = await this.client.runQuery(query, { project });
        }
        
        res.json(result);
      } catch (error) {
        res.status(500).json({ error: error instanceof Error ? error.message : String(error) });
      }
    });

    this.app.get('/api/nodes/:id', async (req, res) => {
      try {
        const { project } = req.query;
        
        if (!project) {
          return res.status(400).json({ error: 'Project parameter is required' });
        }
        
        const node = await this.nodeManager.getNode(req.params.id, project as string);
        if (node) {
          res.json(node);
        } else {
          res.status(404).json({ error: 'Node not found' });
        }
      } catch (error) {
        res.status(500).json({ error: error instanceof Error ? error.message : String(error) });
      }
    });

    this.app.get('/api/edges', async (req, res) => {
      try {
        const { source, type, project } = req.query;
        
        if (!project) {
          return res.status(400).json({ error: 'Project parameter is required' });
        }
        
        let result;
        
        if (source) {
          result = await this.edgeManager.findEdgesBySource(source as string, project as string);
        } else {
          // Get all edges for project (limit to prevent overwhelming response)  
          const query = `MATCH (a)-[r {project_id: $project}]->(b) RETURN r LIMIT 100`;
          result = await this.client.runQuery(query, { project });
        }
        
        res.json(result);
      } catch (error) {
        res.status(500).json({ error: error instanceof Error ? error.message : String(error) });
      }
    });

    this.app.get('/api/edges/:id', async (req, res) => {
      try {
        const { project } = req.query;
        
        if (!project) {
          return res.status(400).json({ error: 'Project parameter is required' });
        }
        
        const edge = await this.edgeManager.getEdge(req.params.id, project as string);
        if (edge) {
          res.json(edge);
        } else {
          res.status(404).json({ error: 'Edge not found' });
        }
      } catch (error) {
        res.status(500).json({ error: error instanceof Error ? error.message : String(error) });
      }
    });

    // Analysis endpoints
    this.app.get('/api/analysis/inheritance/:className', async (req, res) => {
      try {
        const { project } = req.query;
        
        if (!project) {
          return res.status(400).json({ error: 'Project parameter is required' });
        }
        
        const hierarchy = await this.edgeManager.findInheritanceHierarchy(req.params.className, project as string);
        res.json(hierarchy);
      } catch (error) {
        res.status(500).json({ error: error instanceof Error ? error.message : String(error) });
      }
    });

    this.app.get('/api/analysis/implementations/:interfaceName', async (req, res) => {
      try {
        const { project } = req.query;
        
        if (!project) {
          return res.status(400).json({ error: 'Project parameter is required' });
        }
        
        const implementations = await this.edgeManager.findClassesThatImplementInterface(req.params.interfaceName, project as string);
        res.json(implementations);
      } catch (error) {
        res.status(500).json({ error: error instanceof Error ? error.message : String(error) });
      }
    });

    this.app.get('/api/analysis/callers/:methodName', async (req, res) => {
      try {
        const { project } = req.query;
        
        if (!project) {
          return res.status(400).json({ error: 'Project parameter is required' });
        }
        
        const callers = await this.edgeManager.findClassesThatCallMethod(req.params.methodName, project as string);
        res.json(callers);
      } catch (error) {
        res.status(500).json({ error: error instanceof Error ? error.message : String(error) });
      }
    });

    // New metrics endpoints
    this.app.get('/api/metrics/ck/:classId', async (req, res) => {
      try {
        const metrics = await this.metricsManager.calculateCKMetrics(req.params.classId);
        res.json(metrics);
      } catch (error) {
        res.status(500).json({ error: error instanceof Error ? error.message : String(error) });
      }
    });

    this.app.get('/api/metrics/package/:packageName', async (req, res) => {
      try {
        const metrics = await this.metricsManager.calculatePackageMetrics(req.params.packageName);
        res.json(metrics);
      } catch (error) {
        res.status(500).json({ error: error instanceof Error ? error.message : String(error) });
      }
    });

    this.app.get('/api/metrics/issues', async (req, res) => {
      try {
        const issues = await this.metricsManager.findArchitecturalIssues();
        res.json(issues);
      } catch (error) {
        res.status(500).json({ error: error instanceof Error ? error.message : String(error) });
      }
    });

    this.app.get('/api/metrics/summary', async (req, res) => {
      try {
        const summary = await this.metricsManager.calculateProjectSummary();
        res.json(summary);
      } catch (error) {
        res.status(500).json({ error: error instanceof Error ? error.message : String(error) });
      }
    });

    // File parsing endpoints
    this.app.post('/api/parse/file', async (req, res) => {
      try {
        const { file_path, clear_existing } = req.body;
        const result = await this.handleAddFile({ file_path, clear_existing });
        res.json({ success: true, result: result.content[0].text });
      } catch (error) {
        res.status(500).json({ error: error instanceof Error ? error.message : String(error) });
      }
    });

    this.app.post('/api/parse/directory', async (req, res) => {
      try {
        const { directory_path, languages, exclude_paths, include_tests, clear_existing, max_depth } = req.body;
        const result = await this.handleScanDir({ 
          directory_path, 
          languages, 
          exclude_paths, 
          include_tests, 
          clear_existing, 
          max_depth 
        });
        res.json({ success: true, result: result.content[0].text });
      } catch (error) {
        res.status(500).json({ error: error instanceof Error ? error.message : String(error) });
      }
    });
  }

  start(): Promise<void> {
    return new Promise((resolve) => {
      this.app.listen(this.port, () => {
        console.log(`CodeRAG MCP Server started on port ${this.port}`);
        console.log(`Health check: http://localhost:${this.port}/health`);
        console.log(`SSE endpoint: http://localhost:${this.port}/sse`);
        console.log(`Message endpoint: http://localhost:${this.port}/message`);
        console.log(`API endpoints: http://localhost:${this.port}/api/`);
        resolve();
      });
    });
  }
}


================================================
FILE: src/mcp/stdio-handler.ts
================================================
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import { BaseHandler } from './base-handler.js';
import { Neo4jClient } from '../graph/neo4j-client.js';

export class StdioHandler extends BaseHandler {
  constructor(
    client: Neo4jClient,
    serverName: string = 'coderag-mcp-server',
    serverVersion: string = '1.0.0'
  ) {
    super(client, serverName, serverVersion, 'detailed');
  }

  async start(): Promise<void> {
    const transport = new StdioServerTransport();
    await this.server.connect(transport);
    console.error('CodeRAG MCP Server started via STDIO');
  }
}


================================================
FILE: src/mcp/tools/analyze-testing-annotations.ts
================================================
import { Neo4jClient } from '../../graph/neo4j-client.js';

export interface AnalyzeTestingAnnotationsParams {
  project: string;
  framework?: string;
  include_coverage_analysis?: boolean;
}

export async function analyzeTestingAnnotations(
  neo4jClient: Neo4jClient,
  params: AnalyzeTestingAnnotationsParams
) {
  const { project, framework, include_coverage_analysis = false } = params;
  
  let query = `
    MATCH (n)
    WHERE n.project_id = $project
    AND n.attributes IS NOT NULL 
    AND n.attributes.annotations IS NOT NULL
    AND any(annotation IN n.attributes.annotations 
         WHERE annotation.category = 'testing'
  `;
  
  const queryParams: any = { project };
  
  if (framework) {
    query += ` AND annotation.framework = $framework`;
    queryParams.framework = framework;
  }
  
  query += ')';
  
  query += `
    WITH n,
         [annotation IN n.attributes.annotations 
          WHERE annotation.category = 'testing'] as test_annotations
    
    RETURN n.qualified_name as test_entity,
           n.type as entity_type,
           n.source_file as source_file,
           test_annotations,
           size(test_annotations) as annotation_count
    ORDER BY annotation_count DESC, test_entity
  `;
  
  const result = await neo4jClient.runQuery(query, queryParams);
  
  const testEntities = result.records?.map(record => ({
    test_entity: record.get('test_entity'),
    entity_type: record.get('entity_type'),
    source_file: record.get('source_file'),
    test_annotations: record.get('test_annotations'),
    annotation_count: record.get('annotation_count')
  })) || [];
  
  // Get testing framework statistics
  const frameworkStatsQuery = `
    MATCH (n)
    WHERE n.attributes IS NOT NULL 
    AND n.attributes.annotations IS NOT NULL
    AND any(annotation IN n.attributes.annotations 
         WHERE annotation.category = 'testing')
    UNWIND n.attributes.annotations as annotation
    WHERE annotation.category = 'testing'
    WITH annotation.framework as framework,
         annotation.name as annotation_name,
         count(*) as usage_count
    WHERE framework IS NOT NULL
    RETURN framework,
           collect({name: annotation_name, count: usage_count}) as annotations,
           sum(usage_count) as total_usage
    ORDER BY total_usage DESC
  `;
  
  const frameworkResult = await neo4jClient.runQuery(frameworkStatsQuery);
  const frameworkStats = frameworkResult.records?.map(record => ({
    framework: record.get('framework'),
    annotations: record.get('annotations'),
    total_usage: record.get('total_usage')
  })) || [];
  
  let coverageAnalysis = null;
  
  if (include_coverage_analysis) {
    // Analyze test coverage by looking for non-test methods without corresponding test methods
    const coverageQuery = `
      MATCH (method)
      WHERE method.project_id = $project
      AND method.type = 'method'
      AND NOT any(annotation IN coalesce(method.attributes.annotations, []) 
                  WHERE annotation.category = 'testing')
      AND NOT method.qualified_name CONTAINS 'test'
      AND NOT method.qualified_name CONTAINS 'Test'
      
      OPTIONAL MATCH (testMethod)
      WHERE testMethod.project_id = $project
      AND testMethod.type = 'method'
      AND any(annotation IN coalesce(testMethod.attributes.annotations, []) 
              WHERE annotation.category = 'testing')
      AND (testMethod.qualified_name CONTAINS method.name 
           OR testMethod.name CONTAINS method.name)
      
      WITH method, count(testMethod) as test_count
      
      RETURN 
        count(method) as total_methods,
        sum(CASE WHEN test_count > 0 THEN 1 ELSE 0 END) as methods_with_tests,
        sum(CASE WHEN test_count = 0 THEN 1 ELSE 0 END) as methods_without_tests,
        round(100.0 * sum(CASE WHEN test_count > 0 THEN 1 ELSE 0 END) / count(method)) as coverage_percentage
    `;
    
    const coverageResult = await neo4jClient.runQuery(coverageQuery, queryParams);
    const coverageRecord = coverageResult.records?.[0];
    
    if (coverageRecord) {
      coverageAnalysis = {
        total_methods: coverageRecord.get('total_methods'),
        methods_with_tests: coverageRecord.get('methods_with_tests'),
        methods_without_tests: coverageRecord.get('methods_without_tests'),
        coverage_percentage: coverageRecord.get('coverage_percentage')
      };
    }
  }
  
  return {
    test_entities: testEntities,
    framework_statistics: frameworkStats,
    coverage_analysis: coverageAnalysis,
    summary: {
      total_test_entities: testEntities.length,
      frameworks_used: frameworkStats.length,
      total_testing_annotations: frameworkStats.reduce((sum, fs) => sum + fs.total_usage, 0)
    }
  };
}

export async function findUntestableCode(neo4jClient: Neo4jClient, params: { project: string }) {
  const { project } = params;
  
  const query = `
    MATCH (n)
    WHERE n.project_id = $project
    AND n.type IN ['method', 'function']
    AND NOT any(annotation IN coalesce(n.attributes.annotations, []) 
                WHERE annotation.category = 'testing')
    
    // Look for methods that are private or have testing-unfriendly patterns
    WITH n,
         CASE 
           WHEN any(modifier IN coalesce(n.modifiers, []) WHERE modifier = 'private') THEN 'private'
           WHEN any(modifier IN coalesce(n.modifiers, []) WHERE modifier = 'static') THEN 'static'
           WHEN n.qualified_name CONTAINS '__' THEN 'private_python'
           WHEN size(coalesce(n.attributes.parameters, [])) > 10 THEN 'too_many_parameters'
           ELSE 'public'
         END as testability_concern
    
    WHERE testability_concern <> 'public'
    
    RETURN testability_concern,
           collect({
             qualified_name: n.qualified_name,
             type: n.type,
             source_file: n.source_file,
             parameter_count: size(coalesce(n.attributes.parameters, []))
           }) as methods,
           count(n) as count
    ORDER BY count DESC
  `;
  
  const result = await neo4jClient.runQuery(query, { project });
  
  return {
    testability_issues: result.records?.map(record => ({
      concern: record.get('testability_concern'),
      methods: record.get('methods'),
      count: record.get('count')
    })) || [],
    total_concerning_methods: result.records?.reduce((sum, record) => sum + record.get('count'), 0) || 0
  };
}

export const analyzeTestingAnnotationsTool = {
  name: 'analyze_testing_annotations',
  description: 'Analyze testing patterns and coverage based on test annotations/decorators',
  inputSchema: {
    type: 'object',
    properties: {
      framework: {
        type: 'string',
        description: 'Optional: Filter by testing framework (e.g., JUnit, Pytest, Jest)'
      },
      include_coverage_analysis: {
        type: 'boolean',
        description: 'Whether to include test coverage analysis',
        default: false
      }
    },
    required: []
  }
};

export const findUntestableCodeTool = {
  name: 'find_untestable_code',
  description: 'Find code patterns that may be difficult to test (private methods, static methods, etc.)',
  inputSchema: {
    type: 'object',
    properties: {},
    required: []
  }
};


================================================
FILE: src/mcp/tools/edge-management.ts
================================================
import { EdgeManager } from '../../graph/edge-manager.js';
import { CodeEdge } from '../../types.js';

// Edge Management Tool Parameters
export interface AddEdgeParams {
  id: string;
  project: string;
  type: CodeEdge['type'];
  source: string;
  target: string;
  attributes?: Record<string, any>;
}

export interface GetEdgeParams {
  id: string;
  project: string;
}

export interface DeleteEdgeParams {
  id: string;
  project: string;
}

export interface FindEdgesBySourceParams {
  project: string;
  sourceId: string;
}

// Edge Management Functions
export async function addEdge(
  edgeManager: EdgeManager,
  params: AddEdgeParams
) {
  const edge: CodeEdge = {
    id: params.id,
    project_id: params.project,
    type: params.type,
    source: params.source,
    target: params.target,
    attributes: params.attributes
  };

  const result = await edgeManager.addEdge(edge);
  return {
    content: [{ type: 'text', text: `Edge created successfully: ${JSON.stringify(result, null, 2)}` }]
  };
}

export async function getEdge(
  edgeManager: EdgeManager,
  params: GetEdgeParams
) {
  const result = await edgeManager.getEdge(params.id, params.project);
  return {
    content: [{ type: 'text', text: result ? JSON.stringify(result, null, 2) : 'Edge not found' }]
  };
}

export async function deleteEdge(
  edgeManager: EdgeManager,
  params: DeleteEdgeParams
) {
  const result = await edgeManager.deleteEdge(params.id, params.project);
  return {
    content: [{ type: 'text', text: result ? 'Edge deleted successfully' : 'Edge not found' }]
  };
}

export async function findEdgesBySource(
  edgeManager: EdgeManager,
  params: FindEdgesBySourceParams
) {
  const result = await edgeManager.findEdgesBySource(params.sourceId, params.project);
  return {
    content: [{ 
      type: 'text', 
      text: result.length > 0 ? JSON.stringify(result, null, 2) : 'No edges found' 
    }]
  };
}


================================================
FILE: src/mcp/tools/find-deprecated-code.ts
================================================
import { Neo4jClient } from '../../graph/neo4j-client.js';

export interface FindDeprecatedCodeParams {
  include_dependencies?: boolean;
  node_type?: 'class' | 'interface' | 'enum' | 'exception' | 'function' | 'method' | 'field' | 'package' | 'module';
}

export async function findDeprecatedCode(
  neo4jClient: Neo4jClient,
  params: FindDeprecatedCodeParams = {}
) {
  const { include_dependencies = false, node_type } = params;
  
  let query = `
    MATCH (n)
    WHERE n.attributes IS NOT NULL 
    AND n.attributes.annotations IS NOT NULL
    AND any(annotation IN n.attributes.annotations 
         WHERE annotation.name IN ['@Deprecated', 'deprecated', '@deprecated'])
  `;
  
  const queryParams: any = {};
  
  if (node_type) {
    query += ` AND n.type = $node_type`;
    queryParams.node_type = node_type;
  }
  
  if (include_dependencies) {
    query += `
      OPTIONAL MATCH (n)<-[r:calls|references|extends|implements]-(dependentNode)
      WITH n, 
           [annotation IN n.attributes.annotations 
            WHERE annotation.name IN ['@Deprecated', 'deprecated', '@deprecated']][0] as deprecation_annotation,
           collect(DISTINCT {
             node: dependentNode.qualified_name,
             relationship: type(r),
             type: dependentNode.type
           }) as dependencies
      RETURN n,
             deprecation_annotation,
             dependencies,
             size(dependencies) as dependency_count
      ORDER BY dependency_count DESC, n.qualified_name
    `;
  } else {
    query += `
      WITH n,
           [annotation IN n.attributes.annotations 
            WHERE annotation.name IN ['@Deprecated', 'deprecated', '@deprecated']][0] as deprecation_annotation
      RETURN n,
             deprecation_annotation
      ORDER BY n.qualified_name
    `;
  }
  
  const result = await neo4jClient.runQuery(query, queryParams);
  
  return {
    deprecated_nodes: result.records?.map(record => {
      const node = record.get('n').properties;
      const deprecationAnnotation = record.get('deprecation_annotation');
      const response: any = {
        ...node,
        deprecation_info: deprecationAnnotation
      };
      
      if (include_dependencies) {
        response.dependencies = record.get('dependencies') || [];
        response.dependency_count = record.get('dependency_count') || 0;
      }
      
      return response;
    }) || [],
    total_count: result.records?.length || 0
  };
}

export async function findUsageOfDeprecatedCode(
  neo4jClient: Neo4jClient,
  params: { include_usage_details?: boolean } = {}
) {
  const { include_usage_details = false } = params;
  
  const query = `
    MATCH (deprecated)
    WHERE deprecated.attributes IS NOT NULL 
    AND deprecated.attributes.annotations IS NOT NULL
    AND any(annotation IN deprecated.attributes.annotations 
         WHERE annotation.name IN ['@Deprecated', 'deprecated', '@deprecated'])
    
    MATCH (deprecated)<-[r:calls|references|extends|implements]-(using)
    
    ${include_usage_details ? `
      WITH deprecated, using, r,
           [annotation IN deprecated.attributes.annotations 
            WHERE annotation.name IN ['@Deprecated', 'deprecated', '@deprecated']][0] as deprecation_info
      RETURN deprecated.qualified_name as deprecated_node,
             deprecated.type as deprecated_type,
             deprecation_info,
             collect({
               using_node: using.qualified_name,
               using_type: using.type,
               relationship: type(r),
               source_file: using.source_file
             }) as usage_details,
             count(using) as usage_count
      ORDER BY usage_count DESC
    ` : `
      RETURN deprecated.qualified_name as deprecated_node,
             deprecated.type as deprecated_type,
             count(using) as usage_count
      ORDER BY usage_count DESC
    `}
  `;
  
  const result = await neo4jClient.runQuery(query);
  
  return {
    deprecated_usage: result.records?.map(record => {
      const response: any = {
        deprecated_node: record.get('deprecated_node'),
        deprecated_type: record.get('deprecated_type'),
        usage_count: record.get('usage_count')
      };
      
      if (include_usage_details) {
        response.deprecation_info = record.get('deprecation_info');
        response.usage_details = record.get('usage_details');
      }
      
      return response;
    }) || [],
    total_deprecated_items: result.records?.length || 0
  };
}

export const findDeprecatedCodeTool = {
  name: 'find_deprecated_code',
  description: 'Find all code elements marked as deprecated and optionally their dependencies',
  inputSchema: {
    type: 'object',
    properties: {
      include_dependencies: {
        type: 'boolean',
        description: 'Whether to include information about what depends on deprecated code',
        default: false
      },
      node_type: {
        type: 'string',
        enum: ['class', 'interface', 'enum', 'exception', 'function', 'method', 'field', 'package', 'module'],
        description: 'Optional: Filter by node type'
      }
    },
    required: []
  }
};

export const findUsageOfDeprecatedCodeTool = {
  name: 'find_usage_of_deprecated_code',
  description: 'Find code that uses deprecated elements and assess migration impact',
  inputSchema: {
    type: 'object',
    properties: {
      include_usage_details: {
        type: 'boolean',
        description: 'Whether to include detailed information about each usage',
        default: false
      }
    },
    required: []
  }
};


================================================
FILE: src/mcp/tools/find-nodes-by-annotation.ts
================================================
import { Neo4jClient } from '../../graph/neo4j-client.js';

export interface FindNodesByAnnotationParams {
  annotation_name: string;
  framework?: string;
  category?: string;
  node_type?: 'class' | 'interface' | 'enum' | 'exception' | 'function' | 'method' | 'field' | 'package' | 'module';
}

export async function findNodesByAnnotation(
  neo4jClient: Neo4jClient,
  params: FindNodesByAnnotationParams
) {
  const { annotation_name, framework, category, node_type } = params;
  
  let query = `
    MATCH (n)
    WHERE n.attributes IS NOT NULL 
    AND n.attributes.annotations IS NOT NULL
    AND any(annotation IN n.attributes.annotations 
         WHERE annotation.name = $annotation_name
  `;
  
  const queryParams: any = { annotation_name };
  
  if (framework) {
    query += ` AND annotation.framework = $framework`;
    queryParams.framework = framework;
  }
  
  if (category) {
    query += ` AND annotation.category = $category`;
    queryParams.category = category;
  }
  
  query += ')';
  
  if (node_type) {
    query += ` AND n.type = $node_type`;
    queryParams.node_type = node_type;
  }
  
  query += `
    RETURN n, 
           [annotation IN n.attributes.annotations 
            WHERE annotation.name = $annotation_name][0] as matched_annotation
    ORDER BY n.qualified_name
  `;
  
  const result = await neo4jClient.runQuery(query, queryParams);
  
  return {
    nodes: result.records?.map(record => ({
      ...record.get('n').properties,
      matched_annotation: record.get('matched_annotation')
    })) || [],
    total_count: result.records?.length || 0
  };
}

export const findNodesByAnnotationTool = {
  name: 'find_nodes_by_annotation',
  description: 'Find code nodes (classes, methods, etc.) that have specific annotations/decorators',
  inputSchema: {
    type: 'object',
    properties: {
      annotation_name: {
        type: 'string',
        description: 'The annotation/decorator name to search for (e.g., @Component, @Override, staticmethod)'
      },
      framework: {
        type: 'string',
        description: 'Optional: Filter by framework (e.g., Spring, Angular, Flask, Django)'
      },
      category: {
        type: 'string',
        description: 'Optional: Filter by annotation category (e.g., web, testing, injection, persistence)'
      },
      node_type: {
        type: 'string',
        enum: ['class', 'interface', 'enum', 'exception', 'function', 'method', 'field', 'package', 'module'],
        description: 'Optional: Filter by node type'
      }
    },
    required: ['annotation_name']
  }
};


================================================
FILE: src/mcp/tools/get-annotation-usage.ts
================================================
import { Neo4jClient } from '../../graph/neo4j-client.js';

export interface GetAnnotationUsageParams {
  category?: string;
  framework?: string;
  include_deprecated?: boolean;
  group_by?: 'annotation' | 'category' | 'framework';
}

export async function getAnnotationUsage(
  neo4jClient: Neo4jClient,
  params: GetAnnotationUsageParams = {}
) {
  const { category, framework, include_deprecated = true, group_by = 'annotation' } = params;
  
  let query = `
    MATCH (n)
    WHERE n.attributes IS NOT NULL 
    AND n.attributes.annotations IS NOT NULL
    UNWIND n.attributes.annotations as annotation
    WHERE annotation.name IS NOT NULL
  `;
  
  const queryParams: any = {};
  
  if (category) {
    query += ` AND annotation.category = $category`;
    queryParams.category = category;
  }
  
  if (framework) {
    query += ` AND annotation.framework = $framework`;
    queryParams.framework = framework;
  }
  
  if (!include_deprecated) {
    query += ` AND annotation.name <> '@Deprecated' AND annotation.name <> 'deprecated'`;
  }
  
  switch (group_by) {
    case 'category':
      query += `
        WITH annotation.category as grouping_key,
             annotation.name as annotation_name,
             annotation.framework as framework,
             count(*) as usage_count,
             collect(DISTINCT n.type) as node_types,
             collect(DISTINCT n.qualified_name) as sample_nodes
        RETURN grouping_key as category,
               collect({
                 name: annotation_name,
                 framework: framework,
                 usage_count: usage_count,
                 node_types: node_types,
                 sample_nodes: sample_nodes[0..3]
               }) as annotations,
               sum(usage_count) as total_usage
        ORDER BY total_usage DESC
      `;
      break;
      
    case 'framework':
      query += `
        WITH annotation.framework as grouping_key,
             annotation.name as annotation_name,
             annotation.category as category,
             count(*) as usage_count,
             collect(DISTINCT n.type) as node_types,
             collect(DISTINCT n.qualified_name) as sample_nodes
        WHERE grouping_key IS NOT NULL
        RETURN grouping_key as framework,
               collect({
                 name: annotation_name,
                 category: category,
                 usage_count: usage_count,
                 node_types: node_types,
                 sample_nodes: sample_nodes[0..3]
               }) as annotations,
               sum(usage_count) as total_usage
        ORDER BY total_usage DESC
      `;
      break;
      
    default: // 'annotation'
      query += `
        WITH annotation.name as grouping_key,
             annotation.framework as framework,
             annotation.category as category,
             annotation.type as annotation_type,
             count(*) as usage_count,
             collect(DISTINCT n.type) as node_types,
             collect(DISTINCT n.qualified_name) as sample_nodes
        RETURN grouping_key as annotation_name,
               framework,
               category,
               annotation_type,
               usage_count,
               node_types,
               sample_nodes[0..5] as sample_nodes
        ORDER BY usage_count DESC
      `;
  }
  
  const result = await neo4jClient.runQuery(query, queryParams);
  
  if (group_by === 'annotation') {
    return {
      annotations: result.records?.map(record => ({
        annotation_name: record.get('annotation_name'),
        framework: record.get('framework'),
        category: record.get('category'),
        annotation_type: record.get('annotation_type'),
        usage_count: record.get('usage_count'),
        node_types: record.get('node_types'),
        sample_nodes: record.get('sample_nodes')
      })) || [],
      total_annotations: result.records?.length || 0
    };
  } else {
    const groupKey = group_by === 'category' ? 'category' : 'framework';
    return {
      groups: result.records?.map(record => ({
        [groupKey]: record.get(groupKey),
        annotations: record.get('annotations'),
        total_usage: record.get('total_usage')
      })) || [],
      total_groups: result.records?.length || 0
    };
  }
}

export const getAnnotationUsageTool = {
  name: 'get_annotation_usage',
  description: 'Get comprehensive statistics on annotation/decorator usage patterns across the codebase',
  inputSchema: {
    type: 'object',
    properties: {
      category: {
        type: 'string',
        description: 'Optional: Filter by annotation category (e.g., web, testing, injection, persistence)'
      },
      framework: {
        type: 'string',
        description: 'Optional: Filter by framework (e.g., Spring, Angular, Flask, Django)'
      },
      include_deprecated: {
        type: 'boolean',
        description: 'Whether to include deprecated annotations in results',
        default: true
      },
      group_by: {
        type: 'string',
        enum: ['annotation', 'category', 'framework'],
        description: 'How to group the results',
        default: 'annotation'
      }
    },
    required: []
  }
};


================================================
FILE: src/mcp/tools/get-framework-usage.ts
================================================
import { Neo4jClient } from '../../graph/neo4j-client.js';

export interface GetFrameworkUsageParams {
  include_parameters?: boolean;
  min_usage_count?: number;
}

export async function getFrameworkUsage(
  neo4jClient: Neo4jClient,
  params: GetFrameworkUsageParams = {}
) {
  const { include_parameters = false, min_usage_count = 1 } = params;
  
  const query = `
    MATCH (n)
    WHERE n.attributes IS NOT NULL 
    AND n.attributes.annotations IS NOT NULL
    UNWIND n.attributes.annotations as annotation
    WHERE annotation.framework IS NOT NULL
    WITH annotation.framework as framework,
         annotation.name as annotation_name,
         annotation.category as category${include_parameters ? ',\n         annotation.parameters as parameters' : ''},
         count(*) as usage_count,
         collect(DISTINCT n.qualified_name) as nodes_using
    WHERE usage_count >= $min_usage_count
    RETURN framework,
           collect({
             name: annotation_name,
             category: category,
             usage_count: usage_count${include_parameters ? ',\n             parameters: parameters' : ''},
             sample_nodes: nodes_using[0..5]
           }) as annotations,
           sum(usage_count) as total_framework_usage
    ORDER BY total_framework_usage DESC
  `;
  
  const result = await neo4jClient.runQuery(query, { min_usage_count });
  
  return {
    frameworks: result.records?.map(record => ({
      framework: record.get('framework'),
      total_usage: record.get('total_framework_usage'),
      annotations: record.get('annotations')
    })) || [],
    total_frameworks: result.records?.length || 0
  };
}

export const getFrameworkUsageTool = {
  name: 'get_framework_usage',
  description: 'Get statistics on framework usage based on annotations/decorators across the codebase',
  inputSchema: {
    type: 'object',
    properties: {
      include_parameters: {
        type: 'boolean',
        description: 'Whether to include annotation parameters in the results',
        default: false
      },
      min_usage_count: {
        type: 'number',
        description: 'Minimum usage count to include in results',
        default: 1,
        minimum: 1
      }
    },
    required: []
  }
};


================================================
FILE: src/mcp/tools/list-projects.ts
================================================
import { Neo4jClient } from '../../graph/neo4j-client.js';

export interface ListProjectsParams {
  include_stats?: boolean;
  sort_by?: 'name' | 'created_at' | 'updated_at' | 'entity_count';
  limit?: number;
}

export async function listProjects(
  neo4jClient: Neo4jClient,
  params: ListProjectsParams = {}
) {
  const { include_stats = false, sort_by = 'name', limit = 100 } = params;
  
  try {
    // Get basic project information
    const projects = await neo4jClient.listProjects();
    
    if (!include_stats) {
      // Simple list without statistics
      const sortedProjects = sortProjects(projects, sort_by);
      return {
        projects: sortedProjects.slice(0, limit),
        total_count: projects.length
      };
    }

    // Enhanced list with statistics
    const projectsWithStats = await Promise.all(
      projects.map(async (project) => {
        const stats = await getProjectStats(neo4jClient, project.project_id);
        return {
          ...project,
          stats
        };
      })
    );

    const sortedProjects = sortProjectsWithStats(projectsWithStats, sort_by);
    
    return {
      projects: sortedProjects.slice(0, limit),
      total_count: projects.length,
      summary: {
        total_projects: projects.length,
        total_entities: projectsWithStats.reduce((sum, p) => sum + p.stats.entity_count, 0),
        total_relationships: projectsWithStats.reduce((sum, p) => sum + p.stats.relationship_count, 0)
      }
    };
  } catch (error) {
    throw new Error(`Failed to list projects: ${error instanceof Error ? error.message : String(error)}`);
  }
}

async function getProjectStats(neo4jClient: Neo4jClient, projectId: string) {
  const statsQuery = `
    MATCH (n:CodeNode {project_id: $project_id})
    OPTIONAL MATCH (n)-[r {project_id: $project_id}]-()
    RETURN 
      count(DISTINCT n) as entity_count,
      count(DISTINCT r) as relationship_count,
      collect(DISTINCT n.type) as entity_types,
      collect(DISTINCT type(r)) as relationship_types
  `;
  
  const result = await neo4jClient.runQuery(statsQuery, { project_id: projectId });
  
  if (result.records.length === 0) {
    return {
      entity_count: 0,
      relationship_count: 0,
      entity_types: [],
      relationship_types: []
    };
  }
  
  const record = result.records[0];
  return {
    entity_count: record.get('entity_count').toNumber(),
    relationship_count: record.get('relationship_count').toNumber(),
    entity_types: record.get('entity_types').filter((type: string) => type !== null),
    relationship_types: record.get('relationship_types').filter((type: string) => type !== null)
  };
}

function sortProjects(projects: any[], sortBy: string) {
  return [...projects].sort((a, b) => {
    switch (sortBy) {
      case 'name':
        return (a.name || a.project_id).localeCompare(b.name || b.project_id);
      case 'created_at':
        return new Date(b.created_at || 0).getTime() - new Date(a.created_at || 0).getTime();
      case 'updated_at':
        return new Date(b.updated_at || 0).getTime() - new Date(a.updated_at || 0).getTime();
      default:
        return (a.name || a.project_id).localeCompare(b.name || b.project_id);
    }
  });
}

function sortProjectsWithStats(projects: any[], sortBy: string) {
  return [...projects].sort((a, b) => {
    switch (sortBy) {
      case 'name':
        return (a.name || a.project_id).localeCompare(b.name || b.project_id);
      case 'created_at':
        return new Date(b.created_at || 0).getTime() - new Date(a.created_at || 0).getTime();
      case 'updated_at':
        return new Date(b.updated_at || 0).getTime() - new Date(a.updated_at || 0).getTime();
      case 'entity_count':
        return b.stats.entity_count - a.stats.entity_count;
      default:
        return (a.name || a.project_id).localeCompare(b.name || b.project_id);
    }
  });
}

export const listProjectsTool = {
  name: 'list_projects',
  description: 'List all projects in the CodeRAG graph database with optional statistics',
  inputSchema: {
    type: 'object',
    properties: {
      include_stats: {
        type: 'boolean',
        description: 'Include detailed statistics for each project (entity counts, types, etc.)',
        default: false
      },
      sort_by: {
        type: 'string',
        enum: ['name', 'created_at', 'updated_at', 'entity_count'],
        description: 'Sort projects by the specified field',
        default: 'name'
      },
      limit: {
        type: 'number',
        description: 'Maximum number of projects to return',
        default: 100,
        minimum: 1,
        maximum: 1000
      }
    },
    required: []
  }
};


================================================
FILE: src/mcp/tools/metrics-analysis.ts
================================================
[Binary file]


================================================
FILE: src/mcp/tools/node-management.ts
================================================
import { NodeManager } from '../../graph/node-manager.js';
import { CodeNode } from '../../types.js';
import { applyTokenLimit, createPaginatedResponse } from '../../utils/token-limiter.js';

// Node Management Tool Parameters
export interface AddNodeParams {
  id: string;
  project: string;
  type: CodeNode['type'];
  name: string;
  qualified_name: string;
  description?: string;
  source_file?: string;
  start_line?: number;
  end_line?: number;
  modifiers?: string[];
  attributes?: Record<string, any>;
}

export interface UpdateNodeParams {
  id: string;
  project: string;
  updates: Record<string, any>;
}

export interface GetNodeParams {
  nodeId: string;
  projectId: string;
}

export interface DeleteNodeParams {
  id: string;
  project: string;
}

export interface FindNodesByTypeParams {
  nodeType: CodeNode['type'];
  projectId: string;
  limit?: number;
  offset?: number;
}

export interface SearchNodesParams {
  searchTerm: string;
  projectId: string;
  limit?: number;
  offset?: number;
}

// Node Management Functions
export async function addNode(
  nodeManager: NodeManager,
  params: AddNodeParams
) {
  try {
    const node: CodeNode = {
      id: params.id,
      project_id: params.project,
      type: params.type,
      name: params.name,
      qualified_name: params.qualified_name,
      description: params.description,
      source_file: params.source_file,
      start_line: params.start_line,
      end_line: params.end_line,
      modifiers: params.modifiers,
      attributes: params.attributes
    };

    const result = await nodeManager.addNode(node);
    return {
      content: [{ type: 'text', text: `Node created successfully: ${JSON.stringify(result, null, 2)}` }]
    };
  } catch (error) {
    return {
      isError: true,
      content: [{ type: 'text', text: `Failed to add node: ${error instanceof Error ? error.message : String(error)}` }]
    };
  }
}

export async function updateNode(
  nodeManager: NodeManager,
  params: UpdateNodeParams
) {
  try {
    const result = await nodeManager.updateNode(params.id, params.project, params.updates);
    return {
      content: [{ type: 'text', text: `Node updated successfully: ${JSON.stringify(result, null, 2)}` }]
    };
  } catch (error) {
    return {
      isError: true,
      content: [{ type: 'text', text: `Failed to update node: ${error instanceof Error ? error.message : String(error)}` }]
    };
  }
}

export async function getNode(
  nodeManager: NodeManager,
  params: GetNodeParams
) {
  try {
    const result = await nodeManager.getNode(params.nodeId, params.projectId);
    return {
      content: [{ type: 'text', text: result ? JSON.stringify(result, null, 2) : 'Node not found' }]
    };
  } catch (error) {
    return {
      isError: true,
      content: [{ type: 'text', text: `Failed to get node: ${error instanceof Error ? error.message : String(error)}` }]
    };
  }
}

export async function deleteNode(
  nodeManager: NodeManager,
  params: DeleteNodeParams
) {
  try {
    const result = await nodeManager.deleteNode(params.id, params.project);
    return {
      content: [{ type: 'text', text: result ? 'Node deleted successfully' : 'Node not found' }]
    };
  } catch (error) {
    return {
      isError: true,
      content: [{ type: 'text', text: `Failed to delete node: ${error instanceof Error ? error.message : String(error)}` }]
    };
  }
}

export async function findNodesByType(
  nodeManager: NodeManager,
  params: FindNodesByTypeParams
) {
  try {
    const allResults = await nodeManager.findNodesByType(params.nodeType, params.projectId);
    
    // Apply token limiting with pagination
    const limitedResult = createPaginatedResponse(
      allResults,
      params.offset || 0,
      params.limit
    );

    const response: {
      results: CodeNode[];
      pagination: {
        total: number;
        returned: number;
        offset: number;
        hasMore: boolean;
        nextOffset: number | undefined;
      };
      truncated: boolean;
      estimatedTokens: number;
      metadata?: any;
    } = {
      results: limitedResult.data,
      pagination: {
        total: limitedResult.originalCount,
        returned: limitedResult.returnedCount,
        offset: params.offset || 0,
        hasMore: limitedResult.hasMore,
        nextOffset: limitedResult.nextOffset
      },
      truncated: limitedResult.truncated,
      estimatedTokens: limitedResult.estimatedTokens
    };

    // Add metadata if results were truncated
    if (limitedResult.metadata) {
      response.metadata = limitedResult.metadata;
    }

    return {
      content: [{ type: 'text', text: JSON.stringify(response, null, 2) }]
    };
  } catch (error) {
    return {
      isError: true,
      content: [{ type: 'text', text: `Failed to find nodes: ${error instanceof Error ? error.message : String(error)}` }]
    };
  }
}

export async function searchNodes(
  nodeManager: NodeManager,
  params: SearchNodesParams
) {
  try {
    const allResults = await nodeManager.searchNodes(params.searchTerm, params.projectId);
    
    // Apply token limiting with pagination
    const limitedResult = createPaginatedResponse(
      allResults,
      params.offset || 0,
      params.limit
    );

    const response: {
      searchTerm: string;
      results: CodeNode[];
      pagination: {
        total: number;
        returned: number;
        offset: number;
        hasMore: boolean;
        nextOffset: number | undefined;
      };
      truncated: boolean;
      estimatedTokens: number;
      metadata?: any;
    } = {
      searchTerm: params.searchTerm,
      results: limitedResult.data,
      pagination: {
        total: limitedResult.originalCount,
        returned: limitedResult.returnedCount,
        offset: params.offset || 0,
        hasMore: limitedResult.hasMore,
        nextOffset: limitedResult.nextOffset
      },
      truncated: limitedResult.truncated,
      estimatedTokens: limitedResult.estimatedTokens
    };

    // Add metadata if results were truncated
    if (limitedResult.metadata) {
      response.metadata = limitedResult.metadata;
    }

    return {
      content: [{ type: 'text', text: JSON.stringify(response, null, 2) }]
    };
  } catch (error) {
    return {
      isError: true,
      content: [{ type: 'text', text: `Failed to search nodes: ${error instanceof Error ? error.message : String(error)}` }]
    };
  }
}


================================================
FILE: src/mcp/tools/relationship-analysis.ts
================================================
import { EdgeManager } from '../../graph/edge-manager.js';

// Relationship Analysis Tool Parameters
export interface FindMethodCallersParams {
  methodName: string;
  projectId: string;
}

export interface FindImplementationsParams {
  interfaceName: string;
  projectId: string;
}

export interface FindInheritanceHierarchyParams {
  className: string;
  projectId: string;
}

// Relationship Analysis Functions
export async function findMethodCallers(
  edgeManager: EdgeManager,
  params: FindMethodCallersParams
) {
  const result = await edgeManager.findClassesThatCallMethod(params.methodName, params.projectId);
  return {
    content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
  };
}

export async function findImplementations(
  edgeManager: EdgeManager,
  params: FindImplementationsParams
) {
  const result = await edgeManager.findClassesThatImplementInterface(params.interfaceName, params.projectId);
  return {
    content: [{ 
      type: 'text', 
      text: result.length > 0 ? JSON.stringify(result, null, 2) : 'No classes found' 
    }]
  };
}

export async function findInheritanceHierarchy(
  edgeManager: EdgeManager,
  params: FindInheritanceHierarchyParams
) {
  const result = await edgeManager.findInheritanceHierarchy(params.className, params.projectId);
  return {
    content: [{ type: 'text', text: JSON.stringify(result, null, 2) }]
  };
}


================================================
FILE: src/mcp/tools/remote-scanner-tools.ts
================================================
import { Tool } from '@modelcontextprotocol/sdk/types.js';
import { Neo4jClient } from '../../graph/neo4j-client.js';
import { CodebaseScanner } from '../../scanner/codebase-scanner.js';
import { Language } from '../../scanner/types.js';
import { z } from 'zod';

const scanRemoteRepoSchema = z.object({
  gitUrl: z.string().describe('Git repository URL (HTTPS, SSH, or Git protocol)'),
  projectId: z.string().optional().describe('Project ID for multi-project separation'),
  projectName: z.string().optional().describe('Project name'),
  languages: z.array(z.enum(['typescript', 'javascript', 'java', 'python', 'csharp'])).optional()
    .describe('Languages to scan (auto-detected if not specified)'),
  branch: z.string().optional().default('main').describe('Git branch to scan'),
  includeTests: z.boolean().optional().default(false).describe('Include test files in scan'),
  useCache: z.boolean().optional().default(false).describe('Enable repository caching'),
  clearGraph: z.boolean().optional().default(false).describe('Clear existing project data'),
  analyze: z.boolean().optional().default(false).describe('Run quality analysis after scanning')
});

const validateRemoteRepoSchema = z.object({
  gitUrl: z.string().describe('Git repository URL to validate')
});

const gitCacheStatsSchema = z.object({});

const clearGitCacheSchema = z.object({});

export function createRemoteScannerTools(client: Neo4jClient): Tool[] {
  const scanner = new CodebaseScanner(client);

  return [
    {
      name: 'scan_remote_repo',
      description: 'Scan a remote Git repository and populate the graph database. Supports GitHub, GitLab, Bitbucket, and custom Git servers.',
      inputSchema: {
        type: 'object',
        properties: {
          gitUrl: {
            type: 'string',
            description: 'Git repository URL (HTTPS, SSH, or Git protocol). Examples: https://github.com/owner/repo.git, git@github.com:owner/repo.git'
          },
          projectId: {
            type: 'string',
            description: 'Project ID for multi-project separation. Auto-generated from repository if not provided.'
          },
          projectName: {
            type: 'string',
            description: 'Project name for display purposes'
          },
          languages: {
            type: 'array',
            items: {
              type: 'string',
              enum: ['typescript', 'javascript', 'java', 'python', 'csharp']
            },
            description: 'Languages to scan. Auto-detected from repository if not specified.'
          },
          branch: {
            type: 'string',
            default: 'main',
            description: 'Git branch to scan'
          },
          includeTests: {
            type: 'boolean',
            default: false,
            description: 'Include test files in the scan'
          },
          useCache: {
            type: 'boolean',
            default: false,
            description: 'Enable repository caching for faster subsequent scans'
          },
          clearGraph: {
            type: 'boolean',
            default: false,
            description: 'Clear existing project data before scanning'
          },
          analyze: {
            type: 'boolean',
            default: false,
            description: 'Run quality analysis after scanning'
          }
        },
        required: ['gitUrl']
      }
    },

    {
      name: 'validate_remote_repo',
      description: 'Validate that a remote Git repository is accessible and can be scanned.',
      inputSchema: {
        type: 'object',
        properties: {
          gitUrl: {
            type: 'string',
            description: 'Git repository URL to validate'
          }
        },
        required: ['gitUrl']
      }
    },

    {
      name: 'git_cache_stats',
      description: 'Get statistics about the Git repository cache, including number of cached repositories and total size.',
      inputSchema: {
        type: 'object',
        properties: {},
        additionalProperties: false
      }
    },

    {
      name: 'clear_git_cache',
      description: 'Clear all cached Git repositories to free up disk space.',
      inputSchema: {
        type: 'object',
        properties: {},
        additionalProperties: false
      }
    }
  ];
}

export async function handleRemoteScannerTool(
  name: string,
  args: any,
  client: Neo4jClient
): Promise<any> {
  const scanner = new CodebaseScanner(client);

  switch (name) {
    case 'scan_remote_repo': {
      const params = scanRemoteRepoSchema.parse(args);
      
      // Generate project ID from repository if not provided
      let projectId = params.projectId;
      if (!projectId) {
        const parsedUrl = scanner.parseGitUrl(params.gitUrl);
        projectId = `${parsedUrl.owner}-${parsedUrl.repo}`;
      }

      // Clear graph if requested
      if (params.clearGraph) {
        await scanner.clearGraph(projectId);
      }

      // Scan the remote repository
      const result = await scanner.scanRemoteRepository(params.gitUrl, {
        projectId,
        projectName: params.projectName || projectId,
        languages: params.languages || ['typescript', 'javascript', 'java', 'python'],
        includeTests: params.includeTests,
        outputProgress: true,
        gitBranch: params.branch,
        useCache: params.useCache,
        cacheOptions: {
          forceRefresh: false
        }
      });

      // Run quality analysis if requested
      let analysisResult = null;
      if (params.analyze) {
        const { MetricsManager } = await import('../../analysis/metrics-manager.js');
        const metricsManager = new MetricsManager(client);
        
        try {
          // Get architectural issues and project summary
          const architecturalIssues = await metricsManager.findArchitecturalIssues();
          const projectSummary = await metricsManager.calculateProjectSummary();
          
          // Calculate a simple quality score based on issues
          const qualityScore = Math.max(0, Math.min(100, 100 - (architecturalIssues.length * 5)));
          
          analysisResult = {
            architecturalIssues: architecturalIssues.length,
            qualityScore,
            summary: projectSummary
          };
        } catch (error) {
          console.warn('Quality analysis failed:', error);
          analysisResult = {
            error: 'Quality analysis failed',
            message: error instanceof Error ? error.message : 'Unknown error'
          };
        }
      }

      return {
        success: true,
        projectId,
        repository: {
          url: params.gitUrl,
          branch: params.branch
        },
        scanResults: {
          filesProcessed: result.stats?.filesProcessed || 0,
          entitiesFound: result.stats?.entitiesFound || 0,
          relationshipsFound: result.stats?.relationshipsFound || 0,
          processingTimeMs: result.stats?.processingTimeMs || 0,
          errors: result.errors?.length || 0
        },
        analysis: analysisResult
      };
    }

    case 'validate_remote_repo': {
      const params = validateRemoteRepoSchema.parse(args);
      
      try {
        const isValid = await scanner.validateRemoteRepository(params.gitUrl);
        
        if (isValid) {
          // Get repository information
          const gitManager = (scanner as any).gitManager;
          const repoInfo = await gitManager.validateRepository(params.gitUrl);
          
          return {
            valid: true,
            repository: repoInfo
          };
        } else {
          return {
            valid: false,
            error: 'Repository validation failed'
          };
        }
      } catch (error) {
        return {
          valid: false,
          error: error instanceof Error ? error.message : 'Unknown validation error'
        };
      }
    }

    case 'git_cache_stats': {
      gitCacheStatsSchema.parse(args);
      
      const stats = await scanner.getCacheStats();
      
      return {
        cache: {
          entries: stats.entries,
          totalSizeBytes: stats.totalSize,
          totalSizeMB: Math.round(stats.totalSize / 1024 / 1024 * 100) / 100,
          oldestEntry: stats.oldestEntry?.toISOString(),
          newestEntry: stats.newestEntry?.toISOString()
        }
      };
    }

    case 'clear_git_cache': {
      clearGitCacheSchema.parse(args);
      
      const statsBefore = await scanner.getCacheStats();
      await scanner.clearCache();
      
      return {
        success: true,
        clearedEntries: statsBefore.entries,
        freedSpaceBytes: statsBefore.totalSize,
        freedSpaceMB: Math.round(statsBefore.totalSize / 1024 / 1024 * 100) / 100
      };
    }

    default:
      throw new Error(`Unknown remote scanner tool: ${name}`);
  }
}


================================================
FILE: src/mcp/tools/scanner-tools.ts
================================================
import { NodeManager } from '../../graph/node-manager.js';
import { EdgeManager } from '../../graph/edge-manager.js';
import { CodebaseScanner } from '../../scanner/codebase-scanner.js';
import { ScanConfig, Language } from '../../scanner/types.js';

// Scanner Tool Parameters
export interface AddFileParams {
  file_path: string;
  project: string;
  clear_existing?: boolean;
}

export interface ScanDirParams {
  project: string;
  directory_path: string;
  languages?: Language[];
  exclude_paths?: string[];
  include_tests?: boolean;
  max_depth?: number;
  clear_existing?: boolean;
}

// Helper Functions
export function findParser(codebaseScanner: CodebaseScanner, filePath: string): any {
  const parsers = [
    codebaseScanner['parsers'].get('typescript'),
    codebaseScanner['parsers'].get('java'),
    codebaseScanner['parsers'].get('python')
  ];

  for (const parser of parsers) {
    if (parser && parser.canParse(filePath)) {
      return parser;
    }
  }
  return null;
}

export async function storeParseResult(
  parseResult: any, 
  project: string,
  nodeManager: NodeManager,
  edgeManager: EdgeManager
): Promise<void> {
  // Store entities - they already have project_id from the parsers
  for (const entity of parseResult.entities) {
    try {
      await nodeManager.addNode(entity);
    } catch (error) {
      // Skip duplicates
      if (!(error instanceof Error) || !error.message.includes('already exists')) {
        console.warn(`Failed to store entity ${entity.id}: ${error instanceof Error ? error.message : String(error)}`);
      }
    }
  }

  // Store relationships - they already have project_id from the parsers
  for (const relationship of parseResult.relationships) {
    try {
      await edgeManager.addEdge(relationship);
    } catch (error) {
      // Skip duplicates
      if (!(error instanceof Error) || !error.message.includes('already exists')) {
        console.warn(`Failed to store relationship ${relationship.id}: ${error instanceof Error ? error.message : String(error)}`);
      }
    }
  }
}

export function summarizeEntityTypes(entities: any[]): string {
  const typeCounts = entities.reduce((acc, entity) => {
    acc[entity.type] = (acc[entity.type] || 0) + 1;
    return acc;
  }, {} as Record<string, number>);

  return Object.entries(typeCounts)
    .sort(([,a], [,b]) => (b as number) - (a as number))
    .map(([type, count]) => `  • ${type}: ${count}`)
    .join('\n') || '  No entities found';
}

// Scanner Tool Functions
export async function addFile(
  codebaseScanner: CodebaseScanner,
  nodeManager: NodeManager,
  edgeManager: EdgeManager,
  neo4jClient: any, // For clearing existing entities
  params: AddFileParams
) {
  try {
    const filePath = params.file_path;
    const clearExisting = params.clear_existing || false;

    // Check if file exists
    const fs = await import('fs');
    if (!fs.existsSync(filePath)) {
      return {
        content: [{ type: 'text', text: `❌ File not found: ${filePath}` }]
      };
    }

    // Clear existing entities from this file if requested
    if (clearExisting) {
      const query = `
        MATCH (n {source_file: $filePath, project: $project})
        DETACH DELETE n
      `;
      await neo4jClient.runQuery(query, { filePath, project: params.project });
    }

    // Read file content
    const content = await fs.promises.readFile(filePath, 'utf-8');

    // Find appropriate parser
    const parser = findParser(codebaseScanner, filePath);
    if (!parser) {
      const supportedExtensions = ['.ts', '.tsx', '.js', '.jsx', '.java', '.py'];
      return {
        content: [{ 
          type: 'text', 
          text: `❌ Unsupported file type: ${filePath}\nSupported extensions: ${supportedExtensions.join(', ')}` 
        }]
      };
    }

    // Parse the file
    const parseResult = await parser.parseFile(filePath, content, params.project);

    // Store entities and relationships
    await storeParseResult(parseResult, params.project, nodeManager, edgeManager);

    const summary = `✅ File parsed successfully: ${filePath}

📊 Results:
  • Entities found: ${parseResult.entities.length}
  • Relationships found: ${parseResult.relationships.length}
  • Errors: ${parseResult.errors.length}

🏗️ Entity Types:
${summarizeEntityTypes(parseResult.entities)}

${parseResult.errors.length > 0 ? `
⚠️ Parse Errors:
${parseResult.errors.slice(0, 5).map((e: any) => `  • Line ${e.line || '?'}: ${e.message}`).join('\n')}
${parseResult.errors.length > 5 ? `  ... and ${parseResult.errors.length - 5} more` : ''}
` : ''}`;

    return {
      content: [{ type: 'text', text: summary }]
    };

  } catch (error) {
    return {
      content: [{ 
        type: 'text', 
        text: `❌ Failed to parse file: ${error instanceof Error ? error.message : String(error)}` 
      }]
    };
  }
}

export async function scanDir(
  codebaseScanner: CodebaseScanner,
  params: ScanDirParams
) {
  try {
    const directoryPath = params.directory_path;
    const languages = params.languages?.length ? params.languages : undefined;
    const excludePaths = params.exclude_paths || [];
    const includeTests = params.include_tests || false;
    const clearExisting = params.clear_existing || false;
    const maxDepth = params.max_depth || 10;

    // Check if directory exists
    const fs = await import('fs');
    if (!fs.existsSync(directoryPath)) {
      return {
        content: [{ type: 'text', text: `❌ Directory not found: ${directoryPath}` }]
      };
    }

    // Validate project structure first
    const validation = await codebaseScanner.validateProjectStructure(directoryPath);
    
    if (!validation.isValid) {
      return {
        content: [{ 
          type: 'text', 
          text: `❌ Invalid project structure:\n${validation.suggestions.join('\n')}` 
        }]
      };
    }

    // Prepare scan configuration
    const scanConfig: ScanConfig = {
      projectPath: directoryPath,
      projectId: params.project,
      projectName: params.project,
      languages: languages || validation.detectedLanguages,
      excludePaths,
      includeTests,
      maxDepth,
      outputProgress: false // We'll handle our own progress reporting
    };

    // Clear existing project data if requested
    if (clearExisting) {
      await codebaseScanner.clearGraph(params.project);
    }

    // Perform the scan
    console.log(`🔍 Scanning directory: ${directoryPath}`);
    const scanResult = await codebaseScanner.scanProject(scanConfig);

    // Generate detailed report
    const report = await codebaseScanner.generateScanReport(scanResult);

    return {
      content: [{ type: 'text', text: report }]
    };

  } catch (error) {
    return {
      content: [{ 
        type: 'text', 
        text: `❌ Failed to scan directory: ${error instanceof Error ? error.message : String(error)}` 
      }]
    };
  }
}


================================================
FILE: src/mcp/tools/semantic-search.ts
================================================
import { SemanticSearchManager } from '../../services/semantic-search-manager.js';
import { SemanticSearchParams, SemanticSearchResult } from '../../types.js';

export interface SemanticSearchToolParams {
  query: string;
  project_id?: string;
  node_types?: string[];
  limit?: number;
  similarity_threshold?: number;
  include_graph_context?: boolean;
  max_hops?: number;
}

export interface UpdateEmbeddingsParams {
  project_id?: string;
  node_types?: string[];
}

export interface GetSimilarCodeParams {
  node_id: string;
  project_id: string;
  limit?: number;
}

export async function semanticSearch(
  semanticSearchManager: SemanticSearchManager,
  params: SemanticSearchToolParams
): Promise<{ results: SemanticSearchResult[]; total_found: number }> {
  try {
    const searchParams: SemanticSearchParams = {
      query: params.query,
      project_id: params.project_id,
      node_types: params.node_types as any[],
      limit: params.limit,
      similarity_threshold: params.similarity_threshold
    };

    let results: SemanticSearchResult[];

    if (params.include_graph_context) {
      results = await semanticSearchManager.hybridSearch(searchParams, {
        includeRelationships: true,
        maxHops: params.max_hops || 2
      });
    } else {
      results = await semanticSearchManager.semanticSearch(searchParams);
    }

    return {
      results,
      total_found: results.length
    };
  } catch (error) {
    throw new Error(`Semantic search failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}

export async function updateEmbeddings(
  semanticSearchManager: SemanticSearchManager,
  params: UpdateEmbeddingsParams
): Promise<{ message: string; updated: number; failed: number }> {
  try {
    const result = await semanticSearchManager.updateEmbeddings(
      params.project_id,
      params.node_types
    );

    return {
      message: `Embedding update completed. Updated: ${result.updated}, Failed: ${result.failed}`,
      updated: result.updated,
      failed: result.failed
    };
  } catch (error) {
    throw new Error(`Failed to update embeddings: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}

export async function getSimilarCode(
  semanticSearchManager: SemanticSearchManager,
  params: GetSimilarCodeParams
): Promise<{ results: SemanticSearchResult[]; total_found: number }> {
  try {
    const results = await semanticSearchManager.getSimilarNodes(
      params.node_id,
      params.project_id,
      params.limit || 5
    );

    return {
      results,
      total_found: results.length
    };
  } catch (error) {
    throw new Error(`Failed to get similar code: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}

export async function initializeSemanticSearch(
  semanticSearchManager: SemanticSearchManager
): Promise<{ message: string; success: boolean }> {
  try {
    await semanticSearchManager.initializeVectorIndexes();
    
    return {
      message: 'Semantic search initialized successfully. Vector indexes created.',
      success: true
    };
  } catch (error) {
    return {
      message: `Failed to initialize semantic search: ${error instanceof Error ? error.message : 'Unknown error'}`,
      success: false
    };
  }
}


================================================
FILE: src/scanner/codebase-scanner.ts
================================================
import * as fs from 'fs';
import * as path from 'path';
import { glob } from 'glob';
import { Neo4jClient } from '../graph/neo4j-client.js';
import { NodeManager } from '../graph/node-manager.js';
import { EdgeManager } from '../graph/edge-manager.js';
import { EmbeddingService } from '../services/embedding-service.js';
import { SemanticSearchManager } from '../services/semantic-search-manager.js';
import { TypeScriptParser } from './parsers/typescript-parser.js';
import { JavaParser } from './parsers/java-parser.js';
import { PythonParser } from './parsers/python-parser.js';
import { 
  ScanConfig, 
  ParseResult, 
  LanguageParser, 
  ParsedEntity, 
  ParsedRelationship,
  Language,
  ProjectDetectionResult 
} from './types.js';
import { ProjectLanguageDetector } from './detection/language-detector.js';
import { ProjectBuildFileDetector } from './detection/build-file-detector.js';
import { GitRepositoryManager, GitAuthConfig } from './git/index.js';

export class CodebaseScanner {
  private parsers: Map<Language, LanguageParser>;
  private nodeManager: NodeManager;
  private edgeManager: EdgeManager;
  private embeddingService: EmbeddingService;
  private semanticSearchManager: SemanticSearchManager;
  private languageDetector: ProjectLanguageDetector;
  private buildFileDetector: ProjectBuildFileDetector;
  private gitManager: GitRepositoryManager;

  constructor(private client: Neo4jClient) {
    this.nodeManager = new NodeManager(client);
    this.edgeManager = new EdgeManager(client);
    this.embeddingService = new EmbeddingService();
    this.semanticSearchManager = new SemanticSearchManager(client, this.embeddingService);
    this.languageDetector = new ProjectLanguageDetector();
    this.buildFileDetector = new ProjectBuildFileDetector();
    this.gitManager = new GitRepositoryManager();
    
    // Initialize parsers
    this.parsers = new Map();
    const tsParser = new TypeScriptParser();
    this.parsers.set('typescript', tsParser);
    this.parsers.set('javascript', tsParser);
    this.parsers.set('java', new JavaParser());
    this.parsers.set('python', new PythonParser());
  }

  async scanProject(config: ScanConfig): Promise<ParseResult> {
    const startTime = Date.now();
    
    let actualProjectPath = config.projectPath;
    let isTemporaryPath = false;

    // Handle remote repository cloning
    if (config.isRemote && config.gitUrl) {
      console.log(`🔍 Starting remote codebase scan for project '${config.projectId}': ${config.gitUrl}`);
      
      try {
        actualProjectPath = await this.gitManager.cloneRepository(config.gitUrl, {
          branch: config.gitBranch,
          depth: 1, // Shallow clone for efficiency
          singleBranch: true,
          tempDir: config.tempDir,
          useCache: config.useCache,
          cacheOptions: config.cacheOptions,
          progressCallback: config.outputProgress ? (progress) => {
            console.log(`📊 ${progress.message} ${progress.percentage ? `(${Math.round(progress.percentage)}%)` : ''}`);
          } : undefined
        });
        isTemporaryPath = true;
        console.log(`📥 Repository cloned to: ${actualProjectPath}`);
      } catch (error) {
        throw new Error(`Failed to clone remote repository: ${error instanceof Error ? error.message : 'Unknown error'}`);
      }
    } else {
      console.log(`🔍 Starting local codebase scan for project '${config.projectId}': ${config.projectPath}`);
    }
    
    // Create updated config with actual path
    const actualConfig: ScanConfig = {
      ...config,
      projectPath: actualProjectPath
    };
    
    // Ensure project exists in database
    await this.ensureProjectExists(actualConfig);
    
    const allEntities: ParsedEntity[] = [];
    const allRelationships: ParsedRelationship[] = [];
    const allErrors: any[] = [];
    let filesProcessed = 0;

    try {
      // Find all source files
      const files = await this.findSourceFiles(actualConfig);
      console.log(`📁 Found ${files.length} source files`);

      // Process files in batches
      const batchSize = 10;
      for (let i = 0; i < files.length; i += batchSize) {
        const batch = files.slice(i, i + batchSize);
        const batchResults = await Promise.all(
          batch.map(file => this.processFile(file, actualConfig))
        );

        for (const result of batchResults) {
          if (result) {
            allEntities.push(...result.entities);
            allRelationships.push(...result.relationships);
            allErrors.push(...result.errors);
            filesProcessed++;
          }
        }

        if (actualConfig.outputProgress) {
          console.log(`📊 Processed ${Math.min(i + batchSize, files.length)}/${files.length} files`);
        }
      }

      // Store entities and relationships in the graph
      console.log(`💾 Storing ${allEntities.length} entities and ${allRelationships.length} relationships...`);
      const storeErrors = await this.storeInGraph(allEntities, allRelationships);
      allErrors.push(...storeErrors);

      const processingTimeMs = Date.now() - startTime;
      
      const result: ParseResult = {
        entities: allEntities,
        relationships: allRelationships,
        errors: allErrors,
        stats: {
          filesProcessed,
          entitiesFound: allEntities.length,
          relationshipsFound: allRelationships.length,
          processingTimeMs
        }
      };

      console.log(`✅ Scan completed successfully!`);
      console.log(`   Files processed: ${filesProcessed}`);
      console.log(`   Entities found: ${allEntities.length}`);
      console.log(`   Relationships found: ${allRelationships.length}`);
      console.log(`   Processing time: ${(processingTimeMs / 1000).toFixed(2)}s`);
      
      if (allErrors.length > 0) {
        console.log(`⚠️  Warnings/Errors: ${allErrors.length}`);
      }

      return result;

    } catch (error) {
      console.error(`❌ Scan failed: ${error instanceof Error ? error.message : String(error)}`);
      throw error;
    } finally {
      // Cleanup temporary directory for remote repositories
      if (isTemporaryPath && (config.cleanupTemp !== false)) {
        try {
          await this.gitManager.cleanup(actualProjectPath);
        } catch (cleanupError) {
          console.warn(`⚠️  Failed to cleanup temporary directory: ${cleanupError instanceof Error ? cleanupError.message : 'Unknown error'}`);
        }
      }
    }
  }

  async clearGraph(projectId?: string): Promise<void> {
    if (projectId) {
      console.log(`🗑️  Clearing graph data for project '${projectId}'...`);
      const query = `
        MATCH (n:CodeNode {project_id: $project_id})
        OPTIONAL MATCH (n)-[r {project_id: $project_id}]-()
        DELETE n, r
      `;
      await this.client.runQuery(query, { project_id: projectId });
      console.log(`✅ Project '${projectId}' graph data cleared`);
    } else {
      console.log(`🗑️  Clearing all graph data...`);
      const query = `
        MATCH (n)
        DETACH DELETE n
      `;
      await this.client.runQuery(query);
      console.log(`✅ All graph data cleared`);
    }
  }

  private async ensureProjectExists(config: ScanConfig): Promise<void> {
    try {
      // Check if project already exists
      const existingProject = await this.client.getProject(config.projectId);
      
      if (!existingProject) {
        // Create new project
        console.log(`📋 Creating project '${config.projectId}'...`);
        await this.client.createProject({
          project_id: config.projectId,
          name: config.projectName || config.projectId,
          description: `Scanned from ${config.projectPath}`
        });
        console.log(`✅ Project '${config.projectId}' created`);
      } else {
        console.log(`📋 Using existing project '${config.projectId}'`);
      }
    } catch (error) {
      console.warn(`⚠️ Failed to create/verify project: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  async validateProjectStructure(projectPath: string): Promise<ProjectDetectionResult> {
    // Check if path exists
    if (!fs.existsSync(projectPath)) {
      return {
        isValid: false,
        suggestions: [`Project path does not exist: ${projectPath}`],
        detectedLanguages: [],
        projectMetadata: [],
        subProjects: [],
        isMonoRepo: false
      };
    }

    try {
      // Use the new comprehensive detection system
      const result = await this.buildFileDetector.detect(projectPath);
      
      // If no build files found, fallback to file extension detection
      if (result.detectedLanguages.length === 0) {
        const extensionLanguages = await this.languageDetector.detectFromFileExtensions(projectPath);
        result.detectedLanguages = extensionLanguages;
        result.suggestions.push('💡 No build files detected - using file extension detection');
        
        if (extensionLanguages.length === 0) {
          result.suggestions.push('⚠️ No source files found - check project path and file extensions');
          result.isValid = false;
        } else {
          result.isValid = true;
        }
      }

      // Add recommendations for project structure
      const srcDirExists = fs.existsSync(path.join(projectPath, 'src'));
      if (!srcDirExists && result.detectedLanguages.length > 0) {
        result.suggestions.push('💡 Consider organizing code in a src/ directory for better analysis');
      }

      // Add language validation warnings
      const validation = this.languageDetector.validateLanguages(result.detectedLanguages);
      result.suggestions.push(...validation.warnings);

      return result;
    } catch (error) {
      return {
        isValid: false,
        suggestions: [`❌ Failed to analyze project structure: ${error instanceof Error ? error.message : String(error)}`],
        detectedLanguages: [],
        projectMetadata: [],
        subProjects: [],
        isMonoRepo: false
      };
    }
  }

  /**
   * Get recommended scan configuration with auto-detected languages and metadata
   */
  async getRecommendedScanConfig(projectPath: string, projectId?: string): Promise<{
    scanConfig: Partial<ScanConfig>;
    projectMetadata: any[];
    suggestions: string[];
  }> {
    const detection = await this.validateProjectStructure(projectPath);
    const recommendation = await this.languageDetector.getRecommendedScanConfig(projectPath);

    const scanConfig: Partial<ScanConfig> = {
      projectPath,
      projectId: projectId || path.basename(projectPath),
      languages: recommendation.languages,
      excludePaths: recommendation.excludePaths,
      includeTests: recommendation.includeTests
    };

    // Extract project name from metadata if available
    const primaryMetadata = detection.projectMetadata.find(m => 
      m.language === recommendation.primaryLanguage
    ) || detection.projectMetadata[0];

    if (primaryMetadata?.name) {
      scanConfig.projectName = primaryMetadata.name;
    }

    return {
      scanConfig,
      projectMetadata: detection.projectMetadata,
      suggestions: [...detection.suggestions, ...recommendation.suggestions]
    };
  }

  private async findSourceFiles(config: ScanConfig): Promise<string[]> {
    const patterns = this.getFilePatterns(config.languages, config.includeTests);
    const excludePatterns = [
      'node_modules/**',
      'dist/**',
      'build/**',
      '.git/**',
      'coverage/**',
      '**/*.d.ts',
      ...(config.excludePaths || [])
    ];

    if (!config.includeTests) {
      excludePatterns.push('**/*.test.*', '**/*.spec.*', '**/test/**', '**/tests/**');
    }

    const files: string[] = [];
    
    for (const pattern of patterns) {
      const matches = await glob(pattern, {
        cwd: config.projectPath,
        ignore: excludePatterns,
        absolute: true
      });
      files.push(...matches);
    }

    // Remove duplicates and sort
    return [...new Set(files)].sort();
  }

  private getFilePatterns(languages: Language[], includeTests: boolean = false): string[] {
    const patterns: string[] = [];
    
    if (languages.includes('typescript')) {
      patterns.push('**/*.ts', '**/*.tsx');
    }
    if (languages.includes('javascript')) {
      patterns.push('**/*.js', '**/*.jsx');
    }
    if (languages.includes('java')) {
      // For Java, only include files from standard Maven/Gradle directory structure
      patterns.push('src/main/**/*.java');
      if (includeTests) {
        patterns.push('src/test/**/*.java');
      }
    }
    if (languages.includes('python')) {
      patterns.push('**/*.py');
    }
    if (languages.includes('csharp')) {
      patterns.push('**/*.cs');
    }

    return patterns;
  }

  private async processFile(filePath: string, config: ScanConfig): Promise<{
    entities: ParsedEntity[];
    relationships: ParsedRelationship[];
    errors: any[];
  } | null> {
    try {
      // Find appropriate parser
      const parser = this.findParser(filePath);
      if (!parser) {
        return null;
      }

      // Read file content
      const content = await fs.promises.readFile(filePath, 'utf-8');
      
      // Parse the file
      const result = await parser.parseFile(filePath, content, config.projectId);
      
      return result;

    } catch (error) {
      console.warn(`⚠️ Failed to process ${filePath}: ${error instanceof Error ? error.message : String(error)}`);
      return {
        entities: [],
        relationships: [],
        errors: [{
          file: filePath,
          message: error instanceof Error ? error.message : String(error),
          severity: 'error'
        }]
      };
    }
  }

  private findParser(filePath: string): LanguageParser | null {
    for (const parser of this.parsers.values()) {
      if (parser.canParse(filePath)) {
        return parser;
      }
    }
    return null;
  }

  private async storeInGraph(entities: ParsedEntity[], relationships: ParsedRelationship[]): Promise<any[]> {
    console.log(`📥 Storing entities...`);
    const errors: any[] = [];
    
    // Deduplicate entities by ID + project_id
    const entityMap = new Map<string, ParsedEntity>();
    for (const entity of entities) {
      const key = `${entity.project_id}:${entity.id}`;
      if (!entityMap.has(key)) {
        entityMap.set(key, entity);
      }
    }
    const deduplicatedEntities = Array.from(entityMap.values());
    
    console.log(`📥 Deduplicated ${entities.length} entities to ${deduplicatedEntities.length}`);
    
    // Debug: log entity type counts
    const entityTypeCounts = deduplicatedEntities.reduce((acc, e) => {
      acc[e.type] = (acc[e.type] || 0) + 1;
      return acc;
    }, {} as Record<string, number>);
    console.log(`📋 Entity types:`, entityTypeCounts);
    
    // Store entities in batches
    const entityBatchSize = 100;
    for (let i = 0; i < deduplicatedEntities.length; i += entityBatchSize) {
      const batch = deduplicatedEntities.slice(i, i + entityBatchSize);
      await Promise.all(batch.map(async (entity) => {
        try {
          await this.nodeManager.addNode({
            id: entity.id,
            project_id: entity.project_id,
            type: entity.type as any,
            name: entity.name,
            qualified_name: entity.qualified_name,
            description: entity.description,
            source_file: entity.source_file,
            start_line: entity.start_line,
            end_line: entity.end_line,
            modifiers: entity.modifiers,
            attributes: entity.attributes
          });
        } catch (error) {
          // Skip duplicates or other node creation errors
          if (!(error instanceof Error) || !error.message.includes('already exists')) {
            console.warn(`Failed to store entity ${entity.id}: ${error instanceof Error ? error.message : String(error)}`);
            errors.push({
              type: 'node_creation_error',
              entity_id: entity.id,
              message: error instanceof Error ? error.message : String(error),
              severity: 'error'
            });
          }
        }
      }));
    }

    console.log(`🔗 Storing relationships...`);
    
    // Debug: Check if relationship targets exist in entities
    const entityIds = new Set(deduplicatedEntities.map(e => e.id));
    const missingTargets = relationships.filter(r => !entityIds.has(r.source) || !entityIds.has(r.target));
    console.log(`📋 Missing relationship targets: ${missingTargets.length} out of ${relationships.length}`);
    
    if (missingTargets.length > 0) {
      console.log(`📋 Sample missing targets:`, missingTargets.slice(0, 3).map(r => `${r.source} -> ${r.target} (source exists: ${entityIds.has(r.source)}, target exists: ${entityIds.has(r.target)})`));
    }
    
    // Store relationships in batches
    const relationshipBatchSize = 100;
    for (let i = 0; i < relationships.length; i += relationshipBatchSize) {
      const batch = relationships.slice(i, i + relationshipBatchSize);
      await Promise.all(batch.map(async (relationship) => {
        try {
          await this.edgeManager.addEdge({
            id: relationship.id,
            project_id: relationship.project_id,
            type: relationship.type as any,
            source: relationship.source,
            target: relationship.target,
            attributes: relationship.attributes
          });
        } catch (error) {
          // Skip duplicates or other relationship creation errors
          if (!(error instanceof Error) || !error.message.includes('already exists')) {
            console.warn(`Failed to store relationship ${relationship.id}: ${error instanceof Error ? error.message : String(error)}`);
            errors.push({
              type: 'edge_creation_error',
              relationship_id: relationship.id,
              source: relationship.source,
              target: relationship.target,
              message: error instanceof Error ? error.message : String(error),
              severity: 'error'
            });
          }
        }
      }));
    }

    // Generate embeddings if semantic search is enabled
    if (this.embeddingService.isEnabled()) {
      console.log(`🧠 Generating semantic embeddings for ${deduplicatedEntities.length} entities...`);
      try {
        const embeddingResult = await this.generateEmbeddingsForEntities(deduplicatedEntities);
        console.log(`✅ Generated embeddings for ${embeddingResult.successful} entities (${embeddingResult.failed} failed)`);
        
        if (embeddingResult.failed > 0) {
          errors.push({
            type: 'embedding_generation_error',
            message: `Failed to generate embeddings for ${embeddingResult.failed} entities`,
            severity: 'warning'
          });
        }
      } catch (error) {
        console.warn(`⚠️ Failed to generate embeddings: ${error instanceof Error ? error.message : String(error)}`);
        errors.push({
          type: 'embedding_generation_error',
          message: error instanceof Error ? error.message : String(error),
          severity: 'warning'
        });
      }
    } else {
      console.log(`🧠 Semantic search disabled, skipping embedding generation`);
    }
    
    return errors;
  }

  async generateScanReport(result: ParseResult): Promise<string> {
    const { stats, entities, relationships, errors } = result;
    
    // Analyze entities by type
    const entityTypes = entities.reduce((acc, entity) => {
      acc[entity.type] = (acc[entity.type] || 0) + 1;
      return acc;
    }, {} as Record<string, number>);

    // Analyze relationships by type
    const relationshipTypes = relationships.reduce((acc, rel) => {
      acc[rel.type] = (acc[rel.type] || 0) + 1;
      return acc;
    }, {} as Record<string, number>);

    // Find largest classes (by method count)
    const classMethodCounts = relationships
      .filter(r => r.type === 'contains' && entities.find(e => e.id === r.target)?.type === 'method')
      .reduce((acc, r) => {
        acc[r.source] = (acc[r.source] || 0) + 1;
        return acc;
      }, {} as Record<string, number>);

    const topClasses = Object.entries(classMethodCounts)
      .sort(([,a], [,b]) => b - a)
      .slice(0, 5)
      .map(([classId, count]) => {
        const entity = entities.find(e => e.id === classId);
        return `  • ${entity?.name || classId}: ${count} methods`;
      });

    const report = `
📊 CODEBASE SCAN REPORT
═══════════════════════

📈 STATISTICS
  Files processed: ${stats.filesProcessed}
  Entities found: ${stats.entitiesFound}
  Relationships found: ${stats.relationshipsFound}
  Processing time: ${(stats.processingTimeMs / 1000).toFixed(2)}s
  ${errors.length > 0 ? `Errors/Warnings: ${errors.length}` : ''}

🏗️ ENTITY BREAKDOWN
${Object.entries(entityTypes)
  .sort(([,a], [,b]) => b - a)
  .map(([type, count]) => `  • ${type}: ${count}`)
  .join('\n')}

🔗 RELATIONSHIP BREAKDOWN
${Object.entries(relationshipTypes)
  .sort(([,a], [,b]) => b - a)
  .map(([type, count]) => `  • ${type}: ${count}`)
  .join('\n')}

🏆 LARGEST CLASSES (by method count)
${topClasses.join('\n') || '  No classes found'}

${errors.length > 0 ? `
⚠️ ISSUES DETECTED
${errors.slice(0, 10).map(e => `  • ${e.file_path}: ${e.message}`).join('\n')}
${errors.length > 10 ? `  ... and ${errors.length - 10} more` : ''}
` : '✅ No issues detected'}

`;

    return report;
  }

  private async generateEmbeddingsForEntities(entities: ParsedEntity[]): Promise<{ successful: number; failed: number }> {
    let successful = 0;
    let failed = 0;

    // Filter entities that would benefit from embeddings
    const relevantEntities = entities.filter(entity => 
      ['class', 'interface', 'method', 'function', 'enum'].includes(entity.type) &&
      (entity.description || entity.name || entity.qualified_name)
    );

    if (relevantEntities.length === 0) {
      return { successful: 0, failed: 0 };
    }

    // Process in batches to avoid overwhelming the API
    const batchSize = 50;
    for (let i = 0; i < relevantEntities.length; i += batchSize) {
      const batch = relevantEntities.slice(i, i + batchSize);
      
      try {
        // Extract semantic content for the batch
        const contents = batch.map(entity => this.embeddingService.extractSemanticContent(entity));
        
        // Generate embeddings
        const embeddings = await this.embeddingService.generateEmbeddings(contents);
        
        // Store embeddings
        for (let j = 0; j < batch.length; j++) {
          const entity = batch[j];
          const embedding = embeddings[j];
          
          if (embedding) {
            try {
              await this.semanticSearchManager.addEmbeddingToNode(
                entity.id, 
                entity.project_id, 
                embedding
              );
              successful++;
            } catch (error) {
              console.warn(`Failed to store embedding for entity ${entity.id}:`, error);
              failed++;
            }
          } else {
            failed++;
          }
        }
      } catch (error) {
        console.warn(`Failed to process embedding batch starting at index ${i}:`, error);
        failed += batch.length;
      }
    }

    return { successful, failed };
  }

  async scanRemoteRepository(
    gitUrl: string, 
    config: Omit<ScanConfig, 'projectPath' | 'isRemote' | 'gitUrl'>
  ): Promise<ParseResult> {
    const remoteConfig: ScanConfig = {
      ...config,
      projectPath: '', // Will be set by cloning
      isRemote: true,
      gitUrl,
      cleanupTemp: true
    };
    
    return this.scanProject(remoteConfig);
  }

  async validateRemoteRepository(gitUrl: string): Promise<boolean> {
    try {
      await this.gitManager.validateRepository(gitUrl);
      return true;
    } catch {
      return false;
    }
  }

  isGitUrl(url: string): boolean {
    return this.gitManager.isGitUrl(url);
  }

  parseGitUrl(url: string) {
    return this.gitManager.parseGitUrl(url);
  }

  updateGitAuthConfig(authConfig: GitAuthConfig): void {
    this.gitManager.updateAuthConfig(authConfig);
  }

  async clearCache(): Promise<void> {
    await this.gitManager.clearCache();
  }

  async getCacheStats() {
    return this.gitManager.getCacheStats();
  }
}


================================================
FILE: src/scanner/types.ts
================================================
export interface ScanConfig {
  projectPath: string;
  projectId: string;
  projectName?: string;
  languages: Language[];
  excludePaths?: string[];
  includeTests?: boolean;
  maxDepth?: number;
  outputProgress?: boolean;
  // Remote repository support
  isRemote?: boolean;
  gitUrl?: string;
  gitBranch?: string;
  tempDir?: string;
  cleanupTemp?: boolean;
  useCache?: boolean;
  cacheOptions?: {
    maxAge?: number;
    forceRefresh?: boolean;
  };
}

export type Language = 'typescript' | 'javascript' | 'java' | 'python' | 'csharp';

export interface ParsedEntity {
  id: string;
  project_id: string;
  type: 'class' | 'interface' | 'enum' | 'exception' | 'function' | 'method' | 'field' | 'package' | 'module';
  name: string;
  qualified_name: string;
  description?: string;
  source_file: string;
  start_line?: number;
  end_line?: number;
  modifiers?: string[];
  annotations?: any[];
  attributes?: {
    parameters?: Array<{
      name: string;
      type: string;
      description?: string;
    }>;
    return_type?: string;
    implements?: string[];
    extends?: string;
    [key: string]: any;
  };
}

export interface ParsedRelationship {
  id: string;
  project_id: string;
  type: 'calls' | 'implements' | 'extends' | 'contains' | 'references' | 'throws' | 'belongs_to';
  source: string;
  target: string;
  source_file: string;
  attributes?: {
    [key: string]: any;
  };
}

export interface ParseResult {
  entities: ParsedEntity[];
  relationships: ParsedRelationship[];
  errors: ParseError[];
  stats: {
    filesProcessed: number;
    entitiesFound: number;
    relationshipsFound: number;
    processingTimeMs: number;
  };
}

export interface ParseError {
  project_id?: string;
  file_path: string;
  line?: number;
  message: string;
  severity?: 'warning' | 'error';
}

export interface LanguageParser {
  canParse(filePath: string): boolean;
  parseFile(filePath: string, content: string, projectId: string): Promise<{
    entities: ParsedEntity[];
    relationships: ParsedRelationship[];
    errors: ParseError[];
  }>;
}

// New interfaces for improved language detection and project metadata

export interface ProjectMetadata {
  name?: string;
  version?: string;
  description?: string;
  language: Language;
  buildSystem?: BuildSystem;
  dependencies?: string[];
  devDependencies?: string[];
  framework?: string;
  subProjects?: SubProject[];
  buildFilePath: string;
}

export interface SubProject {
  name: string;
  path: string;
  language: Language;
  buildSystem?: BuildSystem;
  metadata?: ProjectMetadata;
}

export interface ProjectDetectionResult {
  isValid: boolean;
  suggestions: string[];
  detectedLanguages: Language[];
  primaryLanguage?: Language;
  projectMetadata: ProjectMetadata[];
  subProjects: SubProject[];
  isMonoRepo: boolean;
}

export type BuildSystem = 
  | 'npm' | 'yarn' | 'pnpm'           // JavaScript/TypeScript
  | 'maven' | 'gradle' | 'ant'         // Java
  | 'pip' | 'poetry' | 'pipenv' | 'conda' // Python
  | 'dotnet' | 'msbuild' | 'nuget'     // C#
  | 'make' | 'cmake' | 'bazel';        // General

export interface BuildFileDetector {
  detect(projectPath: string): Promise<ProjectDetectionResult>;
  canDetect(filePath: string): boolean;
  extractMetadata(filePath: string): Promise<ProjectMetadata | null>;
}

export interface LanguageDetector {
  detectFromBuildFiles(projectPath: string): Promise<Language[]>;
  detectFromFileExtensions(projectPath: string): Promise<Language[]>;
  detectPrimaryLanguage(languages: Language[], projectPath: string): Promise<Language | undefined>;
}


================================================
FILE: src/scanner/detection/build-file-detector.ts
================================================
import * as fs from 'fs';
import * as path from 'path';
import { glob } from 'glob';
import { 
  BuildFileDetector, 
  ProjectDetectionResult, 
  ProjectMetadata, 
  SubProject, 
  Language, 
  BuildSystem 
} from '../types.js';

export class ProjectBuildFileDetector implements BuildFileDetector {
  private buildFilePatterns = {
    // JavaScript/TypeScript
    'package.json': { language: 'typescript' as Language, buildSystem: 'npm' as BuildSystem },
    'yarn.lock': { language: 'typescript' as Language, buildSystem: 'yarn' as BuildSystem },
    'pnpm-lock.yaml': { language: 'typescript' as Language, buildSystem: 'pnpm' as BuildSystem },
    'tsconfig.json': { language: 'typescript' as Language },
    
    // Java
    'pom.xml': { language: 'java' as Language, buildSystem: 'maven' as BuildSystem },
    'build.gradle': { language: 'java' as Language, buildSystem: 'gradle' as BuildSystem },
    'build.gradle.kts': { language: 'java' as Language, buildSystem: 'gradle' as BuildSystem },
    'settings.gradle': { language: 'java' as Language, buildSystem: 'gradle' as BuildSystem },
    'gradle.properties': { language: 'java' as Language, buildSystem: 'gradle' as BuildSystem },
    'build.xml': { language: 'java' as Language, buildSystem: 'ant' as BuildSystem },
    
    // Python
    'setup.py': { language: 'python' as Language, buildSystem: 'pip' as BuildSystem },
    'pyproject.toml': { language: 'python' as Language, buildSystem: 'poetry' as BuildSystem },
    'requirements.txt': { language: 'python' as Language, buildSystem: 'pip' as BuildSystem },
    'Pipfile': { language: 'python' as Language, buildSystem: 'pipenv' as BuildSystem },
    'poetry.lock': { language: 'python' as Language, buildSystem: 'poetry' as BuildSystem },
    'environment.yml': { language: 'python' as Language, buildSystem: 'conda' as BuildSystem },
    'conda.yml': { language: 'python' as Language, buildSystem: 'conda' as BuildSystem },
    
    // C#
    '*.csproj': { language: 'csharp' as Language, buildSystem: 'dotnet' as BuildSystem },
    '*.sln': { language: 'csharp' as Language, buildSystem: 'dotnet' as BuildSystem },
    '*.fsproj': { language: 'csharp' as Language, buildSystem: 'dotnet' as BuildSystem },
    'packages.config': { language: 'csharp' as Language, buildSystem: 'nuget' as BuildSystem },
    
    // General
    'Makefile': { buildSystem: 'make' as BuildSystem },
    'CMakeLists.txt': { buildSystem: 'cmake' as BuildSystem },
    'BUILD': { buildSystem: 'bazel' as BuildSystem },
    'BUILD.bazel': { buildSystem: 'bazel' as BuildSystem }
  };

  async detect(projectPath: string): Promise<ProjectDetectionResult> {
    const suggestions: string[] = [];
    const detectedLanguages: Language[] = [];
    const projectMetadata: ProjectMetadata[] = [];
    const subProjects: SubProject[] = [];
    
    // Find all build files in the project
    const buildFiles = await this.findBuildFiles(projectPath);
    
    if (buildFiles.length === 0) {
      suggestions.push('⚠️ No build files found - this may not be a valid project');
      suggestions.push('💡 Consider adding appropriate build files (package.json, pom.xml, etc.)');
    }

    // Process each build file
    for (const buildFile of buildFiles) {
      try {
        const metadata = await this.extractMetadata(buildFile);
        if (metadata) {
          projectMetadata.push(metadata);
          if (!detectedLanguages.includes(metadata.language)) {
            detectedLanguages.push(metadata.language);
          }
          
          // Check if this is a sub-project
          if (path.dirname(buildFile) !== projectPath) {
            const subProjectPath = path.dirname(buildFile);
            const subProjectName = metadata.name || path.basename(subProjectPath);
            
            subProjects.push({
              name: subProjectName,
              path: subProjectPath,
              language: metadata.language,
              buildSystem: metadata.buildSystem,
              metadata
            });
          }
        }
      } catch (error) {
        suggestions.push(`⚠️ Failed to parse build file ${buildFile}: ${error instanceof Error ? error.message : String(error)}`);
      }
    }

    // Determine if this is a mono-repo
    const isMonoRepo = subProjects.length > 1 || 
                      (subProjects.length === 1 && projectMetadata.length > 1);

    // Determine primary language
    const primaryLanguage = await this.determinePrimaryLanguage(detectedLanguages, projectPath);

    // Add language-specific suggestions
    this.addLanguageSpecificSuggestions(suggestions, detectedLanguages, projectMetadata, isMonoRepo);

    return {
      isValid: detectedLanguages.length > 0,
      suggestions,
      detectedLanguages,
      primaryLanguage,
      projectMetadata,
      subProjects,
      isMonoRepo
    };
  }

  canDetect(filePath: string): boolean {
    const fileName = path.basename(filePath);
    return Object.keys(this.buildFilePatterns).some(pattern => {
      if (pattern.includes('*')) {
        // Handle glob patterns like *.csproj
        const regex = new RegExp(pattern.replace(/\*/g, '.*'));
        return regex.test(fileName);
      }
      return fileName === pattern;
    });
  }

  async extractMetadata(filePath: string): Promise<ProjectMetadata | null> {
    if (!fs.existsSync(filePath)) {
      return null;
    }

    const fileName = path.basename(filePath);
    const content = await fs.promises.readFile(filePath, 'utf-8');

    try {
      // Route to appropriate parser based on file type
      switch (fileName) {
        case 'package.json':
          return this.parsePackageJson(filePath, content);
        case 'pom.xml':
          return this.parsePomXml(filePath, content);
        case 'build.gradle':
        case 'build.gradle.kts':
          return this.parseBuildGradle(filePath, content);
        case 'setup.py':
          return this.parseSetupPy(filePath, content);
        case 'pyproject.toml':
          return this.parsePyprojectToml(filePath, content);
        default:
          if (fileName.endsWith('.csproj') || fileName.endsWith('.fsproj')) {
            return this.parseCsProj(filePath, content);
          }
          if (fileName.endsWith('.sln')) {
            return this.parseSolution(filePath, content);
          }
          return this.parseGenericBuildFile(filePath, fileName);
      }
    } catch (error) {
      console.warn(`Failed to parse ${filePath}: ${error instanceof Error ? error.message : String(error)}`);
      return null;
    }
  }

  private async findBuildFiles(projectPath: string): Promise<string[]> {
    const patterns = Object.keys(this.buildFilePatterns);
    const buildFiles: string[] = [];

    for (const pattern of patterns) {
      try {
        const files = await glob(pattern, {
          cwd: projectPath,
          absolute: true,
          ignore: ['node_modules/**', 'dist/**', 'build/**', '.git/**', 'target/**']
        });
        buildFiles.push(...files);
      } catch (error) {
        // Ignore glob errors for specific patterns
      }
    }

    return [...new Set(buildFiles)]; // Remove duplicates
  }

  private parsePackageJson(filePath: string, content: string): ProjectMetadata {
    const pkg = JSON.parse(content);
    const hasTypeScript = pkg.devDependencies?.typescript || 
                         pkg.dependencies?.typescript ||
                         fs.existsSync(path.join(path.dirname(filePath), 'tsconfig.json'));
    
    return {
      name: pkg.name,
      version: pkg.version,
      description: pkg.description,
      language: hasTypeScript ? 'typescript' : 'javascript',
      buildSystem: this.determineBuildSystem(path.dirname(filePath)),
      dependencies: pkg.dependencies ? Object.keys(pkg.dependencies) : [],
      devDependencies: pkg.devDependencies ? Object.keys(pkg.devDependencies) : [],
      framework: this.detectFramework(pkg),
      buildFilePath: filePath
    };
  }

  private parsePomXml(filePath: string, content: string): ProjectMetadata {
    // Basic XML parsing for Maven pom.xml
    const nameMatch = content.match(/<artifactId>(.*?)<\/artifactId>/);
    const versionMatch = content.match(/<version>(.*?)<\/version>/);
    const descMatch = content.match(/<description>(.*?)<\/description>/);
    
    return {
      name: nameMatch?.[1],
      version: versionMatch?.[1],
      description: descMatch?.[1],
      language: 'java',
      buildSystem: 'maven',
      buildFilePath: filePath
    };
  }

  private parseBuildGradle(filePath: string, content: string): ProjectMetadata {
    // Basic parsing for Gradle build files
    const nameMatch = content.match(/rootProject\.name\s*=\s*['"]([^'"]+)['"]/);
    const versionMatch = content.match(/version\s*=\s*['"]([^'"]+)['"]/);
    
    return {
      name: nameMatch?.[1] || path.basename(path.dirname(filePath)),
      version: versionMatch?.[1],
      language: 'java',
      buildSystem: 'gradle',
      buildFilePath: filePath
    };
  }

  private parseSetupPy(filePath: string, content: string): ProjectMetadata {
    // Basic parsing for Python setup.py
    const nameMatch = content.match(/name\s*=\s*['"]([^'"]+)['"]/);
    const versionMatch = content.match(/version\s*=\s*['"]([^'"]+)['"]/);
    const descMatch = content.match(/description\s*=\s*['"]([^'"]+)['"]/);
    
    return {
      name: nameMatch?.[1],
      version: versionMatch?.[1],
      description: descMatch?.[1],
      language: 'python',
      buildSystem: 'pip',
      buildFilePath: filePath
    };
  }

  private parsePyprojectToml(filePath: string, content: string): ProjectMetadata {
    // Basic TOML parsing for pyproject.toml
    const nameMatch = content.match(/name\s*=\s*"([^"]+)"/);
    const versionMatch = content.match(/version\s*=\s*"([^"]+)"/);
    const descMatch = content.match(/description\s*=\s*"([^"]+)"/);
    
    return {
      name: nameMatch?.[1],
      version: versionMatch?.[1],
      description: descMatch?.[1],
      language: 'python',
      buildSystem: 'poetry',
      buildFilePath: filePath
    };
  }

  private parseCsProj(filePath: string, content: string): ProjectMetadata {
    const nameMatch = content.match(/<AssemblyName>(.*?)<\/AssemblyName>/) ||
                     content.match(/<ProjectName>(.*?)<\/ProjectName>/);
    const versionMatch = content.match(/<Version>(.*?)<\/Version>/);
    
    return {
      name: nameMatch?.[1] || path.basename(filePath, path.extname(filePath)),
      version: versionMatch?.[1],
      language: 'csharp',
      buildSystem: 'dotnet',
      buildFilePath: filePath
    };
  }

  private parseSolution(filePath: string, content: string): ProjectMetadata {
    return {
      name: path.basename(filePath, '.sln'),
      language: 'csharp',
      buildSystem: 'dotnet',
      buildFilePath: filePath
    };
  }

  private parseGenericBuildFile(filePath: string, fileName: string): ProjectMetadata {
    const pattern = Object.keys(this.buildFilePatterns).find(p => 
      p.includes('*') ? new RegExp(p.replace(/\*/g, '.*')).test(fileName) : p === fileName
    );
    
    const config = pattern ? this.buildFilePatterns[pattern as keyof typeof this.buildFilePatterns] : null;
    
    let language: Language = 'typescript'; // default fallback
    let buildSystem: BuildSystem | undefined = undefined;
    
    if (config) {
      if ('language' in config) {
        language = config.language;
      }
      if ('buildSystem' in config) {
        buildSystem = config.buildSystem;
      }
    }
    
    return {
      name: path.basename(path.dirname(filePath)),
      language,
      buildSystem,
      buildFilePath: filePath
    };
  }

  private determineBuildSystem(projectPath: string): BuildSystem {
    if (fs.existsSync(path.join(projectPath, 'yarn.lock'))) return 'yarn';
    if (fs.existsSync(path.join(projectPath, 'pnpm-lock.yaml'))) return 'pnpm';
    return 'npm';
  }

  private detectFramework(pkg: any): string | undefined {
    const allDeps = { ...pkg.dependencies, ...pkg.devDependencies };
    
    if (allDeps.react) return 'React';
    if (allDeps.vue) return 'Vue';
    if (allDeps['@angular/core']) return 'Angular';
    if (allDeps.express) return 'Express';
    if (allDeps['@nestjs/core']) return 'NestJS';
    if (allDeps.next) return 'Next.js';
    
    return undefined;
  }

  private async determinePrimaryLanguage(languages: Language[], projectPath: string): Promise<Language | undefined> {
    if (languages.length === 0) return undefined;
    if (languages.length === 1) return languages[0];

    // Count files by language to determine primary
    const languageCounts: Record<Language, number> = {} as any;
    
    for (const lang of languages) {
      const extensions = this.getLanguageExtensions(lang);
      let count = 0;
      
      for (const ext of extensions) {
        const files = await glob(`**/*${ext}`, {
          cwd: projectPath,
          ignore: ['node_modules/**', 'dist/**', 'build/**', '.git/**']
        });
        count += files.length;
      }
      
      languageCounts[lang] = count;
    }

    // Return language with most files
    return Object.entries(languageCounts)
      .sort(([, a], [, b]) => b - a)[0]?.[0] as Language;
  }

  private getLanguageExtensions(language: Language): string[] {
    switch (language) {
      case 'typescript': return ['.ts', '.tsx'];
      case 'javascript': return ['.js', '.jsx'];
      case 'java': return ['.java'];
      case 'python': return ['.py'];
      case 'csharp': return ['.cs'];
      default: return [];
    }
  }

  private addLanguageSpecificSuggestions(
    suggestions: string[],
    languages: Language[],
    metadata: ProjectMetadata[],
    isMonoRepo: boolean
  ): void {
    if (isMonoRepo) {
      suggestions.push('🏗️ Mono-repository detected with multiple sub-projects');
    }

    for (const meta of metadata) {
      suggestions.push(`✅ ${meta.language} project detected: ${meta.name || 'unnamed'}`);
      
      if (meta.buildSystem) {
        suggestions.push(`🔧 Build system: ${meta.buildSystem}`);
      }
      
      if (meta.framework) {
        suggestions.push(`🚀 Framework: ${meta.framework}`);
      }
    }

    if (languages.length > 1) {
      suggestions.push(`🔀 Multi-language project detected: ${languages.join(', ')}`);
    }
  }
}


================================================
FILE: src/scanner/detection/language-detector.ts
================================================
import * as fs from 'fs';
import * as path from 'path';
import { glob } from 'glob';
import { LanguageDetector, Language } from '../types.js';
import { ProjectBuildFileDetector } from './build-file-detector.js';

export class ProjectLanguageDetector implements LanguageDetector {
  private buildFileDetector: ProjectBuildFileDetector;

  constructor() {
    this.buildFileDetector = new ProjectBuildFileDetector();
  }

  async detectFromBuildFiles(projectPath: string): Promise<Language[]> {
    try {
      const result = await this.buildFileDetector.detect(projectPath);
      return result.detectedLanguages;
    } catch (error) {
      console.warn(`Failed to detect languages from build files: ${error instanceof Error ? error.message : String(error)}`);
      return [];
    }
  }

  async detectFromFileExtensions(projectPath: string): Promise<Language[]> {
    const detectedLanguages: Language[] = [];

    try {
      // Find all source files
      const files = await glob('**/*.{ts,tsx,js,jsx,java,py,cs}', {
        cwd: projectPath,
        ignore: ['node_modules/**', 'dist/**', 'build/**', '.git/**', 'target/**', 'coverage/**']
      });

      const extensions = new Set(files.map(f => path.extname(f).toLowerCase()));

      // Map extensions to languages
      if (extensions.has('.ts') || extensions.has('.tsx')) {
        detectedLanguages.push('typescript');
      }
      if (extensions.has('.js') || extensions.has('.jsx')) {
        detectedLanguages.push('javascript');
      }
      if (extensions.has('.java')) {
        detectedLanguages.push('java');
      }
      if (extensions.has('.py')) {
        detectedLanguages.push('python');
      }
      if (extensions.has('.cs')) {
        detectedLanguages.push('csharp');
      }

      return detectedLanguages;
    } catch (error) {
      console.warn(`Failed to detect languages from file extensions: ${error instanceof Error ? error.message : String(error)}`);
      return [];
    }
  }

  async detectPrimaryLanguage(languages: Language[], projectPath: string): Promise<Language | undefined> {
    if (languages.length === 0) return undefined;
    if (languages.length === 1) return languages[0];

    // First, try to determine primary language from build files
    const buildFileResult = await this.buildFileDetector.detect(projectPath);
    if (buildFileResult.primaryLanguage) {
      return buildFileResult.primaryLanguage;
    }

    // Fallback: count files by language
    const languageCounts: Record<Language, number> = {} as any;

    for (const lang of languages) {
      const extensions = this.getLanguageExtensions(lang);
      let count = 0;

      for (const ext of extensions) {
        try {
          const files = await glob(`**/*${ext}`, {
            cwd: projectPath,
            ignore: ['node_modules/**', 'dist/**', 'build/**', '.git/**', 'target/**']
          });
          count += files.length;
        } catch (error) {
          // Continue with other extensions
        }
      }

      languageCounts[lang] = count;
    }

    // Return language with most files
    const sortedLanguages = Object.entries(languageCounts)
      .sort(([, a], [, b]) => b - a);

    return sortedLanguages[0]?.[0] as Language;
  }

  private getLanguageExtensions(language: Language): string[] {
    switch (language) {
      case 'typescript': return ['.ts', '.tsx'];
      case 'javascript': return ['.js', '.jsx'];
      case 'java': return ['.java'];
      case 'python': return ['.py'];
      case 'csharp': return ['.cs'];
      default: return [];
    }
  }

  /**
   * Comprehensive language detection combining build files and file extensions
   */
  async detectLanguages(projectPath: string): Promise<{
    languages: Language[];
    primaryLanguage?: Language;
    buildFileLanguages: Language[];
    extensionLanguages: Language[];
  }> {
    const buildFileLanguages = await this.detectFromBuildFiles(projectPath);
    const extensionLanguages = await this.detectFromFileExtensions(projectPath);

    // Combine and deduplicate languages
    const allLanguages = [...new Set([...buildFileLanguages, ...extensionLanguages])];

    // Determine primary language
    const primaryLanguage = await this.detectPrimaryLanguage(allLanguages, projectPath);

    return {
      languages: allLanguages,
      primaryLanguage,
      buildFileLanguages,
      extensionLanguages
    };
  }

  /**
   * Validate that detected languages are supported
   */
  validateLanguages(languages: Language[]): {
    supported: Language[];
    unsupported: Language[];
    warnings: string[];
  } {
    const supportedLanguages: Language[] = ['typescript', 'javascript', 'java', 'python'];
    const supported: Language[] = [];
    const unsupported: Language[] = [];
    const warnings: string[] = [];

    for (const lang of languages) {
      if (supportedLanguages.includes(lang)) {
        supported.push(lang);
      } else {
        unsupported.push(lang);
        warnings.push(`⚠️ ${lang} is detected but not yet fully supported for parsing`);
      }
    }

    if (supported.length === 0 && unsupported.length > 0) {
      warnings.push('❌ No supported languages detected in project');
    }

    return { supported, unsupported, warnings };
  }

  /**
   * Get recommended scan configuration based on detected languages
   */
  async getRecommendedScanConfig(projectPath: string): Promise<{
    languages: Language[];
    primaryLanguage?: Language;
    buildSystems: string[];
    frameworks: string[];
    suggestions: string[];
    includeTests: boolean;
    excludePaths: string[];
  }> {
    const detection = await this.detectLanguages(projectPath);
    const validation = this.validateLanguages(detection.languages);
    const buildFileResult = await this.buildFileDetector.detect(projectPath);

    const suggestions: string[] = [];
    const buildSystems: string[] = [];
    const frameworks: string[] = [];
    const excludePaths = ['node_modules', 'dist', 'build', '.git', 'target', 'coverage'];

    // Extract build systems and frameworks
    for (const metadata of buildFileResult.projectMetadata) {
      if (metadata.buildSystem && !buildSystems.includes(metadata.buildSystem)) {
        buildSystems.push(metadata.buildSystem);
      }
      if (metadata.framework && !frameworks.includes(metadata.framework)) {
        frameworks.push(metadata.framework);
      }
    }

    // Add language-specific exclude paths
    if (detection.languages.includes('java')) {
      excludePaths.push('target/**', '*.class');
    }
    if (detection.languages.includes('python')) {
      excludePaths.push('__pycache__/**', '*.pyc', 'venv/**', '.venv/**');
    }
    if (detection.languages.includes('csharp')) {
      excludePaths.push('bin/**', 'obj/**');
    }

    // Generate suggestions
    suggestions.push(...validation.warnings);
    suggestions.push(...buildFileResult.suggestions);

    if (buildFileResult.isMonoRepo) {
      suggestions.push('🏗️ Mono-repository structure detected - consider scanning sub-projects separately');
    }

    if (frameworks.length > 0) {
      suggestions.push(`🚀 Frameworks detected: ${frameworks.join(', ')}`);
    }

    return {
      languages: validation.supported,
      primaryLanguage: detection.primaryLanguage,
      buildSystems,
      frameworks,
      suggestions,
      includeTests: true,
      excludePaths
    };
  }
}


================================================
FILE: src/scanner/git/git-auth-manager.ts
================================================
import * as fs from 'fs/promises';
import * as path from 'path';
import * as os from 'os';
import { GitAuthConfig, ParsedGitUrl, GitError } from './types.js';

export class GitAuthManager {
  private authConfig: GitAuthConfig;

  constructor(initialConfig: GitAuthConfig = {}) {
    this.authConfig = { ...initialConfig };
  }

  async loadAuthFromEnvironment(): Promise<void> {
    // Load from environment variables
    const envAuth: GitAuthConfig = {
      github: {
        token: process.env.GITHUB_TOKEN || process.env.GH_TOKEN
      },
      gitlab: {
        token: process.env.GITLAB_TOKEN || process.env.GL_TOKEN,
        host: process.env.GITLAB_HOST
      },
      bitbucket: {
        username: process.env.BITBUCKET_USERNAME,
        appPassword: process.env.BITBUCKET_APP_PASSWORD
      }
    };

    this.updateAuthConfig(envAuth);
  }

  async loadSSHConfig(): Promise<void> {
    try {
      const sshDir = path.join(os.homedir(), '.ssh');
      const privateKeyPath = path.join(sshDir, 'id_rsa');
      
      if (await this.fileExists(privateKeyPath)) {
        this.authConfig.ssh = {
          privateKey: privateKeyPath
        };
      }
    } catch (error) {
      // SSH config is optional, don't throw
      console.debug('SSH config not available:', error);
    }
  }

  getAuthForRepository(parsedUrl: ParsedGitUrl): {
    cloneUrl: string;
    envVars?: Record<string, string>;
  } {
    if (parsedUrl.protocol === 'ssh') {
      return {
        cloneUrl: `git@${parsedUrl.host}:${parsedUrl.owner}/${parsedUrl.repo}.git`
      };
    }

    // Handle token-based authentication
    const providerConfig = this.getProviderConfig(parsedUrl.provider);
    
    if (providerConfig && 'token' in providerConfig && providerConfig.token) {
      return {
        cloneUrl: this.buildAuthenticatedUrl(parsedUrl, providerConfig.token),
        envVars: this.getEnvironmentVariables(parsedUrl.provider, providerConfig)
      };
    }

    // Return public URL
    return {
      cloneUrl: `https://${parsedUrl.host}/${parsedUrl.owner}/${parsedUrl.repo}.git`
    };
  }

  validateAuthentication(parsedUrl: ParsedGitUrl): {
    isValid: boolean;
    method: 'ssh' | 'token' | 'public' | 'none';
    warnings?: string[];
  } {
    const warnings: string[] = [];

    if (parsedUrl.protocol === 'ssh') {
      const hasSSHKey = !!this.authConfig.ssh?.privateKey;
      return {
        isValid: hasSSHKey,
        method: 'ssh',
        warnings: hasSSHKey ? [] : ['SSH private key not found']
      };
    }

    const providerConfig = this.getProviderConfig(parsedUrl.provider);
    
    if (providerConfig && 'token' in providerConfig && providerConfig.token) {
      const isTokenValid = this.validateToken(providerConfig.token);
      return {
        isValid: isTokenValid,
        method: 'token',
        warnings: isTokenValid ? [] : ['Token appears to be invalid format']
      };
    }

    return {
      isValid: true,
      method: 'public',
      warnings: ['Using public access - private repositories will fail']
    };
  }

  updateAuthConfig(newConfig: GitAuthConfig): void {
    this.authConfig = this.mergeAuthConfigs(this.authConfig, newConfig);
  }

  getAuthConfig(): GitAuthConfig {
    return JSON.parse(JSON.stringify(this.authConfig)); // Deep clone
  }

  clearAuthConfig(): void {
    this.authConfig = {};
  }

  // Security: Clear sensitive data from memory
  dispose(): void {
    this.clearAuthConfig();
  }

  private getProviderConfig(provider: ParsedGitUrl['provider']) {
    switch (provider) {
      case 'github':
        return this.authConfig.github;
      case 'gitlab':
        return this.authConfig.gitlab;
      case 'bitbucket':
        return this.authConfig.bitbucket;
      default:
        return null;
    }
  }

  private buildAuthenticatedUrl(parsedUrl: ParsedGitUrl, token: string): string {
    switch (parsedUrl.provider) {
      case 'github':
        return `https://${token}@${parsedUrl.host}/${parsedUrl.owner}/${parsedUrl.repo}.git`;
      case 'gitlab':
        return `https://oauth2:${token}@${parsedUrl.host}/${parsedUrl.owner}/${parsedUrl.repo}.git`;
      case 'bitbucket':
        const config = this.authConfig.bitbucket;
        if (config?.username && config.appPassword) {
          return `https://${config.username}:${config.appPassword}@${parsedUrl.host}/${parsedUrl.owner}/${parsedUrl.repo}.git`;
        }
        return `https://${parsedUrl.host}/${parsedUrl.owner}/${parsedUrl.repo}.git`;
      default:
        return `https://${token}@${parsedUrl.host}/${parsedUrl.owner}/${parsedUrl.repo}.git`;
    }
  }

  private getEnvironmentVariables(provider: ParsedGitUrl['provider'], config: any): Record<string, string> {
    const envVars: Record<string, string> = {};

    // Add provider-specific environment variables that might be needed
    if (provider === 'gitlab' && config.host) {
      envVars['GITLAB_HOST'] = config.host;
    }

    return envVars;
  }

  private validateToken(token: string): boolean {
    if (!token || typeof token !== 'string') {
      return false;
    }

    // Basic token format validation
    if (token.startsWith('ghp_') && token.length >= 36) return true; // GitHub
    if (token.startsWith('glpat-') && token.length >= 20) return true; // GitLab
    if (token.length >= 10) return true; // Generic token

    return false;
  }

  private mergeAuthConfigs(base: GitAuthConfig, override: GitAuthConfig): GitAuthConfig {
    return {
      github: { ...base.github, ...override.github },
      gitlab: { ...base.gitlab, ...override.gitlab },
      bitbucket: { ...base.bitbucket, ...override.bitbucket },
      ssh: { ...base.ssh, ...override.ssh }
    };
  }

  private async fileExists(filePath: string): Promise<boolean> {
    try {
      await fs.access(filePath);
      return true;
    } catch {
      return false;
    }
  }
}


================================================
FILE: src/scanner/git/git-cache-manager.ts
================================================
import * as fs from 'fs/promises';
import * as path from 'path';
import * as os from 'os';
import * as crypto from 'crypto';
import { ParsedGitUrl } from './types.js';

export interface CacheEntry {
  url: string;
  branch: string;
  lastUpdated: Date;
  lastCommit?: string;
  localPath: string;
}

export interface CacheOptions {
  maxAge?: number; // in milliseconds
  maxSize?: number; // in bytes
  cacheDir?: string;
}

export class GitCacheManager {
  private cacheDir: string;
  private options: Required<CacheOptions>;
  private cacheIndex: Map<string, CacheEntry>;

  constructor(options: CacheOptions = {}) {
    this.options = {
      maxAge: options.maxAge || 24 * 60 * 60 * 1000, // 24 hours
      maxSize: options.maxSize || 5 * 1024 * 1024 * 1024, // 5GB
      cacheDir: options.cacheDir || path.join(os.homedir(), '.coderag', 'git-cache')
    };
    
    this.cacheDir = this.options.cacheDir;
    this.cacheIndex = new Map();
  }

  async initialize(): Promise<void> {
    // Ensure cache directory exists
    await fs.mkdir(this.cacheDir, { recursive: true });
    
    // Load existing cache index
    await this.loadCacheIndex();
    
    // Clean up expired entries
    await this.cleanupExpiredEntries();
  }

  async getCachedRepository(parsedUrl: ParsedGitUrl, branch: string = 'main'): Promise<string | null> {
    const cacheKey = this.generateCacheKey(parsedUrl, branch);
    const entry = this.cacheIndex.get(cacheKey);
    
    if (!entry) {
      return null;
    }
    
    // Check if cache entry is still valid
    const isExpired = Date.now() - entry.lastUpdated.getTime() > this.options.maxAge;
    if (isExpired) {
      await this.removeCacheEntry(cacheKey);
      return null;
    }
    
    // Check if cached directory still exists
    try {
      await fs.access(entry.localPath);
      return entry.localPath;
    } catch {
      // Directory doesn't exist, remove from cache
      await this.removeCacheEntry(cacheKey);
      return null;
    }
  }

  async addToCache(parsedUrl: ParsedGitUrl, branch: string, sourcePath: string): Promise<string> {
    const cacheKey = this.generateCacheKey(parsedUrl, branch);
    const targetPath = path.join(this.cacheDir, cacheKey);
    
    // Copy repository to cache
    await this.copyDirectory(sourcePath, targetPath);
    
    // Get last commit hash for cache validation
    const lastCommit = await this.getLastCommitHash(targetPath);
    
    // Create cache entry
    const entry: CacheEntry = {
      url: parsedUrl.originalUrl,
      branch,
      lastUpdated: new Date(),
      lastCommit,
      localPath: targetPath
    };
    
    this.cacheIndex.set(cacheKey, entry);
    await this.saveCacheIndex();
    
    return targetPath;
  }

  async updateCacheEntry(parsedUrl: ParsedGitUrl, branch: string, sourcePath: string): Promise<string> {
    // Remove existing entry and add new one
    const cacheKey = this.generateCacheKey(parsedUrl, branch);
    await this.removeCacheEntry(cacheKey);
    return this.addToCache(parsedUrl, branch, sourcePath);
  }

  async removeCacheEntry(cacheKey: string): Promise<void> {
    const entry = this.cacheIndex.get(cacheKey);
    if (entry) {
      try {
        await fs.rm(entry.localPath, { recursive: true, force: true });
      } catch (error) {
        console.warn(`Failed to remove cached directory: ${entry.localPath}`, error);
      }
      
      this.cacheIndex.delete(cacheKey);
      await this.saveCacheIndex();
    }
  }

  async clearCache(): Promise<void> {
    try {
      await fs.rm(this.cacheDir, { recursive: true, force: true });
      await fs.mkdir(this.cacheDir, { recursive: true });
      this.cacheIndex.clear();
      await this.saveCacheIndex();
    } catch (error) {
      console.warn('Failed to clear git cache:', error);
    }
  }

  async getCacheStats(): Promise<{
    entries: number;
    totalSize: number;
    oldestEntry?: Date;
    newestEntry?: Date;
  }> {
    let totalSize = 0;
    let oldestEntry: Date | undefined;
    let newestEntry: Date | undefined;
    
    for (const entry of this.cacheIndex.values()) {
      try {
        const stats = await fs.stat(entry.localPath);
        totalSize += stats.size;
        
        if (!oldestEntry || entry.lastUpdated < oldestEntry) {
          oldestEntry = entry.lastUpdated;
        }
        
        if (!newestEntry || entry.lastUpdated > newestEntry) {
          newestEntry = entry.lastUpdated;
        }
      } catch {
        // Directory might not exist, will be cleaned up later
      }
    }
    
    return {
      entries: this.cacheIndex.size,
      totalSize,
      oldestEntry,
      newestEntry
    };
  }

  private generateCacheKey(parsedUrl: ParsedGitUrl, branch: string): string {
    const key = `${parsedUrl.host}/${parsedUrl.owner}/${parsedUrl.repo}/${branch}`;
    return crypto.createHash('sha256').update(key).digest('hex').substring(0, 16);
  }

  private async loadCacheIndex(): Promise<void> {
    const indexPath = path.join(this.cacheDir, 'index.json');
    
    try {
      const data = await fs.readFile(indexPath, 'utf-8');
      const entries = JSON.parse(data);
      
      this.cacheIndex.clear();
      for (const [key, value] of Object.entries(entries)) {
        this.cacheIndex.set(key, {
          ...value as any,
          lastUpdated: new Date((value as any).lastUpdated)
        });
      }
    } catch {
      // Index file doesn't exist or is invalid, start fresh
      this.cacheIndex.clear();
    }
  }

  private async saveCacheIndex(): Promise<void> {
    const indexPath = path.join(this.cacheDir, 'index.json');
    const entries = Object.fromEntries(this.cacheIndex);
    
    try {
      await fs.writeFile(indexPath, JSON.stringify(entries, null, 2));
    } catch (error) {
      console.warn('Failed to save cache index:', error);
    }
  }

  private async cleanupExpiredEntries(): Promise<void> {
    const now = Date.now();
    const expiredKeys: string[] = [];
    
    for (const [key, entry] of this.cacheIndex.entries()) {
      if (now - entry.lastUpdated.getTime() > this.options.maxAge) {
        expiredKeys.push(key);
      }
    }
    
    for (const key of expiredKeys) {
      await this.removeCacheEntry(key);
    }
  }

  private async copyDirectory(source: string, target: string): Promise<void> {
    await fs.mkdir(target, { recursive: true });
    
    const entries = await fs.readdir(source, { withFileTypes: true });
    
    for (const entry of entries) {
      const sourcePath = path.join(source, entry.name);
      const targetPath = path.join(target, entry.name);
      
      if (entry.isDirectory()) {
        await this.copyDirectory(sourcePath, targetPath);
      } else {
        await fs.copyFile(sourcePath, targetPath);
      }
    }
  }

  private async getLastCommitHash(repoPath: string): Promise<string | undefined> {
    try {
      const gitDir = path.join(repoPath, '.git');
      const headPath = path.join(gitDir, 'HEAD');
      
      const headContent = await fs.readFile(headPath, 'utf-8');
      const match = headContent.trim().match(/^ref: (.+)$/);
      
      if (match) {
        const refPath = path.join(gitDir, match[1]);
        const commit = await fs.readFile(refPath, 'utf-8');
        return commit.trim();
      }
      
      // HEAD contains commit hash directly
      return headContent.trim();
    } catch {
      return undefined;
    }
  }
}


================================================
FILE: src/scanner/git/git-repository-manager.ts
================================================
import { simpleGit, SimpleGit, GitError as SimpleGitError } from 'simple-git';
import tmp from 'tmp';
import * as fs from 'fs/promises';
import * as path from 'path';
import { ParsedGitUrl, RepositoryInfo, CloneOptions, GitError, GitAuthConfig, CloneProgress } from './types.js';
import { GitUrlParser } from './git-url-parser.js';
import { GitAuthManager } from './git-auth-manager.js';
import { GitCacheManager } from './git-cache-manager.js';

export class GitRepositoryManager {
  private git: SimpleGit;
  private authManager: GitAuthManager;
  private cacheManager: GitCacheManager;

  constructor(authConfig: GitAuthConfig = {}) {
    this.git = simpleGit();
    this.authManager = new GitAuthManager(authConfig);
    this.cacheManager = new GitCacheManager();
  }

  async cloneRepository(url: string, options: CloneOptions = {}): Promise<string> {
    const parsedUrl = GitUrlParser.parse(url);
    const branch = options.branch || 'main';
    
    // Initialize cache manager if caching is enabled
    if (options.useCache) {
      await this.cacheManager.initialize();
    }
    
    // Progress reporting helper
    const reportProgress = (progress: CloneProgress) => {
      if (options.progressCallback) {
        options.progressCallback(progress);
      }
    };
    
    // Check cache first if enabled
    if (options.useCache && !options.cacheOptions?.forceRefresh) {
      reportProgress({
        stage: 'validating',
        message: 'Checking cache for existing repository...'
      });
      
      const cachedPath = await this.cacheManager.getCachedRepository(parsedUrl, branch);
      if (cachedPath) {
        console.log(`📦 Using cached repository: ${cachedPath}`);
        reportProgress({
          stage: 'completed',
          message: 'Repository loaded from cache',
          percentage: 100
        });
        return cachedPath;
      }
    }
    
    reportProgress({
      stage: 'validating',
      message: 'Loading authentication configuration...'
    });
    
    // Load authentication configuration
    await this.authManager.loadAuthFromEnvironment();
    await this.authManager.loadSSHConfig();
    
    // Validate authentication
    const authValidation = this.authManager.validateAuthentication(parsedUrl);
    if (authValidation.warnings?.length) {
      authValidation.warnings.forEach(warning => 
        console.warn(`⚠️  Authentication warning: ${warning}`)
      );
    }
    
    reportProgress({
      stage: 'cloning',
      message: 'Creating temporary directory...',
      percentage: 10
    });
    
    // Create temporary directory
    const tempDir = await this.createTempDirectory(options.tempDir);
    
    try {
      // Get authentication details
      const authDetails = this.authManager.getAuthForRepository(parsedUrl);
      
      // Use auth override if provided, otherwise use configured auth
      const cloneUrl = options.auth?.token 
        ? this.buildAuthenticatedUrlWithToken(parsedUrl, options.auth.token)
        : authDetails.cloneUrl;
      
      // Prepare clone options
      const cloneArgs = this.buildCloneArgs(options);
      
      console.log(`🔐 Authentication method: ${authValidation.method}`);
      console.log(`📥 Cloning repository: ${parsedUrl.owner}/${parsedUrl.repo}`);
      console.log(`📁 Target directory: ${tempDir}`);
      
      reportProgress({
        stage: 'cloning',
        message: `Cloning ${parsedUrl.owner}/${parsedUrl.repo}...`,
        percentage: 30
      });
      
      // Set environment variables if needed
      const originalEnv = process.env;
      if (authDetails.envVars) {
        Object.assign(process.env, authDetails.envVars);
      }
      
      try {
        // Clone the repository with progress tracking
        const git = simpleGit({
          progress: ({ stage, progress }) => {
            const percentage = 30 + (progress * 0.6); // 30-90% for cloning
            reportProgress({
              stage: 'cloning',
              message: `${stage}: ${Math.round(percentage)}%`,
              percentage
            });
          }
        });
        
        await git.clone(cloneUrl, tempDir, cloneArgs);
        console.log(`✅ Successfully cloned repository to: ${tempDir}`);
        
        reportProgress({
          stage: 'cloning',
          message: 'Repository cloned successfully',
          percentage: 90
        });
      } finally {
        // Restore original environment
        if (authDetails.envVars) {
          process.env = originalEnv;
        }
      }
      
      // Add to cache if caching is enabled
      if (options.useCache) {
        reportProgress({
          stage: 'caching',
          message: 'Adding repository to cache...',
          percentage: 95
        });
        
        try {
          const cachedPath = await this.cacheManager.addToCache(parsedUrl, branch, tempDir);
          console.log(`📦 Repository cached at: ${cachedPath}`);
          
          // Return cached path instead of temp path
          reportProgress({
            stage: 'completed',
            message: 'Repository cached successfully',
            percentage: 100
          });
          
          return cachedPath;
        } catch (cacheError) {
          console.warn('Failed to cache repository, continuing with temporary directory:', cacheError);
        }
      }
      
      reportProgress({
        stage: 'completed',
        message: 'Repository ready for scanning',
        percentage: 100
      });
      
      return tempDir;
    } catch (error) {
      // Clean up on failure
      await this.cleanup(tempDir);
      
      if (error instanceof SimpleGitError) {
        // Provide more helpful error messages
        let errorMessage = `Failed to clone repository: ${error.message}`;
        if (error.message.includes('Authentication failed')) {
          errorMessage += '\n  💡 Check your authentication tokens or SSH keys';
        } else if (error.message.includes('not found')) {
          errorMessage += '\n  💡 Verify the repository URL and access permissions';
        }
        
        throw new GitError(errorMessage, 'CLONE_FAILED', url);
      }
      
      throw new GitError(
        `Unexpected error cloning repository: ${error instanceof Error ? error.message : 'Unknown error'}`,
        'CLONE_FAILED',
        url
      );
    }
  }

  async validateRepository(url: string): Promise<RepositoryInfo> {
    const parsedUrl = GitUrlParser.parse(url);
    
    try {
      // Load authentication configuration
      await this.authManager.loadAuthFromEnvironment();
      await this.authManager.loadSSHConfig();
      
      // Get authentication details
      const authDetails = this.authManager.getAuthForRepository(parsedUrl);
      
      // Use git ls-remote to check if repository exists and is accessible
      const result = await this.git.listRemote([authDetails.cloneUrl]);
      
      if (!result) {
        throw new GitError(
          'Repository not found or not accessible',
          'REPOSITORY_NOT_FOUND',
          url
        );
      }

      return {
        name: parsedUrl.repo,
        fullName: `${parsedUrl.owner}/${parsedUrl.repo}`,
        url: parsedUrl.originalUrl,
        branch: parsedUrl.branch || 'main'
      };
    } catch (error) {
      if (error instanceof GitError) {
        throw error;
      }
      
      if (error instanceof SimpleGitError) {
        throw new GitError(
          `Failed to validate repository: ${error.message}`,
          'VALIDATION_FAILED',
          url
        );
      }
      
      throw new GitError(
        `Unexpected error validating repository: ${error instanceof Error ? error.message : 'Unknown error'}`,
        'VALIDATION_FAILED',
        url
      );
    }
  }

  async cleanup(tempPath: string): Promise<void> {
    try {
      console.log(`Cleaning up temporary directory: ${tempPath}`);
      await fs.rm(tempPath, { recursive: true, force: true });
      console.log(`Successfully cleaned up: ${tempPath}`);
    } catch (error) {
      console.warn(`Failed to clean up temporary directory ${tempPath}:`, error);
      // Don't throw on cleanup failure - it's not critical
    }
  }

  parseGitUrl(url: string): ParsedGitUrl {
    return GitUrlParser.parse(url);
  }

  isGitUrl(url: string): boolean {
    return GitUrlParser.isGitUrl(url);
  }

  private async createTempDirectory(preferredPath?: string): Promise<string> {
    if (preferredPath) {
      await fs.mkdir(preferredPath, { recursive: true });
      return preferredPath;
    }

    return new Promise((resolve, reject) => {
      tmp.dir({ 
        prefix: 'coderag-git-',
        keep: false, // Will be cleaned up manually
        unsafeCleanup: true 
      }, (err, path) => {
        if (err) {
          reject(new GitError('Failed to create temporary directory', 'TEMP_DIR_FAILED'));
        } else {
          resolve(path);
        }
      });
    });
  }


  private buildCloneArgs(options: CloneOptions): string[] {
    const args: string[] = [];

    if (options.branch) {
      args.push('--branch', options.branch);
    }

    if (options.depth) {
      args.push('--depth', options.depth.toString());
    }

    if (options.singleBranch !== false) {
      args.push('--single-branch');
    }

    return args;
  }

  updateAuthConfig(newConfig: GitAuthConfig): void {
    this.authManager.updateAuthConfig(newConfig);
  }

  getAuthConfig(): GitAuthConfig {
    return this.authManager.getAuthConfig();
  }

  private buildAuthenticatedUrlWithToken(parsedUrl: ParsedGitUrl, token: string): string {
    return GitUrlParser.buildCloneUrl(parsedUrl, token);
  }

  async getCacheStats() {
    await this.cacheManager.initialize();
    return this.cacheManager.getCacheStats();
  }

  async clearCache(): Promise<void> {
    await this.cacheManager.clearCache();
  }

  async getCacheManager(): Promise<GitCacheManager> {
    await this.cacheManager.initialize();
    return this.cacheManager;
  }
}


================================================
FILE: src/scanner/git/git-url-parser.ts
================================================
import { ParsedGitUrl, GitError } from './types.js';

export class GitUrlParser {
  private static readonly GIT_URL_PATTERNS = [
    // HTTPS patterns
    /^https?:\/\/([^\/]+)\/([^\/]+)\/([^\/]+?)(?:\.git)?(?:\/.*)?$/,
    // SSH patterns
    /^git@([^:]+):([^\/]+)\/([^\/]+?)(?:\.git)?$/,
    // Git protocol patterns
    /^git:\/\/([^\/]+)\/([^\/]+)\/([^\/]+?)(?:\.git)?(?:\/.*)?$/
  ];

  private static readonly KNOWN_PROVIDERS = {
    'github.com': 'github',
    'gitlab.com': 'gitlab',
    'bitbucket.org': 'bitbucket'
  } as const;

  static parse(url: string): ParsedGitUrl {
    if (!url || typeof url !== 'string') {
      throw new GitError('Invalid URL: URL must be a non-empty string', 'INVALID_URL', url);
    }

    const trimmedUrl = url.trim();
    
    // Try HTTPS pattern
    const httpsMatch = trimmedUrl.match(/^https?:\/\/([^\/]+)\/([^\/]+)\/([^\/]+?)(?:\.git)?(?:\/.*)?$/);
    if (httpsMatch) {
      const [, host, owner, repo] = httpsMatch;
      return {
        protocol: 'https',
        provider: this.getProvider(host),
        host,
        owner,
        repo: this.cleanRepoName(repo),
        originalUrl: trimmedUrl
      };
    }

    // Try SSH pattern
    const sshMatch = trimmedUrl.match(/^git@([^:]+):([^\/]+)\/([^\/]+?)(?:\.git)?$/);
    if (sshMatch) {
      const [, host, owner, repo] = sshMatch;
      return {
        protocol: 'ssh',
        provider: this.getProvider(host),
        host,
        owner,
        repo: this.cleanRepoName(repo),
        originalUrl: trimmedUrl
      };
    }

    // Try git protocol pattern
    const gitMatch = trimmedUrl.match(/^git:\/\/([^\/]+)\/([^\/]+)\/([^\/]+?)(?:\.git)?(?:\/.*)?$/);
    if (gitMatch) {
      const [, host, owner, repo] = gitMatch;
      return {
        protocol: 'git',
        provider: this.getProvider(host),
        host,
        owner,
        repo: this.cleanRepoName(repo),
        originalUrl: trimmedUrl
      };
    }

    throw new GitError(
      `Unsupported git URL format: ${trimmedUrl}. Supported formats: https://github.com/owner/repo, git@github.com:owner/repo, git://github.com/owner/repo`,
      'UNSUPPORTED_URL_FORMAT',
      trimmedUrl
    );
  }

  static isGitUrl(url: string): boolean {
    try {
      this.parse(url);
      return true;
    } catch {
      return false;
    }
  }

  static validateUrl(url: string): { valid: boolean; error?: string } {
    try {
      this.parse(url);
      return { valid: true };
    } catch (error) {
      return { 
        valid: false, 
        error: error instanceof GitError ? error.message : 'Unknown error parsing URL' 
      };
    }
  }

  static normalizeUrl(parsedUrl: ParsedGitUrl): string {
    // Convert to HTTPS format for consistency
    return `https://${parsedUrl.host}/${parsedUrl.owner}/${parsedUrl.repo}.git`;
  }

  static buildCloneUrl(parsedUrl: ParsedGitUrl, useToken?: string): string {
    if (parsedUrl.protocol === 'ssh') {
      return `git@${parsedUrl.host}:${parsedUrl.owner}/${parsedUrl.repo}.git`;
    }

    if (useToken && parsedUrl.provider === 'github') {
      return `https://${useToken}@${parsedUrl.host}/${parsedUrl.owner}/${parsedUrl.repo}.git`;
    }

    if (useToken && parsedUrl.provider === 'gitlab') {
      return `https://oauth2:${useToken}@${parsedUrl.host}/${parsedUrl.owner}/${parsedUrl.repo}.git`;
    }

    return `https://${parsedUrl.host}/${parsedUrl.owner}/${parsedUrl.repo}.git`;
  }

  private static getProvider(host: string): ParsedGitUrl['provider'] {
    const normalizedHost = host.toLowerCase();
    return (this.KNOWN_PROVIDERS[normalizedHost as keyof typeof this.KNOWN_PROVIDERS]) || 'custom';
  }

  private static cleanRepoName(repo: string): string {
    return repo.replace(/\.git$/, '');
  }
}


================================================
FILE: src/scanner/git/index.ts
================================================
export { GitRepositoryManager } from './git-repository-manager.js';
export { GitUrlParser } from './git-url-parser.js';
export { GitAuthManager } from './git-auth-manager.js';
export { GitCacheManager } from './git-cache-manager.js';
export type { 
  ParsedGitUrl, 
  RepositoryInfo, 
  CloneOptions, 
  GitAuthConfig,
  CloneProgress
} from './types.js';
export { GitError } from './types.js';


================================================
FILE: src/scanner/git/types.ts
================================================
export interface ParsedGitUrl {
  protocol: 'https' | 'ssh' | 'git';
  provider: 'github' | 'gitlab' | 'bitbucket' | 'custom';
  host: string;
  owner: string;
  repo: string;
  branch?: string;
  originalUrl: string;
}

export interface RepositoryInfo {
  name: string;
  fullName: string;
  url: string;
  branch: string;
  isPrivate?: boolean;
  size?: number;
}

export interface CloneOptions {
  branch?: string;
  depth?: number;
  singleBranch?: boolean;
  tempDir?: string;
  useCache?: boolean;
  cacheOptions?: {
    maxAge?: number;
    forceRefresh?: boolean;
  };
  progressCallback?: (progress: CloneProgress) => void;
  auth?: {
    token?: string;
    username?: string;
    password?: string;
  };
}

export interface CloneProgress {
  stage: 'validating' | 'cloning' | 'caching' | 'completed';
  message: string;
  percentage?: number;
}

export interface GitAuthConfig {
  github?: {
    token?: string;
  };
  gitlab?: {
    token?: string;
    host?: string;
  };
  bitbucket?: {
    username?: string;
    appPassword?: string;
  };
  ssh?: {
    privateKey?: string;
  };
}

export class GitError extends Error {
  constructor(message: string, public readonly code?: string, public readonly url?: string) {
    super(message);
    this.name = 'GitError';
  }
}


================================================
FILE: src/scanner/parsers/java-parser.ts
================================================
import * as path from 'path';
import { BaseLanguageParser } from './base/BaseLanguageParser.js';
import { EntityFactory } from './base/EntityFactory.js';
import { RelationshipBuilder } from './base/RelationshipBuilder.js';
import { JavaContentExtractor } from './extractors/java/JavaContentExtractor.js';
import { JavaClassParser } from './entity-parsers/java/JavaClassParser.js';
import { JavaMethodParser } from './entity-parsers/java/JavaMethodParser.js';
import { JavaFieldParser } from './entity-parsers/java/JavaFieldParser.js';
import { JavaAnnotationExtractor } from './extractors/java/JavaAnnotationExtractor.js';
import { JavaMethodCallExtractor } from './extractors/java/JavaMethodCallExtractor.js';
import { ParsedEntity, ParsedRelationship, ParseError } from '../types.js';

export class JavaParser extends BaseLanguageParser {
  private contentExtractor = new JavaContentExtractor();
  private classParser = new JavaClassParser();
  private methodParser = new JavaMethodParser();
  private fieldParser = new JavaFieldParser();
  private annotationExtractor = new JavaAnnotationExtractor();
  private methodCallExtractor = new JavaMethodCallExtractor();
  private createdPackages: Map<string, Set<string>> = new Map();

  canParse(filePath: string): boolean {
    const ext = path.extname(filePath).toLowerCase();
    return ext === '.java';
  }

  async parseFile(filePath: string, content: string, projectId: string): Promise<{
    entities: ParsedEntity[];
    relationships: ParsedRelationship[];
    errors: ParseError[];
  }> {
    this.setCurrentProject(projectId);
    
    // Initialize created packages set for this project if not exists
    if (!this.createdPackages.has(projectId)) {
      this.createdPackages.set(projectId, new Set());
    }

    const entities: ParsedEntity[] = [];
    const relationships: ParsedRelationship[] = [];
    const errors: ParseError[] = [];

    try {
      // Check if file is effectively empty (only whitespace/comments)
      const trimmedContent = content.trim();
      if (trimmedContent === '') {
        // Empty file - return empty arrays
        return { entities, relationships, errors };
      }

      // Extract basic content structure
      const extractionResult = this.contentExtractor.extractContent(content, filePath);
      const packageName = extractionResult.packageName || this.getPackageFromPath(filePath);
      const packageId = packageName;

      // Create package entity if not already created
      const createdPackagesForProject = this.createdPackages.get(projectId)!;
      if (!createdPackagesForProject.has(packageId)) {
        const packageEntity = EntityFactory.createPackage(
          packageId,
          packageName,
          packageName,
          filePath,
          `Package: ${packageName}`
        );
        this.addEntity(entities, packageEntity);
        createdPackagesForProject.add(packageId);
      }

      // Create module entity
      const moduleId = `${packageName}.${path.basename(filePath, '.java')}`;
      const moduleEntity = EntityFactory.createModule(
        moduleId,
        path.basename(filePath, '.java'),
        moduleId,
        filePath,
        `Java file: ${path.basename(filePath)}`
      );
      this.addEntity(entities, moduleEntity);
      this.addRelationship(relationships, RelationshipBuilder.createBelongsTo(moduleId, packageId, filePath));

      // Parse different entity types using specialized parsers
      this.classParser.parseClasses(
        content, filePath, packageName, entities, relationships,
        (entity) => this.addEntity(entities, entity),
        (rel) => this.addRelationship(relationships, rel)
      );

      this.methodParser.parseMethods(
        content, filePath, packageName, entities, relationships,
        (entity) => this.addEntity(entities, entity),
        (rel) => this.addRelationship(relationships, rel)
      );

      this.fieldParser.parseFields(
        content, filePath, packageName, entities, relationships,
        (entity) => this.addEntity(entities, entity),
        (rel) => this.addRelationship(relationships, rel)
      );

      // Parse interfaces and enums using content extractor
      this.parseInterfaces(content, filePath, packageName, entities, relationships);
      this.parseEnums(content, filePath, packageName, entities, relationships);

    } catch (error) {
      this.addError(errors, {
        message: `Failed to parse Java file: ${error instanceof Error ? error.message : 'Unknown error'}`,
        line: 1,
        file_path: filePath
      });
    }

    return { entities, relationships, errors };
  }

  private parseInterfaces(
    content: string,
    filePath: string,
    packageName: string,
    entities: ParsedEntity[],
    relationships: ParsedRelationship[]
  ): void {
    const extractionResult = this.contentExtractor.extractContent(content, filePath);
    
    for (const parsedInterface of extractionResult.interfaces) {
      const interfaceId = `${packageName}.${parsedInterface.name}`;
      const qualifiedName = `${packageName}.${parsedInterface.name}`;
      
      const interfaceEntity = EntityFactory.createInterface(
        interfaceId,
        parsedInterface.name,
        qualifiedName,
        filePath,
        parsedInterface.startLine,
        parsedInterface.endLine,
        parsedInterface.modifiers
      );

      this.addEntity(entities, interfaceEntity);
      this.addRelationship(relationships, RelationshipBuilder.createBelongsTo(interfaceId, packageName, filePath));

      // Handle interface inheritance
      if (parsedInterface.extends && parsedInterface.extends.length > 0) {
        for (const parentInterface of parsedInterface.extends) {
          const parentId = this.resolveType(parentInterface.trim(), packageName, extractionResult.imports);
          this.addRelationship(relationships, RelationshipBuilder.createExtends(interfaceId, parentId, filePath));
        }
      }
    }
  }

  private parseEnums(
    content: string,
    filePath: string,
    packageName: string,
    entities: ParsedEntity[],
    relationships: ParsedRelationship[]
  ): void {
    const extractionResult = this.contentExtractor.extractContent(content, filePath);
    
    for (const parsedEnum of extractionResult.enums) {
      const enumId = `${packageName}.${parsedEnum.name}`;
      const qualifiedName = `${packageName}.${parsedEnum.name}`;
      
      const enumEntity = EntityFactory.createEnum(
        enumId,
        parsedEnum.name,
        qualifiedName,
        filePath,
        parsedEnum.startLine,
        parsedEnum.endLine,
        parsedEnum.modifiers
      );

      this.addEntity(entities, enumEntity);
      this.addRelationship(relationships, RelationshipBuilder.createBelongsTo(enumId, packageName, filePath));
    }
  }

  private resolveType(typeName: string, packageName: string, imports: any[]): string {
    // Remove generic type parameters
    const baseType = typeName.split('<')[0].trim();
    
    // Check if it's a fully qualified name
    if (baseType.includes('.')) {
      return baseType;
    }
    
    // Check imports for the type
    for (const imp of imports) {
      if (imp.items?.includes(baseType) || imp.module.endsWith(`.${baseType}`)) {
        return imp.module.includes('.') ? imp.module : `${packageName}.${baseType}`;
      }
    }
    
    // Default to same package
    return `${packageName}.${baseType}`;
  }

  private getPackageFromPath(filePath: string): string {
    const normalized = path.normalize(filePath);
    const parts = normalized.split(path.sep);
    
    // Find src/main/java or just src directory
    const srcIndex = parts.findIndex(part => part === 'src');
    if (srcIndex !== -1) {
      const startIndex = parts.includes('main') ? srcIndex + 3 : srcIndex + 1;
      const packageParts = parts.slice(startIndex, -1); // Exclude filename
      return packageParts.join('.');
    }
    
    return 'default';
  }
}


================================================
FILE: src/scanner/parsers/python-parser.ts
================================================
import * as path from 'path';
import { BaseLanguageParser } from './base/BaseLanguageParser.js';
import { EntityFactory } from './base/EntityFactory.js';
import { RelationshipBuilder } from './base/RelationshipBuilder.js';
import { PythonContentExtractor } from './extractors/python/PythonContentExtractor.js';
import { PythonClassParser } from './entity-parsers/python/PythonClassParser.js';
import { PythonFunctionParser } from './entity-parsers/python/PythonFunctionParser.js';
import { PythonAnnotationExtractor } from './extractors/python/PythonAnnotationExtractor.js';
import { PythonMethodCallExtractor } from './extractors/python/PythonMethodCallExtractor.js';
import { ParsedEntity, ParsedRelationship, ParseError } from '../types.js';

export class PythonParser extends BaseLanguageParser {
  private contentExtractor = new PythonContentExtractor();
  private classParser = new PythonClassParser();
  private functionParser = new PythonFunctionParser();
  private annotationExtractor = new PythonAnnotationExtractor();
  private methodCallExtractor = new PythonMethodCallExtractor();

  canParse(filePath: string): boolean {
    const ext = path.extname(filePath).toLowerCase();
    return ext === '.py';
  }

  async parseFile(filePath: string, content: string, projectId: string): Promise<{
    entities: ParsedEntity[];
    relationships: ParsedRelationship[];
    errors: ParseError[];
  }> {
    this.setCurrentProject(projectId);

    const entities: ParsedEntity[] = [];
    const relationships: ParsedRelationship[] = [];
    const errors: ParseError[] = [];

    try {
      // Extract basic content structure
      const extractionResult = this.contentExtractor.extractContent(content, filePath);
      const moduleName = extractionResult.moduleName || this.getModuleFromPath(filePath);
      const moduleId = moduleName;

      // Create module entity
      if (moduleName !== '__main__') {
        const moduleEntity = EntityFactory.createModule(
          moduleId,
          moduleName,
          moduleName,
          filePath,
          `Python module: ${moduleName}`
        );
        this.addEntity(entities, moduleEntity);
      }

      // Parse different entity types using specialized parsers
      this.classParser.parseClasses(
        content, filePath, moduleName, entities, relationships,
        (entity) => this.addEntity(entities, entity),
        (rel) => this.addRelationship(relationships, rel)
      );

      this.functionParser.parseFunctions(
        content, filePath, moduleName, entities, relationships,
        (entity) => this.addEntity(entities, entity),
        (rel) => this.addRelationship(relationships, rel)
      );

      // Parse enums and module-level attributes
      this.parseEnums(content, filePath, moduleName, entities, relationships);
      this.parseModuleAttributes(content, filePath, moduleName, entities, relationships);

    } catch (error) {
      this.addError(errors, {
        message: `Failed to parse Python file: ${error instanceof Error ? error.message : 'Unknown error'}`,
        line: 1,
        file_path: filePath
      });
    }

    return { entities, relationships, errors };
  }

  private parseEnums(
    content: string,
    filePath: string,
    moduleName: string,
    entities: ParsedEntity[],
    relationships: ParsedRelationship[]
  ): void {
    const extractionResult = this.contentExtractor.extractContent(content, filePath);
    
    for (const parsedEnum of extractionResult.enums) {
      const enumId = `${moduleName}.${parsedEnum.name}`;
      const qualifiedName = `${moduleName}.${parsedEnum.name}`;
      
      const enumEntity = EntityFactory.createEnum(
        enumId,
        parsedEnum.name,
        qualifiedName,
        filePath,
        parsedEnum.startLine,
        parsedEnum.endLine,
        parsedEnum.modifiers
      );

      this.addEntity(entities, enumEntity);
      this.addRelationship(relationships, RelationshipBuilder.createBelongsTo(enumId, moduleName, filePath));
    }
  }

  private parseModuleAttributes(
    content: string,
    filePath: string,
    moduleName: string,
    entities: ParsedEntity[],
    relationships: ParsedRelationship[]
  ): void {
    const extractionResult = this.contentExtractor.extractContent(content, filePath);
    
    for (const parsedField of extractionResult.fields) {
      const fieldId = `${moduleName}.${parsedField.name}`;
      const qualifiedName = `${moduleName}.${parsedField.name}`;
      
      const fieldEntity = EntityFactory.createField(
        fieldId,
        parsedField.name,
        qualifiedName,
        filePath,
        parsedField.startLine,
        parsedField.endLine,
        parsedField.modifiers
      );

      this.addEntity(entities, fieldEntity);
      this.addRelationship(relationships, RelationshipBuilder.createBelongsTo(fieldId, moduleName, filePath));
    }
  }

  private getModuleFromPath(filePath: string): string {
    const normalized = path.normalize(filePath);
    const parsed = path.parse(normalized);
    
    if (parsed.name === '__init__') {
      // For __init__.py files, use the directory name
      return path.basename(parsed.dir);
    }
    
    return parsed.name;
  }
}


================================================
FILE: src/scanner/parsers/typescript-parser.ts
================================================
import * as path from 'path';
import { BaseLanguageParser } from './base/BaseLanguageParser.js';
import { EntityFactory } from './base/EntityFactory.js';
import { RelationshipBuilder } from './base/RelationshipBuilder.js';
import { TypeScriptContentExtractor } from './extractors/typescript/TypeScriptContentExtractor.js';
import { TypeScriptClassParser } from './entity-parsers/typescript/TypeScriptClassParser.js';
import { TypeScriptAnnotationExtractor } from './extractors/typescript/TypeScriptAnnotationExtractor.js';
import { TypeScriptMethodCallExtractor } from './extractors/typescript/TypeScriptMethodCallExtractor.js';
import { ParsedEntity, ParsedRelationship, ParseError } from '../types.js';

export class TypeScriptParser extends BaseLanguageParser {
  private contentExtractor = new TypeScriptContentExtractor();
  private classParser = new TypeScriptClassParser();
  private annotationExtractor = new TypeScriptAnnotationExtractor();
  private methodCallExtractor = new TypeScriptMethodCallExtractor();

  canParse(filePath: string): boolean {
    const ext = path.extname(filePath).toLowerCase();
    return ext === '.ts' || ext === '.tsx' || ext === '.js' || ext === '.jsx';
  }

  async parseFile(filePath: string, content: string, projectId: string): Promise<{
    entities: ParsedEntity[];
    relationships: ParsedRelationship[];
    errors: ParseError[];
  }> {
    this.setCurrentProject(projectId);

    const entities: ParsedEntity[] = [];
    const relationships: ParsedRelationship[] = [];
    const errors: ParseError[] = [];

    try {
      // Extract basic content structure
      const extractionResult = this.contentExtractor.extractContent(content, filePath);
      const moduleName = extractionResult.moduleName || this.getModuleFromPath(filePath);
      const moduleId = moduleName;

      // Create module entity
      const moduleEntity = EntityFactory.createModule(
        moduleId,
        moduleName,
        moduleName,
        filePath,
        `TypeScript module: ${moduleName}`
      );
      this.addEntity(entities, moduleEntity);

      // Parse different entity types using specialized parsers
      this.classParser.parseClasses(
        content, filePath, moduleName, entities, relationships,
        (entity) => this.addEntity(entities, entity),
        (rel) => this.addRelationship(relationships, rel)
      );

      // Parse other entity types using content extractor
      this.parseInterfaces(content, filePath, moduleName, entities, relationships);
      this.parseEnums(content, filePath, moduleName, entities, relationships);
      this.parseFunctions(content, filePath, moduleName, entities, relationships);
      this.parseFields(content, filePath, moduleName, entities, relationships);

    } catch (error) {
      this.addError(errors, {
        message: `Failed to parse TypeScript file: ${error instanceof Error ? error.message : 'Unknown error'}`,
        line: 1,
        file_path: filePath
      });
    }

    return { entities, relationships, errors };
  }

  private parseInterfaces(
    content: string,
    filePath: string,
    moduleName: string,
    entities: ParsedEntity[],
    relationships: ParsedRelationship[]
  ): void {
    const extractionResult = this.contentExtractor.extractContent(content, filePath);
    
    for (const parsedInterface of extractionResult.interfaces) {
      const interfaceId = `${moduleName}.${parsedInterface.name}`;
      const qualifiedName = `${moduleName}.${parsedInterface.name}`;
      
      const interfaceEntity = EntityFactory.createInterface(
        interfaceId,
        parsedInterface.name,
        qualifiedName,
        filePath,
        parsedInterface.startLine,
        parsedInterface.endLine,
        parsedInterface.modifiers
      );

      this.addEntity(entities, interfaceEntity);
      this.addRelationship(relationships, RelationshipBuilder.createBelongsTo(interfaceId, moduleName, filePath));

      // Handle interface inheritance
      if (parsedInterface.extends && parsedInterface.extends.length > 0) {
        for (const parentInterface of parsedInterface.extends) {
          const parentId = this.resolveType(parentInterface.trim(), moduleName, extractionResult.imports);
          this.addRelationship(relationships, RelationshipBuilder.createExtends(interfaceId, parentId, filePath));
        }
      }
    }
  }

  private parseEnums(
    content: string,
    filePath: string,
    moduleName: string,
    entities: ParsedEntity[],
    relationships: ParsedRelationship[]
  ): void {
    const extractionResult = this.contentExtractor.extractContent(content, filePath);
    
    for (const parsedEnum of extractionResult.enums) {
      const enumId = `${moduleName}.${parsedEnum.name}`;
      const qualifiedName = `${moduleName}.${parsedEnum.name}`;
      
      const enumEntity = EntityFactory.createEnum(
        enumId,
        parsedEnum.name,
        qualifiedName,
        filePath,
        parsedEnum.startLine,
        parsedEnum.endLine,
        parsedEnum.modifiers
      );

      this.addEntity(entities, enumEntity);
      this.addRelationship(relationships, RelationshipBuilder.createBelongsTo(enumId, moduleName, filePath));
    }
  }

  private parseFunctions(
    content: string,
    filePath: string,
    moduleName: string,
    entities: ParsedEntity[],
    relationships: ParsedRelationship[]
  ): void {
    const extractionResult = this.contentExtractor.extractContent(content, filePath);
    
    for (const parsedFunction of extractionResult.functions) {
      const functionId = `${moduleName}.${parsedFunction.name}`;
      const qualifiedName = `${moduleName}.${parsedFunction.name}`;
      
      const functionEntity = EntityFactory.createFunction(
        functionId,
        parsedFunction.name,
        qualifiedName,
        filePath,
        parsedFunction.startLine,
        parsedFunction.endLine,
        parsedFunction.modifiers
      );

      this.addEntity(entities, functionEntity);
      this.addRelationship(relationships, RelationshipBuilder.createBelongsTo(functionId, moduleName, filePath));
    }
  }

  private parseFields(
    content: string,
    filePath: string,
    moduleName: string,
    entities: ParsedEntity[],
    relationships: ParsedRelationship[]
  ): void {
    const extractionResult = this.contentExtractor.extractContent(content, filePath);
    
    for (const parsedField of extractionResult.fields) {
      const fieldId = `${moduleName}.${parsedField.name}`;
      const qualifiedName = `${moduleName}.${parsedField.name}`;
      
      const fieldEntity = EntityFactory.createField(
        fieldId,
        parsedField.name,
        qualifiedName,
        filePath,
        parsedField.startLine,
        parsedField.endLine,
        parsedField.modifiers
      );

      this.addEntity(entities, fieldEntity);
      this.addRelationship(relationships, RelationshipBuilder.createBelongsTo(fieldId, moduleName, filePath));
    }
  }

  private resolveType(typeName: string, moduleName: string, imports: any[]): string {
    // Remove generic type parameters
    const baseType = typeName.split('<')[0].trim();
    
    // Check if it's already a qualified name
    if (baseType.includes('.')) {
      return baseType;
    }
    
    // Check imports for the type
    for (const imp of imports) {
      if (imp.items?.includes(baseType)) {
        return imp.module ? `${imp.module}.${baseType}` : baseType;
      }
      if (imp.alias === baseType) {
        return imp.module;
      }
    }
    
    // Check for built-in types
    if (this.isBuiltInType(baseType)) {
      return `typescript.${baseType}`;
    }
    
    // Default to same module
    return `${moduleName}.${baseType}`;
  }

  private isBuiltInType(typeName: string): boolean {
    const builtInTypes = [
      'string', 'number', 'boolean', 'object', 'any', 'void', 'never', 'unknown',
      'Array', 'Object', 'Function', 'Date', 'RegExp', 'Error',
      'Promise', 'Map', 'Set', 'WeakMap', 'WeakSet'
    ];
    
    return builtInTypes.includes(typeName);
  }

  private getModuleFromPath(filePath: string): string {
    const parsed = path.parse(filePath);
    return parsed.name;
  }
}


================================================
FILE: src/scanner/parsers/base/BaseLanguageParser.ts
================================================
import { LanguageParser, ParsedEntity, ParsedRelationship, ParseError } from '../../types.js';

export abstract class BaseLanguageParser implements LanguageParser {
  protected currentProjectId: string = '';

  abstract canParse(filePath: string): boolean;

  abstract parseFile(filePath: string, content: string, projectId: string): Promise<{
    entities: ParsedEntity[];
    relationships: ParsedRelationship[];
    errors: ParseError[];
  }>;

  protected addEntity(entities: ParsedEntity[], entity: Omit<ParsedEntity, 'project_id'>): void {
    entities.push({
      ...entity,
      project_id: this.currentProjectId
    });
  }

  protected addRelationship(relationships: ParsedRelationship[], relationship: Omit<ParsedRelationship, 'project_id'>): void {
    relationships.push({
      ...relationship,
      project_id: this.currentProjectId
    });
  }

  protected addError(errors: ParseError[], error: Omit<ParseError, 'project_id'>): void {
    errors.push({
      ...error,
      project_id: this.currentProjectId
    });
  }

  protected setCurrentProject(projectId: string): void {
    this.currentProjectId = projectId;
  }
}


================================================
FILE: src/scanner/parsers/base/EntityFactory.ts
================================================
import { ParsedEntity } from '../../types.js';
import { AnnotationInfo } from '../../../types.js';

export class EntityFactory {
  static createClass(
    id: string,
    name: string,
    qualifiedName: string,
    sourceFile: string,
    startLine?: number,
    endLine?: number,
    modifiers?: string[],
    description?: string,
    annotations?: AnnotationInfo[]
  ): Omit<ParsedEntity, 'project_id'> {
    return {
      id,
      type: 'class',
      name,
      qualified_name: qualifiedName,
      source_file: sourceFile,
      start_line: startLine,
      end_line: endLine,
      modifiers: modifiers || [],
      description,
      annotations: annotations || []
    };
  }

  static createInterface(
    id: string,
    name: string,
    qualifiedName: string,
    sourceFile: string,
    startLine?: number,
    endLine?: number,
    modifiers?: string[],
    description?: string,
    annotations?: AnnotationInfo[]
  ): Omit<ParsedEntity, 'project_id'> {
    return {
      id,
      type: 'interface',
      name,
      qualified_name: qualifiedName,
      source_file: sourceFile,
      start_line: startLine,
      end_line: endLine,
      modifiers: modifiers || [],
      description,
      annotations: annotations || []
    };
  }

  static createMethod(
    id: string,
    name: string,
    qualifiedName: string,
    sourceFile: string,
    startLine?: number,
    endLine?: number,
    modifiers?: string[],
    description?: string,
    annotations?: AnnotationInfo[]
  ): Omit<ParsedEntity, 'project_id'> {
    return {
      id,
      type: 'method',
      name,
      qualified_name: qualifiedName,
      source_file: sourceFile,
      start_line: startLine,
      end_line: endLine,
      modifiers: modifiers || [],
      description,
      annotations: annotations || []
    };
  }

  static createFunction(
    id: string,
    name: string,
    qualifiedName: string,
    sourceFile: string,
    startLine?: number,
    endLine?: number,
    modifiers?: string[],
    description?: string,
    annotations?: AnnotationInfo[]
  ): Omit<ParsedEntity, 'project_id'> {
    return {
      id,
      type: 'function',
      name,
      qualified_name: qualifiedName,
      source_file: sourceFile,
      start_line: startLine,
      end_line: endLine,
      modifiers: modifiers || [],
      description,
      annotations: annotations || []
    };
  }

  static createField(
    id: string,
    name: string,
    qualifiedName: string,
    sourceFile: string,
    startLine?: number,
    endLine?: number,
    modifiers?: string[],
    description?: string,
    annotations?: AnnotationInfo[]
  ): Omit<ParsedEntity, 'project_id'> {
    return {
      id,
      type: 'field',
      name,
      qualified_name: qualifiedName,
      source_file: sourceFile,
      start_line: startLine,
      end_line: endLine,
      modifiers: modifiers || [],
      description,
      annotations: annotations || []
    };
  }

  static createEnum(
    id: string,
    name: string,
    qualifiedName: string,
    sourceFile: string,
    startLine?: number,
    endLine?: number,
    modifiers?: string[],
    description?: string,
    annotations?: AnnotationInfo[]
  ): Omit<ParsedEntity, 'project_id'> {
    return {
      id,
      type: 'enum',
      name,
      qualified_name: qualifiedName,
      source_file: sourceFile,
      start_line: startLine,
      end_line: endLine,
      modifiers: modifiers || [],
      description,
      annotations: annotations || []
    };
  }

  static createPackage(
    id: string,
    name: string,
    qualifiedName: string,
    sourceFile: string,
    description?: string
  ): Omit<ParsedEntity, 'project_id'> {
    return {
      id,
      type: 'package',
      name,
      qualified_name: qualifiedName,
      source_file: sourceFile,
      description
    };
  }

  static createModule(
    id: string,
    name: string,
    qualifiedName: string,
    sourceFile: string,
    description?: string
  ): Omit<ParsedEntity, 'project_id'> {
    return {
      id,
      type: 'module',
      name,
      qualified_name: qualifiedName,
      source_file: sourceFile,
      description
    };
  }

  static createException(
    id: string,
    name: string,
    qualifiedName: string,
    sourceFile: string,
    startLine?: number,
    endLine?: number,
    modifiers?: string[],
    description?: string,
    annotations?: AnnotationInfo[]
  ): Omit<ParsedEntity, 'project_id'> {
    return {
      id,
      type: 'exception',
      name,
      qualified_name: qualifiedName,
      source_file: sourceFile,
      start_line: startLine,
      end_line: endLine,
      modifiers: modifiers || [],
      description,
      annotations: annotations || []
    };
  }
}


================================================
FILE: src/scanner/parsers/base/RelationshipBuilder.ts
================================================
import { ParsedRelationship } from '../../types.js';

export class RelationshipBuilder {
  static createExtends(
    sourceId: string,
    targetId: string,
    sourceFile: string
  ): Omit<ParsedRelationship, 'project_id'> {
    return {
      id: `${sourceId}_extends_${targetId}`,
      type: 'extends',
      source: sourceId,
      target: targetId,
      source_file: sourceFile
    };
  }

  static createImplements(
    sourceId: string,
    targetId: string,
    sourceFile: string
  ): Omit<ParsedRelationship, 'project_id'> {
    return {
      id: `${sourceId}_implements_${targetId}`,
      type: 'implements',
      source: sourceId,
      target: targetId,
      source_file: sourceFile
    };
  }

  static createContains(
    sourceId: string,
    targetId: string,
    sourceFile: string
  ): Omit<ParsedRelationship, 'project_id'> {
    return {
      id: `${sourceId}_contains_${targetId}`,
      type: 'contains',
      source: sourceId,
      target: targetId,
      source_file: sourceFile
    };
  }

  static createCalls(
    sourceId: string,
    targetId: string,
    sourceFile: string
  ): Omit<ParsedRelationship, 'project_id'> {
    return {
      id: `${sourceId}_calls_${targetId}`,
      type: 'calls',
      source: sourceId,
      target: targetId,
      source_file: sourceFile
    };
  }

  static createReferences(
    sourceId: string,
    targetId: string,
    sourceFile: string
  ): Omit<ParsedRelationship, 'project_id'> {
    return {
      id: `${sourceId}_references_${targetId}`,
      type: 'references',
      source: sourceId,
      target: targetId,
      source_file: sourceFile
    };
  }

  static createThrows(
    sourceId: string,
    targetId: string,
    sourceFile: string
  ): Omit<ParsedRelationship, 'project_id'> {
    return {
      id: `${sourceId}_throws_${targetId}`,
      type: 'throws',
      source: sourceId,
      target: targetId,
      source_file: sourceFile
    };
  }

  static createBelongsTo(
    sourceId: string,
    targetId: string,
    sourceFile: string
  ): Omit<ParsedRelationship, 'project_id'> {
    return {
      id: `${sourceId}_belongs_to_${targetId}`,
      type: 'belongs_to',
      source: sourceId,
      target: targetId,
      source_file: sourceFile
    };
  }
}


================================================
FILE: src/scanner/parsers/entity-parsers/java/JavaClassParser.ts
================================================
import { ParsedEntity, ParsedRelationship } from '../../../types.js';
import { EntityFactory } from '../../base/EntityFactory.js';
import { RelationshipBuilder } from '../../base/RelationshipBuilder.js';
import { JavaContentExtractor } from '../../extractors/java/JavaContentExtractor.js';
import { JavaDocExtractor } from '../../extractors/java/JavaDocExtractor.js';
import { JavaFrameworkDetector } from '../../framework-detection/java/JavaFrameworkDetector.js';
import { JavaAnnotationExtractor } from '../../extractors/java/JavaAnnotationExtractor.js';

export class JavaClassParser {
  private contentExtractor = new JavaContentExtractor();
  private docExtractor = new JavaDocExtractor();
  private frameworkDetector = new JavaFrameworkDetector();
  private annotationExtractor = new JavaAnnotationExtractor();

  parseClasses(
    content: string, 
    filePath: string, 
    packageName: string,
    entities: ParsedEntity[], 
    relationships: ParsedRelationship[],
    addEntity: (entity: Omit<ParsedEntity, 'project_id'>) => void,
    addRelationship: (rel: Omit<ParsedRelationship, 'project_id'>) => void
  ): void {
    const extractionResult = this.contentExtractor.extractContent(content, filePath);
    
    for (const parsedClass of extractionResult.classes) {
      const classId = `${packageName}.${parsedClass.name}`;
      const qualifiedName = `${packageName}.${parsedClass.name}`;
      
      // Extract documentation
      const documentation = parsedClass.startLine 
        ? this.docExtractor.extractDocumentation(content, this.getPositionFromLine(content, parsedClass.startLine))
        : undefined;

      // Extract annotations using modular extractor
      const annotationResult = this.annotationExtractor.extractAnnotations(content, this.getPositionFromLine(content, parsedClass.startLine || 1));
      const annotations = annotationResult.annotations;

      // Create class entity
      const classEntity = EntityFactory.createClass(
        classId,
        parsedClass.name,
        qualifiedName,
        filePath,
        parsedClass.startLine,
        parsedClass.endLine,
        parsedClass.modifiers,
        documentation,
        annotations
      );

      addEntity(classEntity);

      // Create package relationship
      const packageId = packageName;
      addRelationship(RelationshipBuilder.createBelongsTo(classId, packageId, filePath));

      // Handle inheritance
      if (parsedClass.extends && parsedClass.extends.length > 0) {
        for (const parentClass of parsedClass.extends) {
          const parentId = this.resolveType(parentClass.trim(), packageName, extractionResult.imports);
          addRelationship(RelationshipBuilder.createExtends(classId, parentId, filePath));
        }
      }

      // Handle interfaces
      if (parsedClass.implements && parsedClass.implements.length > 0) {
        for (const interfaceName of parsedClass.implements) {
          const interfaceId = this.resolveType(interfaceName.trim(), packageName, extractionResult.imports);
          addRelationship(RelationshipBuilder.createImplements(classId, interfaceId, filePath));
        }
      }
    }
  }

  private extractAnnotations(content: string, startLine: number): any[] {
    const annotations: any[] = [];
    const lines = content.split('\n');
    
    // Look backwards from the class declaration for annotations
    for (let i = startLine - 2; i >= 0; i--) {
      const line = lines[i].trim();
      if (!line || line.startsWith('//') || line.startsWith('/*')) continue;
      
      const annotationMatch = line.match(/@([A-Za-z_][A-Za-z0-9_]*)/);
      if (annotationMatch) {
        const annotationName = annotationMatch[1];
        const framework = this.frameworkDetector.detectFramework(annotationName) || 'Unknown';
        const category = this.frameworkDetector.categorizeAnnotation(annotationName) || 'unknown';
        
        annotations.unshift({
          name: annotationName,
          framework,
          category
        });
      } else if (line && !line.startsWith('@')) {
        break; // Stop at non-annotation content
      }
    }
    
    return annotations;
  }

  private resolveType(typeName: string, packageName: string, imports: any[]): string {
    // Remove generic type parameters
    const baseType = typeName.split('<')[0].trim();
    
    // Check if it's a fully qualified name
    if (baseType.includes('.')) {
      return baseType;
    }
    
    // Check imports for the type
    for (const imp of imports) {
      if (imp.items?.includes(baseType) || imp.module.endsWith(`.${baseType}`)) {
        return imp.module.includes('.') ? imp.module : `${packageName}.${baseType}`;
      }
    }
    
    // Default to same package
    return `${packageName}.${baseType}`;
  }

  private getPositionFromLine(content: string, lineNumber: number): number {
    const lines = content.split('\n');
    let position = 0;
    
    for (let i = 0; i < Math.min(lineNumber - 1, lines.length); i++) {
      position += lines[i].length + 1; // +1 for newline
    }
    
    return position;
  }
}


================================================
FILE: src/scanner/parsers/entity-parsers/java/JavaFieldParser.ts
================================================
import { ParsedEntity, ParsedRelationship } from '../../../types.js';
import { EntityFactory } from '../../base/EntityFactory.js';
import { RelationshipBuilder } from '../../base/RelationshipBuilder.js';
import { JavaContentExtractor } from '../../extractors/java/JavaContentExtractor.js';
import { JavaDocExtractor } from '../../extractors/java/JavaDocExtractor.js';
import { JavaFrameworkDetector } from '../../framework-detection/java/JavaFrameworkDetector.js';

export class JavaFieldParser {
  private contentExtractor = new JavaContentExtractor();
  private docExtractor = new JavaDocExtractor();
  private frameworkDetector = new JavaFrameworkDetector();

  parseFields(
    content: string, 
    filePath: string, 
    packageName: string,
    entities: ParsedEntity[], 
    relationships: ParsedRelationship[],
    addEntity: (entity: Omit<ParsedEntity, 'project_id'>) => void,
    addRelationship: (rel: Omit<ParsedRelationship, 'project_id'>) => void
  ): void {
    const extractionResult = this.contentExtractor.extractContent(content, filePath);
    
    for (const parsedField of extractionResult.fields) {
      // Determine the containing class
      const containingClass = this.findContainingClass(content, parsedField.startLine || 1, entities);
      if (!containingClass) continue; // Skip if not in a class
      
      const fieldId = `${containingClass.qualified_name}.${parsedField.name}`;
      const qualifiedName = `${containingClass.qualified_name}.${parsedField.name}`;
      
      // Extract documentation
      const documentation = parsedField.startLine 
        ? this.docExtractor.extractDocumentation(content, this.getPositionFromLine(content, parsedField.startLine))
        : undefined;

      // Extract annotations
      const annotations = this.extractAnnotations(content, parsedField.startLine || 1);

      // Create field entity
      const fieldEntity = EntityFactory.createField(
        fieldId,
        parsedField.name,
        qualifiedName,
        filePath,
        parsedField.startLine,
        parsedField.endLine,
        parsedField.modifiers,
        documentation,
        annotations
      );

      addEntity(fieldEntity);

      // Create containment relationship
      addRelationship(RelationshipBuilder.createContains(containingClass.id, fieldId, filePath));

      // Create type reference if the field has a custom type
      if (parsedField.type) {
        const referencedType = this.resolveType(parsedField.type, packageName, extractionResult.imports);
        if (referencedType !== parsedField.type && !this.isBuiltInType(referencedType)) {
          addRelationship(RelationshipBuilder.createReferences(fieldId, referencedType, filePath));
        }
      }
    }
  }

  private findContainingClass(content: string, fieldLine: number, entities: ParsedEntity[]): ParsedEntity | null {
    // Find the class that contains this field based on line numbers
    for (const entity of entities) {
      if (entity.type === 'class' && 
          entity.start_line && 
          entity.end_line &&
          fieldLine >= entity.start_line && 
          fieldLine <= entity.end_line) {
        return entity;
      }
    }
    return null;
  }

  private resolveType(typeName: string, packageName: string, imports: any[]): string {
    // Remove generic type parameters and array brackets
    const baseType = typeName.replace(/[<>\[\]]/g, '').split(/[<,\s]/)[0].trim();
    
    // Check if it's a fully qualified name
    if (baseType.includes('.')) {
      return baseType;
    }
    
    // Check imports for the type
    for (const imp of imports) {
      if (imp.items?.includes(baseType) || imp.module.endsWith(`.${baseType}`)) {
        return imp.module.includes('.') ? imp.module : `${packageName}.${baseType}`;
      }
    }
    
    // Default to same package
    return `${packageName}.${baseType}`;
  }

  private isBuiltInType(typeName: string): boolean {
    const builtInTypes = [
      'int', 'long', 'short', 'byte', 'float', 'double', 'boolean', 'char',
      'Integer', 'Long', 'Short', 'Byte', 'Float', 'Double', 'Boolean', 'Character',
      'String', 'Object', 'void', 'Void',
      'List', 'Set', 'Map', 'Collection', 'ArrayList', 'HashMap', 'HashSet'
    ];
    
    return builtInTypes.some(type => typeName.includes(type));
  }

  private extractAnnotations(content: string, startLine: number): any[] {
    const annotations: any[] = [];
    const lines = content.split('\n');
    
    // Look backwards from the field declaration for annotations
    for (let i = startLine - 2; i >= 0; i--) {
      const line = lines[i].trim();
      if (!line || line.startsWith('//') || line.startsWith('/*')) continue;
      
      const annotationMatch = line.match(/@([A-Za-z_][A-Za-z0-9_]*)/);
      if (annotationMatch) {
        const annotationName = annotationMatch[1];
        const framework = this.frameworkDetector.detectFramework(annotationName) || 'Unknown';
        const category = this.frameworkDetector.categorizeAnnotation(annotationName) || 'unknown';
        
        annotations.unshift({
          name: annotationName,
          framework,
          category
        });
      } else if (line && !line.startsWith('@')) {
        break; // Stop at non-annotation content
      }
    }
    
    return annotations;
  }

  private getPositionFromLine(content: string, lineNumber: number): number {
    const lines = content.split('\n');
    let position = 0;
    
    for (let i = 0; i < Math.min(lineNumber - 1, lines.length); i++) {
      position += lines[i].length + 1; // +1 for newline
    }
    
    return position;
  }
}


================================================
FILE: src/scanner/parsers/entity-parsers/java/JavaMethodParser.ts
================================================
import { ParsedEntity, ParsedRelationship } from '../../../types.js';
import { EntityFactory } from '../../base/EntityFactory.js';
import { RelationshipBuilder } from '../../base/RelationshipBuilder.js';
import { JavaContentExtractor } from '../../extractors/java/JavaContentExtractor.js';
import { JavaDocExtractor } from '../../extractors/java/JavaDocExtractor.js';
import { JavaFrameworkDetector } from '../../framework-detection/java/JavaFrameworkDetector.js';

export class JavaMethodParser {
  private contentExtractor = new JavaContentExtractor();
  private docExtractor = new JavaDocExtractor();
  private frameworkDetector = new JavaFrameworkDetector();

  parseMethods(
    content: string, 
    filePath: string, 
    packageName: string,
    entities: ParsedEntity[], 
    relationships: ParsedRelationship[],
    addEntity: (entity: Omit<ParsedEntity, 'project_id'>) => void,
    addRelationship: (rel: Omit<ParsedRelationship, 'project_id'>) => void
  ): void {
    const extractionResult = this.contentExtractor.extractContent(content, filePath);
    
    for (const parsedMethod of extractionResult.functions) {
      // Determine the containing class
      const containingClass = this.findContainingClass(content, parsedMethod.startLine || 1, entities);
      if (!containingClass) continue; // Skip if not in a class
      
      const methodId = `${containingClass.qualified_name}.${parsedMethod.name}`;
      const qualifiedName = `${containingClass.qualified_name}.${parsedMethod.name}`;
      
      // Extract documentation
      const documentation = parsedMethod.startLine 
        ? this.docExtractor.extractDocumentation(content, this.getPositionFromLine(content, parsedMethod.startLine))
        : undefined;

      // Extract annotations
      const annotations = this.extractAnnotations(content, parsedMethod.startLine || 1);

      // Create method entity
      const methodEntity = EntityFactory.createMethod(
        methodId,
        parsedMethod.name,
        qualifiedName,
        filePath,
        parsedMethod.startLine,
        parsedMethod.endLine,
        parsedMethod.modifiers,
        documentation,
        annotations
      );

      addEntity(methodEntity);

      // Create containment relationship
      addRelationship(RelationshipBuilder.createContains(containingClass.id, methodId, filePath));

      // Parse method calls and create call relationships
      this.parseMethodCalls(content, parsedMethod, methodId, packageName, extractionResult.imports, addRelationship, filePath);
    }
  }

  private findContainingClass(content: string, methodLine: number, entities: ParsedEntity[]): ParsedEntity | null {
    // Find the class that contains this method based on line numbers
    for (const entity of entities) {
      if (entity.type === 'class' && 
          entity.start_line && 
          entity.end_line &&
          methodLine >= entity.start_line && 
          methodLine <= entity.end_line) {
        return entity;
      }
    }
    return null;
  }

  private parseMethodCalls(
    content: string, 
    method: any, 
    methodId: string, 
    packageName: string,
    imports: any[],
    addRelationship: (rel: Omit<ParsedRelationship, 'project_id'>) => void,
    filePath: string
  ): void {
    if (!method.startLine || !method.endLine) return;
    
    const methodBody = this.extractMethodBody(content, method.startLine, method.endLine);
    
    // Simple regex to find method calls - can be improved
    const methodCallPattern = /([A-Za-z_][A-Za-z0-9_]*)\s*\(/g;
    let match;
    
    while ((match = methodCallPattern.exec(methodBody)) !== null) {
      const calledMethodName = match[1];
      
      // Skip common Java keywords and built-in methods
      if (this.isBuiltInMethod(calledMethodName)) continue;
      
      // Try to resolve the called method
      const calledMethodId = this.resolveMethodCall(calledMethodName, packageName, imports);
      
      addRelationship(RelationshipBuilder.createCalls(methodId, calledMethodId, filePath));
    }
  }

  private extractMethodBody(content: string, startLine: number, endLine: number): string {
    const lines = content.split('\n');
    return lines.slice(startLine - 1, endLine).join('\n');
  }

  private isBuiltInMethod(methodName: string): boolean {
    const builtInMethods = [
      'if', 'else', 'for', 'while', 'do', 'switch', 'case', 'default',
      'try', 'catch', 'finally', 'throw', 'throws', 'return', 'new',
      'this', 'super', 'class', 'interface', 'enum', 'extends', 'implements',
      'public', 'private', 'protected', 'static', 'final', 'abstract',
      'println', 'print', 'toString', 'equals', 'hashCode', 'getClass'
    ];
    
    return builtInMethods.includes(methodName);
  }

  private resolveMethodCall(methodName: string, packageName: string, imports: any[]): string {
    // Simple resolution - can be enhanced with more sophisticated type analysis
    return `${packageName}.${methodName}`;
  }

  private extractAnnotations(content: string, startLine: number): any[] {
    const annotations: any[] = [];
    const lines = content.split('\n');
    
    // Look backwards from the method declaration for annotations
    for (let i = startLine - 2; i >= 0; i--) {
      const line = lines[i].trim();
      if (!line || line.startsWith('//') || line.startsWith('/*')) continue;
      
      const annotationMatch = line.match(/@([A-Za-z_][A-Za-z0-9_]*)/);
      if (annotationMatch) {
        const annotationName = annotationMatch[1];
        const framework = this.frameworkDetector.detectFramework(annotationName) || 'Unknown';
        const category = this.frameworkDetector.categorizeAnnotation(annotationName) || 'unknown';
        
        annotations.unshift({
          name: annotationName,
          framework,
          category
        });
      } else if (line && !line.startsWith('@')) {
        break; // Stop at non-annotation content
      }
    }
    
    return annotations;
  }

  private getPositionFromLine(content: string, lineNumber: number): number {
    const lines = content.split('\n');
    let position = 0;
    
    for (let i = 0; i < Math.min(lineNumber - 1, lines.length); i++) {
      position += lines[i].length + 1; // +1 for newline
    }
    
    return position;
  }
}


================================================
FILE: src/scanner/parsers/entity-parsers/python/PythonClassParser.ts
================================================
import { ParsedEntity, ParsedRelationship } from '../../../types.js';
import { EntityFactory } from '../../base/EntityFactory.js';
import { RelationshipBuilder } from '../../base/RelationshipBuilder.js';
import { PythonContentExtractor } from '../../extractors/python/PythonContentExtractor.js';
import { DocstringExtractor } from '../../extractors/python/DocstringExtractor.js';
import { PythonFrameworkDetector } from '../../framework-detection/PythonFrameworkDetector.js';

export class PythonClassParser {
  private contentExtractor = new PythonContentExtractor();
  private docExtractor = new DocstringExtractor();
  private frameworkDetector = new PythonFrameworkDetector();

  parseClasses(
    content: string, 
    filePath: string, 
    moduleName: string,
    entities: ParsedEntity[], 
    relationships: ParsedRelationship[],
    addEntity: (entity: Omit<ParsedEntity, 'project_id'>) => void,
    addRelationship: (rel: Omit<ParsedRelationship, 'project_id'>) => void
  ): void {
    const extractionResult = this.contentExtractor.extractContent(content, filePath);
    
    for (const parsedClass of extractionResult.classes) {
      const classId = `${moduleName}.${parsedClass.name}`;
      const qualifiedName = `${moduleName}.${parsedClass.name}`;
      
      // Extract documentation
      const documentation = parsedClass.startLine 
        ? this.docExtractor.extractDocumentation(content, this.getPositionFromLine(content, parsedClass.startLine))
        : undefined;

      // Extract decorators
      const decorators = this.extractDecorators(content, parsedClass.startLine || 1);

      // Create class entity
      const classEntity = EntityFactory.createClass(
        classId,
        parsedClass.name,
        qualifiedName,
        filePath,
        parsedClass.startLine,
        parsedClass.endLine,
        parsedClass.modifiers,
        documentation,
        decorators
      );

      addEntity(classEntity);

      // Create module relationship
      const moduleId = moduleName;
      addRelationship(RelationshipBuilder.createBelongsTo(classId, moduleId, filePath));

      // Handle inheritance
      if (parsedClass.extends && parsedClass.extends.length > 0) {
        for (const parentClass of parsedClass.extends) {
          const parentId = this.resolveType(parentClass.trim(), moduleName, extractionResult.imports);
          addRelationship(RelationshipBuilder.createExtends(classId, parentId, filePath));
        }
      }
    }
  }

  private extractDecorators(content: string, startLine: number): any[] {
    const decorators: any[] = [];
    const lines = content.split('\n');
    
    // Look backwards from the class declaration for decorators
    for (let i = startLine - 2; i >= 0; i--) {
      const line = lines[i].trim();
      if (!line || line.startsWith('#')) continue;
      
      const decoratorMatch = line.match(/@([A-Za-z_][A-Za-z0-9_.]*)(?:\(([^)]*)\))?/);
      if (decoratorMatch) {
        const decoratorName = decoratorMatch[1];
        const framework = this.frameworkDetector.detectFramework(decoratorName) || 'Unknown';
        const category = this.frameworkDetector.categorizeAnnotation(decoratorName) || 'unknown';
        
        decorators.unshift({
          name: decoratorName,
          framework,
          category,
          parameters: decoratorMatch[2] ? decoratorMatch[2].split(',').map(p => p.trim()) : []
        });
      } else if (line && !line.startsWith('@')) {
        break; // Stop at non-decorator content
      }
    }
    
    return decorators;
  }

  private resolveType(typeName: string, moduleName: string, imports: any[]): string {
    // Remove generic type parameters
    const baseType = typeName.split('[')[0].trim();
    
    // Check if it's already a qualified name
    if (baseType.includes('.')) {
      return baseType;
    }
    
    // Check imports for the type
    for (const imp of imports) {
      if (imp.items?.includes(baseType)) {
        return imp.module ? `${imp.module}.${baseType}` : baseType;
      }
      if (imp.alias === baseType) {
        return imp.module;
      }
    }
    
    // Check for built-in types
    if (this.isBuiltInType(baseType)) {
      return `builtins.${baseType}`;
    }
    
    // Default to same module
    return `${moduleName}.${baseType}`;
  }

  private isBuiltInType(typeName: string): boolean {
    const builtInTypes = [
      'object', 'str', 'int', 'float', 'bool', 'list', 'dict', 'tuple', 'set',
      'Exception', 'BaseException', 'ValueError', 'TypeError', 'AttributeError'
    ];
    
    return builtInTypes.includes(typeName);
  }

  private getPositionFromLine(content: string, lineNumber: number): number {
    const lines = content.split('\n');
    let position = 0;
    
    for (let i = 0; i < Math.min(lineNumber - 1, lines.length); i++) {
      position += lines[i].length + 1; // +1 for newline
    }
    
    return position;
  }
}


================================================
FILE: src/scanner/parsers/entity-parsers/python/PythonFunctionParser.ts
================================================
import { ParsedEntity, ParsedRelationship } from '../../../types.js';
import { EntityFactory } from '../../base/EntityFactory.js';
import { RelationshipBuilder } from '../../base/RelationshipBuilder.js';
import { PythonContentExtractor } from '../../extractors/python/PythonContentExtractor.js';
import { DocstringExtractor } from '../../extractors/python/DocstringExtractor.js';
import { PythonFrameworkDetector } from '../../framework-detection/PythonFrameworkDetector.js';

export class PythonFunctionParser {
  private contentExtractor = new PythonContentExtractor();
  private docExtractor = new DocstringExtractor();
  private frameworkDetector = new PythonFrameworkDetector();

  parseFunctions(
    content: string, 
    filePath: string, 
    moduleName: string,
    entities: ParsedEntity[], 
    relationships: ParsedRelationship[],
    addEntity: (entity: Omit<ParsedEntity, 'project_id'>) => void,
    addRelationship: (rel: Omit<ParsedRelationship, 'project_id'>) => void
  ): void {
    const extractionResult = this.contentExtractor.extractContent(content, filePath);
    
    for (const parsedFunction of extractionResult.functions) {
      // Determine if this is a method (inside a class) or a standalone function
      const containingClass = this.findContainingClass(content, parsedFunction.startLine || 1, entities);
      
      let functionId: string;
      let qualifiedName: string;
      let entityType: 'function' | 'method';
      
      if (containingClass) {
        // This is a method
        functionId = `${containingClass.qualified_name}.${parsedFunction.name}`;
        qualifiedName = `${containingClass.qualified_name}.${parsedFunction.name}`;
        entityType = 'method';
      } else {
        // This is a standalone function
        functionId = `${moduleName}.${parsedFunction.name}`;
        qualifiedName = `${moduleName}.${parsedFunction.name}`;
        entityType = 'function';
      }
      
      // Extract documentation
      const documentation = parsedFunction.startLine 
        ? this.docExtractor.extractDocumentation(content, this.getPositionFromLine(content, parsedFunction.startLine))
        : undefined;

      // Extract decorators
      const decorators = this.extractDecorators(content, parsedFunction.startLine || 1);

      // Create function/method entity
      const functionEntity = entityType === 'method' 
        ? EntityFactory.createMethod(
            functionId,
            parsedFunction.name,
            qualifiedName,
            filePath,
            parsedFunction.startLine,
            parsedFunction.endLine,
            parsedFunction.modifiers,
            documentation,
            decorators
          )
        : EntityFactory.createFunction(
            functionId,
            parsedFunction.name,
            qualifiedName,
            filePath,
            parsedFunction.startLine,
            parsedFunction.endLine,
            parsedFunction.modifiers,
            documentation,
            decorators
          );

      addEntity(functionEntity);

      // Create containment relationship
      if (containingClass) {
        addRelationship(RelationshipBuilder.createContains(containingClass.id, functionId, filePath));
      } else {
        // Function belongs to module
        addRelationship(RelationshipBuilder.createBelongsTo(functionId, moduleName, filePath));
      }

      // Parse function calls and create call relationships
      this.parseFunctionCalls(content, parsedFunction, functionId, moduleName, extractionResult.imports, addRelationship, filePath);
    }
  }

  private findContainingClass(content: string, functionLine: number, entities: ParsedEntity[]): ParsedEntity | null {
    // Find the class that contains this function based on line numbers and indentation
    const lines = content.split('\n');
    const functionLineContent = lines[functionLine - 1];
    const functionIndentation = this.getIndentation(functionLineContent);
    
    // Look backwards for a class declaration with less indentation
    for (let i = functionLine - 2; i >= 0; i--) {
      const line = lines[i];
      const lineIndentation = this.getIndentation(line);
      
      if (lineIndentation < functionIndentation && line.trim().startsWith('class ')) {
        // Find the corresponding entity
        for (const entity of entities) {
          if (entity.type === 'class' && entity.start_line === i + 1) {
            return entity;
          }
        }
      }
    }
    
    return null;
  }

  private getIndentation(line: string): number {
    const match = line.match(/^(\s*)/);
    return match ? match[1].length : 0;
  }

  private parseFunctionCalls(
    content: string, 
    func: any, 
    functionId: string, 
    moduleName: string,
    imports: any[],
    addRelationship: (rel: Omit<ParsedRelationship, 'project_id'>) => void,
    filePath: string
  ): void {
    if (!func.startLine || !func.endLine) return;
    
    const functionBody = this.extractFunctionBody(content, func.startLine, func.endLine);
    
    // Simple regex to find function calls - can be improved
    const functionCallPattern = /([A-Za-z_][A-Za-z0-9_]*(?:\.[A-Za-z_][A-Za-z0-9_]*)*)\s*\(/g;
    let match;
    
    while ((match = functionCallPattern.exec(functionBody)) !== null) {
      const calledFunctionName = match[1];
      
      // Skip common Python keywords and built-in functions
      if (this.isBuiltInFunction(calledFunctionName)) continue;
      
      // Try to resolve the called function
      const calledFunctionId = this.resolveFunctionCall(calledFunctionName, moduleName, imports);
      
      addRelationship(RelationshipBuilder.createCalls(functionId, calledFunctionId, filePath));
    }
  }

  private extractFunctionBody(content: string, startLine: number, endLine: number): string {
    const lines = content.split('\n');
    return lines.slice(startLine - 1, endLine).join('\n');
  }

  private isBuiltInFunction(functionName: string): boolean {
    const builtInFunctions = [
      'print', 'len', 'range', 'str', 'int', 'float', 'bool', 'list', 'dict', 'tuple', 'set',
      'type', 'isinstance', 'hasattr', 'getattr', 'setattr', 'delattr',
      'max', 'min', 'sum', 'any', 'all', 'enumerate', 'zip', 'map', 'filter',
      'open', 'input', 'repr', 'exec', 'eval', 'compile',
      'if', 'else', 'elif', 'for', 'while', 'try', 'except', 'finally', 'with',
      'def', 'class', 'return', 'yield', 'import', 'from', 'as', 'pass', 'break', 'continue'
    ];
    
    return builtInFunctions.some(builtin => functionName.includes(builtin));
  }

  private resolveFunctionCall(functionName: string, moduleName: string, imports: any[]): string {
    // Handle method calls (obj.method)
    if (functionName.includes('.')) {
      const parts = functionName.split('.');
      const objectName = parts[0];
      const methodName = parts.slice(1).join('.');
      
      // Try to resolve through imports
      for (const imp of imports) {
        if (imp.alias === objectName || imp.items?.includes(objectName)) {
          return `${imp.module}.${methodName}`;
        }
      }
      
      return `${moduleName}.${functionName}`;
    }
    
    // Simple function call
    return `${moduleName}.${functionName}`;
  }

  private extractDecorators(content: string, startLine: number): any[] {
    const decorators: any[] = [];
    const lines = content.split('\n');
    
    // Look backwards from the function declaration for decorators
    for (let i = startLine - 2; i >= 0; i--) {
      const line = lines[i].trim();
      if (!line || line.startsWith('#')) continue;
      
      const decoratorMatch = line.match(/@([A-Za-z_][A-Za-z0-9_.]*)(?:\(([^)]*)\))?/);
      if (decoratorMatch) {
        const decoratorName = decoratorMatch[1];
        const framework = this.frameworkDetector.detectFramework(decoratorName) || 'Unknown';
        const category = this.frameworkDetector.categorizeAnnotation(decoratorName) || 'unknown';
        
        decorators.unshift({
          name: decoratorName,
          framework,
          category,
          parameters: decoratorMatch[2] ? decoratorMatch[2].split(',').map(p => p.trim()) : []
        });
      } else if (line && !line.startsWith('@')) {
        break; // Stop at non-decorator content
      }
    }
    
    return decorators;
  }

  private getPositionFromLine(content: string, lineNumber: number): number {
    const lines = content.split('\n');
    let position = 0;
    
    for (let i = 0; i < Math.min(lineNumber - 1, lines.length); i++) {
      position += lines[i].length + 1; // +1 for newline
    }
    
    return position;
  }
}


================================================
FILE: src/scanner/parsers/entity-parsers/typescript/TypeScriptClassParser.ts
================================================
import { ParsedEntity, ParsedRelationship } from '../../../types.js';
import { EntityFactory } from '../../base/EntityFactory.js';
import { RelationshipBuilder } from '../../base/RelationshipBuilder.js';
import { TypeScriptContentExtractor } from '../../extractors/typescript/TypeScriptContentExtractor.js';
import { JsDocExtractor } from '../../extractors/typescript/JsDocExtractor.js';
import { TypeScriptFrameworkDetector } from '../../framework-detection/typescript/TypeScriptFrameworkDetector.js';
import { TypeScriptAnnotationExtractor } from '../../extractors/typescript/TypeScriptAnnotationExtractor.js';

export class TypeScriptClassParser {
  private contentExtractor = new TypeScriptContentExtractor();
  private docExtractor = new JsDocExtractor();
  private frameworkDetector = new TypeScriptFrameworkDetector();
  private annotationExtractor = new TypeScriptAnnotationExtractor();

  parseClasses(
    content: string, 
    filePath: string, 
    moduleName: string,
    entities: ParsedEntity[], 
    relationships: ParsedRelationship[],
    addEntity: (entity: Omit<ParsedEntity, 'project_id'>) => void,
    addRelationship: (rel: Omit<ParsedRelationship, 'project_id'>) => void
  ): void {
    const extractionResult = this.contentExtractor.extractContent(content, filePath);
    
    for (const parsedClass of extractionResult.classes) {
      const classId = `${moduleName}.${parsedClass.name}`;
      const qualifiedName = `${moduleName}.${parsedClass.name}`;
      
      // Extract documentation
      const documentation = parsedClass.startLine 
        ? this.docExtractor.extractDocumentation(content, this.getPositionFromLine(content, parsedClass.startLine))
        : undefined;

      // Extract decorators using modular extractor
      const decoratorResult = this.annotationExtractor.extractAnnotations(content, this.getPositionFromLine(content, parsedClass.startLine || 1));
      const decorators = decoratorResult.annotations;

      // Create class entity
      const classEntity = EntityFactory.createClass(
        classId,
        parsedClass.name,
        qualifiedName,
        filePath,
        parsedClass.startLine,
        parsedClass.endLine,
        parsedClass.modifiers,
        documentation,
        decorators
      );

      addEntity(classEntity);

      // Create module relationship
      const moduleId = moduleName;
      addRelationship(RelationshipBuilder.createBelongsTo(classId, moduleId, filePath));

      // Handle inheritance
      if (parsedClass.extends && parsedClass.extends.length > 0) {
        for (const parentClass of parsedClass.extends) {
          const parentId = this.resolveType(parentClass.trim(), moduleName, extractionResult.imports);
          addRelationship(RelationshipBuilder.createExtends(classId, parentId, filePath));
        }
      }

      // Handle interfaces
      if (parsedClass.implements && parsedClass.implements.length > 0) {
        for (const interfaceName of parsedClass.implements) {
          const interfaceId = this.resolveType(interfaceName.trim(), moduleName, extractionResult.imports);
          addRelationship(RelationshipBuilder.createImplements(classId, interfaceId, filePath));
        }
      }
    }
  }


  private resolveType(typeName: string, moduleName: string, imports: any[]): string {
    // Remove generic type parameters
    const baseType = typeName.split('<')[0].trim();
    
    // Check if it's already a qualified name
    if (baseType.includes('.')) {
      return baseType;
    }
    
    // Check imports for the type
    for (const imp of imports) {
      if (imp.items?.includes(baseType)) {
        return imp.module ? `${imp.module}.${baseType}` : baseType;
      }
      if (imp.alias === baseType) {
        return imp.module;
      }
    }
    
    // Check for built-in types
    if (this.isBuiltInType(baseType)) {
      return `typescript.${baseType}`;
    }
    
    // Default to same module
    return `${moduleName}.${baseType}`;
  }

  private isBuiltInType(typeName: string): boolean {
    const builtInTypes = [
      'string', 'number', 'boolean', 'object', 'any', 'void', 'never', 'unknown',
      'Array', 'Object', 'Function', 'Date', 'RegExp', 'Error',
      'Promise', 'Map', 'Set', 'WeakMap', 'WeakSet'
    ];
    
    return builtInTypes.includes(typeName);
  }

  private getPositionFromLine(content: string, lineNumber: number): number {
    const lines = content.split('\n');
    let position = 0;
    
    for (let i = 0; i < Math.min(lineNumber - 1, lines.length); i++) {
      position += lines[i].length + 1; // +1 for newline
    }
    
    return position;
  }
}


================================================
FILE: src/scanner/parsers/extractors/base/AnnotationExtractor.ts
================================================
import { AnnotationInfo } from '../../../../types.js';

/**
 * Parameters for annotation extraction
 */
export interface ParsedAnnotationParameter {
  name?: string;
  value: string;
  type?: string;
}

/**
 * Result of annotation extraction
 */
export interface AnnotationExtractionResult {
  annotations: AnnotationInfo[];
  errors: string[];
}

/**
 * Base interface for annotation extraction across different languages
 */
export interface IAnnotationExtractor {
  /**
   * Extract annotations/decorators from source code at a specific position
   */
  extractAnnotations(
    content: string,
    entityPosition: number,
    additionalContext?: any
  ): AnnotationExtractionResult;

  /**
   * Parse annotation parameters from a parameter string
   */
  parseAnnotationParameters(parametersString?: string): ParsedAnnotationParameter[];

  /**
   * Detect which framework an annotation belongs to
   */
  detectFramework(annotationName: string): string | undefined;

  /**
   * Categorize an annotation by its purpose
   */
  categorizeAnnotation(annotationName: string): string | undefined;
}

/**
 * Abstract base class providing common functionality for annotation extractors
 */
export abstract class BaseAnnotationExtractor implements IAnnotationExtractor {
  
  abstract extractAnnotations(
    content: string,
    entityPosition: number,
    additionalContext?: any
  ): AnnotationExtractionResult;

  abstract parseAnnotationParameters(parametersString?: string): ParsedAnnotationParameter[];

  abstract detectFramework(annotationName: string): string | undefined;

  abstract categorizeAnnotation(annotationName: string): string | undefined;

  /**
   * Helper method to split complex parameter strings safely
   */
  protected splitParameters(paramString: string, delimiter: string = ','): string[] {
    const parameters: string[] = [];
    let current = '';
    let depth = 0;
    let inString = false;
    let stringChar = '';
    
    for (let i = 0; i < paramString.length; i++) {
      const char = paramString[i];
      
      if (!inString && (char === '"' || char === "'")) {
        inString = true;
        stringChar = char;
      } else if (inString && char === stringChar) {
        inString = false;
        stringChar = '';
      } else if (!inString) {
        if (char === '(' || char === '[' || char === '{') {
          depth++;
        } else if (char === ')' || char === ']' || char === '}') {
          depth--;
        } else if (char === delimiter && depth === 0) {
          parameters.push(current.trim());
          current = '';
          continue;
        }
      }
      
      current += char;
    }
    
    if (current.trim()) {
      parameters.push(current.trim());
    }
    
    return parameters;
  }

  /**
   * Helper method to infer parameter type from a value string
   */
  protected inferParameterType(value: string): string {
    value = value.trim();
    
    if (value.startsWith('"') || value.startsWith("'")) return 'string';
    if (value === 'true' || value === 'false' || value === 'True' || value === 'False') return 'boolean';
    if (value === 'null' || value === 'None' || value === 'undefined') return 'null';
    if (/^\d+$/.test(value)) return 'number';
    if (/^\d+\.\d+$/.test(value)) return 'number';
    if (value.startsWith('[') || value.startsWith('(') || value.startsWith('{')) return 'collection';
    
    return 'identifier';
  }

  /**
   * Helper method to remove quotes from string values
   */
  protected removeQuotes(value: string): string {
    return value.replace(/^["']|["']$/g, '');
  }

  /**
   * Helper method to find content before a specific position in the source
   */
  protected getContentBefore(content: string, position: number): string[] {
    return content.substring(0, position).split('\n');
  }

  /**
   * Helper method to check if a line is a comment
   */
  protected abstract isCommentLine(line: string): boolean;

  /**
   * Helper method to check if a line is an annotation/decorator
   */
  protected abstract isAnnotationLine(line: string): boolean;
}


================================================
FILE: src/scanner/parsers/extractors/base/ContentExtractor.ts
================================================
export interface ParsedMethod {
  name: string;
  parameters: ParsedParameter[];
  returnType?: string;
  modifiers: string[];
  startLine?: number;
  endLine?: number;
  body?: string;
}

export interface ParsedParameter {
  name: string;
  type?: string;
  defaultValue?: string;
  isOptional?: boolean;
}

export interface ParsedClass {
  name: string;
  extends?: string[];
  implements?: string[];
  modifiers: string[];
  startLine?: number;
  endLine?: number;
  body?: string;
}

export interface ParsedInterface {
  name: string;
  extends?: string[];
  modifiers: string[];
  startLine?: number;
  endLine?: number;
  body?: string;
}

export interface ParsedField {
  name: string;
  type?: string;
  defaultValue?: string;
  modifiers: string[];
  startLine?: number;
  endLine?: number;
}

export interface ParsedEnum {
  name: string;
  values: string[];
  modifiers: string[];
  startLine?: number;
  endLine?: number;
}

export interface ParsedImport {
  module: string;
  items?: string[];
  alias?: string;
  isDefault?: boolean;
}

export interface ContentExtractionResult {
  packageName?: string;
  moduleName?: string;
  imports: ParsedImport[];
  classes: ParsedClass[];
  interfaces: ParsedInterface[];
  enums: ParsedEnum[];
  functions: ParsedMethod[];
  fields: ParsedField[];
  exceptions: ParsedClass[];
}

export abstract class BaseContentExtractor {
  abstract extractContent(content: string, filePath: string): ContentExtractionResult;

  protected findLineNumber(content: string, searchText: string): number | undefined {
    const lines = content.split('\n');
    for (let i = 0; i < lines.length; i++) {
      if (lines[i].includes(searchText)) {
        return i + 1; // Line numbers are 1-based
      }
    }
    return undefined;
  }

  protected findLineRange(content: string, startText: string, endPattern: RegExp | string): { start: number; end: number } | undefined {
    const lines = content.split('\n');
    let startLine = -1;
    let endLine = -1;
    
    // Find start line
    for (let i = 0; i < lines.length; i++) {
      if (lines[i].includes(startText)) {
        startLine = i + 1;
        break;
      }
    }
    
    if (startLine === -1) return undefined;
    
    // Find end line
    const isRegex = endPattern instanceof RegExp;
    for (let i = startLine - 1; i < lines.length; i++) {
      const line = lines[i];
      const matches = isRegex ? endPattern.test(line) : line.includes(endPattern as string);
      if (matches) {
        endLine = i + 1;
        break;
      }
    }
    
    return endLine !== -1 ? { start: startLine, end: endLine } : { start: startLine, end: startLine };
  }

  protected extractBody(content: string, startLine: number, endLine?: number): string {
    const lines = content.split('\n');
    const start = Math.max(0, startLine - 1);
    const end = endLine ? Math.min(lines.length, endLine) : lines.length;
    
    return lines.slice(start, end).join('\n');
  }

  protected parseModifiers(modifierString: string): string[] {
    const modifiers = modifierString.trim().split(/\s+/);
    return modifiers.filter(m => m && !['class', 'interface', 'enum', 'def', 'function'].includes(m));
  }

  protected parseParameters(paramString: string): ParsedParameter[] {
    if (!paramString || paramString.trim() === '') {
      return [];
    }

    const parameters: ParsedParameter[] = [];
    const params = this.splitParameters(paramString);
    
    for (const param of params) {
      const parsed = this.parseParameter(param.trim());
      if (parsed) {
        parameters.push(parsed);
      }
    }
    
    return parameters;
  }

  protected abstract parseParameter(param: string): ParsedParameter | null;

  protected splitParameters(paramString: string): string[] {
    const parameters: string[] = [];
    let current = '';
    let depth = 0;
    let inString = false;
    let stringChar = '';
    
    for (let i = 0; i < paramString.length; i++) {
      const char = paramString[i];
      const prevChar = i > 0 ? paramString[i - 1] : '';
      
      if ((char === '"' || char === "'") && prevChar !== '\\') {
        if (!inString) {
          inString = true;
          stringChar = char;
        } else if (char === stringChar) {
          inString = false;
          stringChar = '';
        }
      }
      
      if (!inString) {
        if (char === '(' || char === '[' || char === '{') {
          depth++;
        } else if (char === ')' || char === ']' || char === '}') {
          depth--;
        } else if (char === ',' && depth === 0) {
          parameters.push(current.trim());
          current = '';
          continue;
        }
      }
      
      current += char;
    }
    
    if (current.trim()) {
      parameters.push(current.trim());
    }
    
    return parameters;
  }
}


================================================
FILE: src/scanner/parsers/extractors/base/DocumentationExtractor.ts
================================================
export interface DocumentationExtractor {
  extractDocumentation(content: string, position: number): string | undefined;
}

export abstract class BaseDocumentationExtractor implements DocumentationExtractor {
  abstract extractDocumentation(content: string, position: number): string | undefined;

  protected cleanCommentMarkers(content: string, patterns: RegExp[]): string {
    let cleaned = content;
    for (const pattern of patterns) {
      cleaned = cleaned.replace(pattern, '');
    }
    return cleaned.trim();
  }

  protected joinLines(lines: string[]): string {
    return lines.join('\n').trim();
  }

  protected isEmptyOrComment(line: string, commentMarkers: string[]): boolean {
    const trimmed = line.trim();
    if (trimmed === '') return true;
    
    return commentMarkers.some(marker => trimmed.startsWith(marker));
  }

  protected findBoundary(lines: string[], startIndex: number, direction: 'forward' | 'backward', stopConditions: (line: string) => boolean): number {
    const increment = direction === 'forward' ? 1 : -1;
    const limit = direction === 'forward' ? lines.length : -1;
    
    for (let i = startIndex; i !== limit; i += increment) {
      if (stopConditions(lines[i])) {
        return i;
      }
    }
    
    return -1;
  }
}


================================================
FILE: src/scanner/parsers/extractors/base/MethodCallExtractor.ts
================================================
export interface ParsedMethodCall {
  targetMethod: string;
  callType: 'instance' | 'static' | 'constructor' | 'function' | 'super';
  lineNumber: number;
  callerObject?: string;
  parameters?: string[];
  context?: 'assignment' | 'return' | 'parameter' | 'standalone';
}

export interface MethodCallExtractionResult {
  calls: ParsedMethodCall[];
  errors: string[];
}

export abstract class BaseMethodCallExtractor {
  abstract extractMethodCalls(
    methodBody: string, 
    methodName: string,
    className?: string,
    packageName?: string,
    imports?: Map<string, string>
  ): MethodCallExtractionResult;

  protected findLineNumber(content: string, searchText: string, startOffset: number = 0): number {
    const beforeOffset = content.substring(0, startOffset);
    const linesBeforeOffset = beforeOffset.split('\n').length - 1;
    
    const lines = content.substring(startOffset).split('\n');
    for (let i = 0; i < lines.length; i++) {
      if (lines[i].includes(searchText)) {
        return linesBeforeOffset + i + 1; // Line numbers are 1-based
      }
    }
    return linesBeforeOffset + 1;
  }

  protected removeCommentsAndStrings(line: string): string {
    // This is a base implementation - should be overridden by language-specific extractors
    return line;
  }

  protected isValidMethodCall(objectOrClass: string, method: string): boolean {
    // Base validation - can be overridden by language-specific extractors
    return objectOrClass.length > 0 && method.length > 0;
  }

  protected isValidFunctionCall(functionName: string): boolean {
    // Base validation - can be overridden by language-specific extractors
    return functionName.length > 0 && /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(functionName);
  }

  protected isStaticCall(objectName: string): boolean {
    // Simple heuristic: starts with uppercase letter (can be overridden)
    return /^[A-Z]/.test(objectName);
  }

  protected resolveMethodCall(
    object: string, 
    method: string, 
    packageName?: string, 
    imports?: Map<string, string>
  ): string {
    // Basic resolution - can be enhanced by language-specific extractors
    return `${object}.${method}`;
  }

  protected resolveStaticMethodCall(
    className: string, 
    method: string, 
    packageName?: string, 
    imports?: Map<string, string>
  ): string {
    // Basic resolution - can be enhanced by language-specific extractors
    if (imports?.has(className)) {
      return `${imports.get(className)}.${method}`;
    }
    return packageName ? `${packageName}.${className}.${method}` : `${className}.${method}`;
  }

  protected resolveConstructorCall(
    className: string, 
    packageName?: string, 
    imports?: Map<string, string>
  ): string {
    // Basic resolution - can be enhanced by language-specific extractors
    if (imports?.has(className)) {
      return `${imports.get(className)}.<init>`;
    }
    return packageName ? `${packageName}.${className}.<init>` : `${className}.<init>`;
  }
}


================================================
FILE: src/scanner/parsers/extractors/java/JavaAnnotationExtractor.ts
================================================
import { BaseAnnotationExtractor, AnnotationExtractionResult, ParsedAnnotationParameter } from '../base/AnnotationExtractor.js';
import { AnnotationInfo } from '../../../../types.js';

/**
 * Java-specific annotation extraction
 */
export class JavaAnnotationExtractor extends BaseAnnotationExtractor {

  extractAnnotations(
    content: string,
    entityPosition: number
  ): AnnotationExtractionResult {
    const errors: string[] = [];
    const annotations: AnnotationInfo[] = [];

    try {
      const beforeEntity = content.substring(0, entityPosition);
      const lines = beforeEntity.split('\n');
      
      // Scan backwards from entity to find annotations
      for (let i = lines.length - 1; i >= 0; i--) {
        const line = lines[i].trim();
        
        if (this.isAnnotationLine(line)) {
          const match = line.match(/@([A-Za-z_][A-Za-z0-9_]*)(?:\(([^)]*)\))?/);
          if (match) {
            const annotationName = match[1];
            const parametersString = match[2];
            
            annotations.unshift({
              name: `@${annotationName}`,
              type: 'annotation',
              parameters: this.parseAnnotationParameters(parametersString),
              source_line: i + 1,
              framework: this.detectFramework(annotationName),
              category: this.categorizeAnnotation(annotationName)
            });
          }
        } else if (line && !this.isCommentLine(line)) {
          // Stop on non-comment, non-annotation content
          break;
        }
      }
    } catch (error) {
      errors.push(`Error extracting Java annotations: ${error instanceof Error ? error.message : String(error)}`);
    }

    return { annotations, errors };
  }

  parseAnnotationParameters(parametersString?: string): ParsedAnnotationParameter[] {
    if (!parametersString || !parametersString.trim()) {
      return [];
    }
    
    const params: ParsedAnnotationParameter[] = [];
    const paramString = parametersString.trim();
    
    // Handle simple cases like @Annotation("value") or @Annotation(value = "something")
    if (paramString.includes('=')) {
      // Named parameters
      const assignments = this.splitParameters(paramString);
      for (const assignment of assignments) {
        const parts = assignment.split('=').map(p => p.trim());
        if (parts.length === 2) {
          params.push({
            name: parts[0],
            value: this.removeQuotes(parts[1]),
            type: this.inferParameterType(parts[1])
          });
        }
      }
    } else {
      // Single value parameter
      params.push({
        value: this.removeQuotes(paramString),
        type: this.inferParameterType(paramString)
      });
    }
    
    return params;
  }

  detectFramework(annotationName: string): string | undefined {
    const frameworkMap: Record<string, string> = {
      // Spring Framework
      'SpringBootApplication': 'Spring Boot',
      'RestController': 'Spring MVC',
      'Controller': 'Spring MVC',
      'Service': 'Spring',
      'Component': 'Spring',
      'Repository': 'Spring',
      'Autowired': 'Spring',
      'Value': 'Spring',
      'Configuration': 'Spring',
      'Bean': 'Spring',
      'RequestMapping': 'Spring MVC',
      'GetMapping': 'Spring MVC',
      'PostMapping': 'Spring MVC',
      'PutMapping': 'Spring MVC',
      'DeleteMapping': 'Spring MVC',
      'PathVariable': 'Spring MVC',
      'RequestParam': 'Spring MVC',
      'RequestBody': 'Spring MVC',
      'ResponseBody': 'Spring MVC',
      'CrossOrigin': 'Spring MVC',
      'Valid': 'Spring Validation',
      'Validated': 'Spring Validation',
      
      // JPA/Hibernate
      'Entity': 'JPA',
      'Table': 'JPA',
      'Id': 'JPA',
      'GeneratedValue': 'JPA',
      'Column': 'JPA',
      'JoinColumn': 'JPA',
      'OneToMany': 'JPA',
      'ManyToOne': 'JPA',
      'ManyToMany': 'JPA',
      'OneToOne': 'JPA',
      'Transactional': 'Spring Transaction',
      
      // Testing
      'Test': 'JUnit',
      'BeforeEach': 'JUnit',
      'AfterEach': 'JUnit',
      'BeforeAll': 'JUnit',
      'AfterAll': 'JUnit',
      'Mock': 'Mockito',
      'MockBean': 'Spring Test',
      'WebMvcTest': 'Spring Test',
      'SpringBootTest': 'Spring Test',
      'DataJpaTest': 'Spring Test',
      
      // Java Core
      'Override': 'Java Core',
      'Deprecated': 'Java Core',
      'SuppressWarnings': 'Java Core',
      'FunctionalInterface': 'Java Core',
      'SafeVarargs': 'Java Core',
      
      // Validation
      'NotNull': 'Bean Validation',
      'NotEmpty': 'Bean Validation',
      'NotBlank': 'Bean Validation',
      'Size': 'Bean Validation',
      'Min': 'Bean Validation',
      'Max': 'Bean Validation',
      'Email': 'Bean Validation',
      'Pattern': 'Bean Validation',
      
      // Security
      'PreAuthorize': 'Spring Security',
      'PostAuthorize': 'Spring Security',
      'Secured': 'Spring Security',
      'RolesAllowed': 'Spring Security',
      
      // Lombok
      'Data': 'Lombok',
      'Builder': 'Lombok',
      'AllArgsConstructor': 'Lombok',
      'NoArgsConstructor': 'Lombok',
      'RequiredArgsConstructor': 'Lombok',
      'Getter': 'Lombok',
      'Setter': 'Lombok',
      'ToString': 'Lombok',
      'EqualsAndHashCode': 'Lombok'
    };
    
    return frameworkMap[annotationName];
  }

  categorizeAnnotation(annotationName: string): string | undefined {
    const categoryMap: Record<string, string> = {
      // Lifecycle
      'SpringBootApplication': 'lifecycle',
      'Configuration': 'lifecycle',
      'Bean': 'lifecycle',
      'BeforeEach': 'lifecycle',
      'AfterEach': 'lifecycle',
      'BeforeAll': 'lifecycle',
      'AfterAll': 'lifecycle',
      
      // Dependency Injection
      'Autowired': 'injection',
      'Value': 'injection',
      'Component': 'injection',
      'Service': 'injection',
      'Repository': 'injection',
      'Controller': 'injection',
      'RestController': 'injection',
      
      // Web/REST
      'RequestMapping': 'web',
      'GetMapping': 'web',
      'PostMapping': 'web',
      'PutMapping': 'web',
      'DeleteMapping': 'web',
      'PathVariable': 'web',
      'RequestParam': 'web',
      'RequestBody': 'web',
      'ResponseBody': 'web',
      'CrossOrigin': 'web',
      
      // Data/Persistence
      'Entity': 'persistence',
      'Table': 'persistence',
      'Id': 'persistence',
      'GeneratedValue': 'persistence',
      'Column': 'persistence',
      'JoinColumn': 'persistence',
      'OneToMany': 'persistence',
      'ManyToOne': 'persistence',
      'ManyToMany': 'persistence',
      'OneToOne': 'persistence',
      'Transactional': 'persistence',
      
      // Testing
      'Test': 'testing',
      'Mock': 'testing',
      'MockBean': 'testing',
      'WebMvcTest': 'testing',
      'SpringBootTest': 'testing',
      'DataJpaTest': 'testing',
      
      // Validation
      'Valid': 'validation',
      'Validated': 'validation',
      'NotNull': 'validation',
      'NotEmpty': 'validation',
      'NotBlank': 'validation',
      'Size': 'validation',
      'Min': 'validation',
      'Max': 'validation',
      'Email': 'validation',
      'Pattern': 'validation',
      
      // Security
      'PreAuthorize': 'security',
      'PostAuthorize': 'security',
      'Secured': 'security',
      'RolesAllowed': 'security',
      
      // Code Generation
      'Data': 'codegen',
      'Builder': 'codegen',
      'AllArgsConstructor': 'codegen',
      'NoArgsConstructor': 'codegen',
      'RequiredArgsConstructor': 'codegen',
      'Getter': 'codegen',
      'Setter': 'codegen',
      'ToString': 'codegen',
      'EqualsAndHashCode': 'codegen',
      
      // Language Features
      'Override': 'language',
      'Deprecated': 'language',
      'SuppressWarnings': 'language',
      'FunctionalInterface': 'language',
      'SafeVarargs': 'language'
    };
    
    return categoryMap[annotationName];
  }

  protected isCommentLine(line: string): boolean {
    const trimmed = line.trim();
    return trimmed.startsWith('//') || trimmed.startsWith('/*') || trimmed.startsWith('*');
  }

  protected isAnnotationLine(line: string): boolean {
    return line.trim().startsWith('@');
  }
}


================================================
FILE: src/scanner/parsers/extractors/java/JavaContentExtractor.ts
================================================
import * as path from 'path';
import { 
  BaseContentExtractor, 
  ContentExtractionResult, 
  ParsedClass, 
  ParsedInterface, 
  ParsedMethod, 
  ParsedField, 
  ParsedEnum, 
  ParsedImport,
  ParsedParameter 
} from '../base/ContentExtractor.js';

export class JavaContentExtractor extends BaseContentExtractor {
  private static readonly PACKAGE_PATTERN = /^\s*package\s+([a-zA-Z_$][a-zA-Z0-9_$.]*)\s*;/m;
  private static readonly IMPORT_PATTERN = /^\s*import\s+(?:static\s+)?([a-zA-Z_$][a-zA-Z0-9_$.]*(?:\.\*)?);/gm;
  private static readonly CLASS_PATTERN = /(?:(?:public|private|protected|static|final|abstract)\s+)*class\s+([A-Za-z_$][A-Za-z0-9_$]*)\s*(?:extends\s+([^{]+?))?\s*(?:implements\s+([^{]+?))?\s*\{/g;
  private static readonly INTERFACE_PATTERN = /(?:(?:public|private|protected|static)\s+)*interface\s+([A-Za-z_$][A-Za-z0-9_$]*)\s*(?:extends\s+([^{]+?))?\s*\{/g;
  private static readonly ENUM_PATTERN = /(?:(?:public|private|protected|static)\s+)*enum\s+([A-Za-z_$][A-Za-z0-9_$]*)\s*\{([^}]+)\}/g;
  private static readonly METHOD_PATTERN = /(?:(?:public|private|protected|static|final|abstract|synchronized|native|strictfp)\s+)*(?:(<[^>]+>\s+))?([A-Za-z_$][A-Za-z0-9_$.<>,\[\]\s]*)\s+([A-Za-z_$][A-Za-z0-9_$]*)\s*\(([^)]*)\)\s*(?:throws\s+([^{]+?))?\s*[{;]/g;
  private static readonly FIELD_PATTERN = /(?:(?:public|private|protected|static|final|volatile|transient)\s+)+([A-Za-z_$][A-Za-z0-9_$.<>,\[\]\s]*)\s+([A-Za-z_$][A-Za-z0-9_$]*)\s*(?:=\s*[^;]+)?\s*;/g;

  extractContent(content: string, filePath: string): ContentExtractionResult {
    const result: ContentExtractionResult = {
      imports: this.extractImports(content),
      classes: this.extractClasses(content),
      interfaces: this.extractInterfaces(content),
      enums: this.extractEnums(content),
      functions: this.extractMethods(content),
      fields: this.extractFields(content),
      exceptions: []
    };

    // Extract package name
    const packageMatch = content.match(JavaContentExtractor.PACKAGE_PATTERN);
    if (packageMatch) {
      result.packageName = packageMatch[1];
    } else {
      result.packageName = this.getPackageFromPath(filePath);
    }

    // Separate exceptions from regular classes
    result.exceptions = result.classes.filter(cls => 
      cls.extends?.some(parent => parent.includes('Exception') || parent.includes('Error')) ||
      cls.name.endsWith('Exception') || cls.name.endsWith('Error')
    );

    return result;
  }

  private extractImports(content: string): ParsedImport[] {
    const imports: ParsedImport[] = [];
    let match;
    JavaContentExtractor.IMPORT_PATTERN.lastIndex = 0;

    while ((match = JavaContentExtractor.IMPORT_PATTERN.exec(content)) !== null) {
      const fullImport = match[1];
      const isWildcard = fullImport.endsWith('.*');
      
      imports.push({
        module: isWildcard ? fullImport.slice(0, -2) : fullImport,
        items: isWildcard ? ['*'] : [fullImport.split('.').pop() || fullImport],
        isDefault: false
      });
    }

    return imports;
  }

  private extractClasses(content: string): ParsedClass[] {
    const classes: ParsedClass[] = [];
    let match;
    JavaContentExtractor.CLASS_PATTERN.lastIndex = 0;

    while ((match = JavaContentExtractor.CLASS_PATTERN.exec(content)) !== null) {
      const [fullMatch, className, extendsClause, implementsClause] = match;
      const lineNumber = this.findLineNumber(content, className);
      
      const parsedClass: ParsedClass = {
        name: className,
        modifiers: this.extractModifiersFromMatch(fullMatch),
        startLine: lineNumber,
        endLine: lineNumber
      };

      if (extendsClause) {
        parsedClass.extends = [extendsClause.trim()];
      }

      if (implementsClause) {
        parsedClass.implements = implementsClause.split(',').map(i => i.trim());
      }

      classes.push(parsedClass);
    }

    return classes;
  }

  private extractInterfaces(content: string): ParsedInterface[] {
    const interfaces: ParsedInterface[] = [];
    let match;
    JavaContentExtractor.INTERFACE_PATTERN.lastIndex = 0;

    while ((match = JavaContentExtractor.INTERFACE_PATTERN.exec(content)) !== null) {
      const [fullMatch, interfaceName, extendsClause] = match;
      const lineNumber = this.findLineNumber(content, interfaceName);
      
      const parsedInterface: ParsedInterface = {
        name: interfaceName,
        modifiers: this.extractModifiersFromMatch(fullMatch),
        startLine: lineNumber,
        endLine: lineNumber
      };

      if (extendsClause) {
        parsedInterface.extends = extendsClause.split(',').map(i => i.trim());
      }

      interfaces.push(parsedInterface);
    }

    return interfaces;
  }

  private extractEnums(content: string): ParsedEnum[] {
    const enums: ParsedEnum[] = [];
    let match;
    JavaContentExtractor.ENUM_PATTERN.lastIndex = 0;

    while ((match = JavaContentExtractor.ENUM_PATTERN.exec(content)) !== null) {
      const [fullMatch, enumName, enumBody] = match;
      const lineNumber = this.findLineNumber(content, enumName);
      
      // Extract enum values
      const values = enumBody.split(',').map(v => v.trim().split(/\s/)[0]).filter(v => v);
      
      enums.push({
        name: enumName,
        values,
        modifiers: this.extractModifiersFromMatch(fullMatch),
        startLine: lineNumber,
        endLine: lineNumber
      });
    }

    return enums;
  }

  private extractMethods(content: string): ParsedMethod[] {
    const methods: ParsedMethod[] = [];
    let match;
    JavaContentExtractor.METHOD_PATTERN.lastIndex = 0;

    while ((match = JavaContentExtractor.METHOD_PATTERN.exec(content)) !== null) {
      const [fullMatch, genericTypes, returnType, methodName, paramString, throwsClause] = match;
      const lineNumber = this.findLineNumber(content, methodName);
      
      methods.push({
        name: methodName,
        parameters: this.parseParameters(paramString || ''),
        returnType: returnType?.trim(),
        modifiers: this.extractModifiersFromMatch(fullMatch),
        startLine: lineNumber,
        endLine: lineNumber
      });
    }

    return methods;
  }

  private extractFields(content: string): ParsedField[] {
    const fields: ParsedField[] = [];
    let match;
    JavaContentExtractor.FIELD_PATTERN.lastIndex = 0;

    while ((match = JavaContentExtractor.FIELD_PATTERN.exec(content)) !== null) {
      const [fullMatch, fieldType, fieldName] = match;
      const lineNumber = this.findLineNumber(content, fieldName);
      
      fields.push({
        name: fieldName,
        type: fieldType?.trim(),
        modifiers: this.extractModifiersFromMatch(fullMatch),
        startLine: lineNumber,
        endLine: lineNumber
      });
    }

    return fields;
  }

  private extractModifiersFromMatch(match: string): string[] {
    const modifierKeywords = ['public', 'private', 'protected', 'static', 'final', 'abstract', 'synchronized', 'native', 'strictfp', 'volatile', 'transient'];
    const words = match.split(/\s+/);
    return words.filter(word => modifierKeywords.includes(word));
  }

  protected parseParameter(param: string): ParsedParameter | null {
    const trimmed = param.trim();
    if (!trimmed) return null;

    // Handle Java parameter format: "Type name" or "final Type name"
    const parts = trimmed.split(/\s+/);
    if (parts.length < 2) return null;

    const name = parts[parts.length - 1];
    const type = parts.slice(0, -1).filter(p => !['final'].includes(p)).join(' ');

    return {
      name,
      type: type || undefined,
      isOptional: false
    };
  }

  private getPackageFromPath(filePath: string): string {
    const normalized = path.normalize(filePath);
    const parts = normalized.split(path.sep);
    
    // Find src/main/java or just src directory
    const srcIndex = parts.findIndex(part => part === 'src');
    if (srcIndex !== -1) {
      const startIndex = parts.includes('main') ? srcIndex + 3 : srcIndex + 1;
      const packageParts = parts.slice(startIndex, -1); // Exclude filename
      return packageParts.join('.');
    }
    
    return 'default';
  }
}


================================================
FILE: src/scanner/parsers/extractors/java/JavaDocExtractor.ts
================================================
import { BaseDocumentationExtractor } from '../base/DocumentationExtractor.js';

export class JavaDocExtractor extends BaseDocumentationExtractor {
  private static readonly JAVADOC_PATTERNS = [
    /\/\*\*/g,  // /** start marker
    /\*\//g,    // */ end marker
    /^\s*\*/gm  // * line continuation markers
  ];

  extractDocumentation(content: string, position: number): string | undefined {
    // Look backwards for JavaDoc comment
    const beforePosition = content.substring(0, position);
    const lines = beforePosition.split('\n');
    
    // Look for /** ... */ pattern just before the declaration
    for (let i = lines.length - 1; i >= 0; i--) {
      const line = lines[i].trim();
      if (line.endsWith('*/')) {
        // Found end of JavaDoc, now find the start
        const javadocLines: string[] = [];
        let foundStart = false;
        
        for (let j = i; j >= 0; j--) {
          const docLine = lines[j].trim();
          javadocLines.unshift(docLine);
          
          if (docLine.startsWith('/**')) {
            foundStart = true;
            break;
          }
        }
        
        if (foundStart) {
          const rawContent = this.joinLines(javadocLines);
          return this.cleanCommentMarkers(rawContent, JavaDocExtractor.JAVADOC_PATTERNS);
        }
      } else if (line && !this.isEmptyOrComment(line, ['*', '//'])) {
        // Found non-comment content, stop looking
        break;
      }
    }
    
    return undefined;
  }

  extractJavaDocTags(content: string): Record<string, string[]> {
    const tags: Record<string, string[]> = {};
    const lines = content.split('\n');
    
    for (const line of lines) {
      const trimmed = line.trim();
      const tagMatch = trimmed.match(/^@(\w+)\s*(.*)$/);
      if (tagMatch) {
        const [, tagName, tagContent] = tagMatch;
        if (!tags[tagName]) {
          tags[tagName] = [];
        }
        tags[tagName].push(tagContent.trim());
      }
    }
    
    return tags;
  }
}


================================================
FILE: src/scanner/parsers/extractors/java/JavaMethodCallExtractor.ts
================================================
import { 
  BaseMethodCallExtractor, 
  ParsedMethodCall, 
  MethodCallExtractionResult 
} from '../base/MethodCallExtractor.js';

export class JavaMethodCallExtractor extends BaseMethodCallExtractor {
  private static readonly INSTANCE_CALL_PATTERN = /(\w+)\.(\w+)\s*\(/g;
  private static readonly STATIC_CALL_PATTERN = /([A-Z]\w*)\.(\w+)\s*\(/g;
  private static readonly CONSTRUCTOR_PATTERN = /new\s+([A-Z]\w*)\s*\(/g;
  private static readonly SUPER_CALL_PATTERN = /super\.(\w+)\s*\(/g;
  private static readonly FUNCTION_CALL_PATTERN = /(?:^|[^\w.])(\w+)\s*\(/g;

  extractMethodCalls(
    methodBody: string,
    methodName: string,
    className?: string,
    packageName?: string,
    imports?: Map<string, string>
  ): MethodCallExtractionResult {
    const calls: ParsedMethodCall[] = [];
    const errors: string[] = [];

    try {
      const lines = methodBody.split('\n');

      lines.forEach((line, lineIndex) => {
        const cleanLine = this.removeCommentsAndStrings(line);
        
        // Extract instance method calls
        calls.push(...this.extractInstanceCalls(cleanLine, lineIndex + 1, packageName, imports));
        
        // Extract static method calls
        calls.push(...this.extractStaticCalls(cleanLine, lineIndex + 1, packageName, imports));
        
        // Extract constructor calls
        calls.push(...this.extractConstructorCalls(cleanLine, lineIndex + 1, packageName, imports));
        
        // Extract super method calls
        calls.push(...this.extractSuperCalls(cleanLine, lineIndex + 1, className));
        
        // Extract direct method calls (same class)
        calls.push(...this.extractDirectCalls(cleanLine, lineIndex + 1, className, methodName));
      });

    } catch (error) {
      errors.push(`Error extracting method calls: ${error instanceof Error ? error.message : String(error)}`);
    }

    return { calls, errors };
  }

  private extractInstanceCalls(
    line: string, 
    lineNumber: number, 
    packageName?: string, 
    imports?: Map<string, string>
  ): ParsedMethodCall[] {
    const calls: ParsedMethodCall[] = [];
    const pattern = new RegExp(JavaMethodCallExtractor.INSTANCE_CALL_PATTERN.source, 'g');
    let match;

    while ((match = pattern.exec(line)) !== null) {
      const object = match[1];
      const method = match[2];
      
      if (this.isValidMethodCall(object, method)) {
        calls.push({
          targetMethod: this.resolveMethodCall(object, method, packageName, imports),
          callType: 'instance',
          lineNumber,
          callerObject: object
        });
      }
    }

    return calls;
  }

  private extractStaticCalls(
    line: string, 
    lineNumber: number, 
    packageName?: string, 
    imports?: Map<string, string>
  ): ParsedMethodCall[] {
    const calls: ParsedMethodCall[] = [];
    const pattern = new RegExp(JavaMethodCallExtractor.STATIC_CALL_PATTERN.source, 'g');
    let match;

    while ((match = pattern.exec(line)) !== null) {
      const className = match[1];
      const method = match[2];
      
      if (this.isValidMethodCall(className, method)) {
        calls.push({
          targetMethod: this.resolveStaticMethodCall(className, method, packageName, imports),
          callType: 'static',
          lineNumber,
          callerObject: className
        });
      }
    }

    return calls;
  }

  private extractConstructorCalls(
    line: string, 
    lineNumber: number, 
    packageName?: string, 
    imports?: Map<string, string>
  ): ParsedMethodCall[] {
    const calls: ParsedMethodCall[] = [];
    const pattern = new RegExp(JavaMethodCallExtractor.CONSTRUCTOR_PATTERN.source, 'g');
    let match;

    while ((match = pattern.exec(line)) !== null) {
      const className = match[1];
      
      if (this.isValidConstructor(className)) {
        calls.push({
          targetMethod: this.resolveConstructorCall(className, packageName, imports),
          callType: 'constructor',
          lineNumber,
          callerObject: className
        });
      }
    }

    return calls;
  }

  private extractSuperCalls(
    line: string, 
    lineNumber: number, 
    className?: string
  ): ParsedMethodCall[] {
    const calls: ParsedMethodCall[] = [];
    const pattern = new RegExp(JavaMethodCallExtractor.SUPER_CALL_PATTERN.source, 'g');
    let match;

    while ((match = pattern.exec(line)) !== null) {
      const method = match[1];
      
      calls.push({
        targetMethod: `super.${method}`,
        callType: 'super',
        lineNumber,
        callerObject: 'super'
      });
    }

    return calls;
  }

  private extractDirectCalls(
    line: string, 
    lineNumber: number, 
    className?: string,
    currentMethodName?: string
  ): ParsedMethodCall[] {
    const calls: ParsedMethodCall[] = [];
    const pattern = new RegExp(JavaMethodCallExtractor.FUNCTION_CALL_PATTERN.source, 'g');
    let match;

    while ((match = pattern.exec(line)) !== null) {
      const functionName = match[1];
      
      // Skip the current method itself and common keywords
      if (functionName !== currentMethodName && this.isValidDirectCall(functionName)) {
        const targetMethod = className ? `${className}.${functionName}` : functionName;
        calls.push({
          targetMethod,
          callType: 'function',
          lineNumber
        });
      }
    }

    return calls;
  }

  protected removeCommentsAndStrings(line: string): string {
    let result = line;
    
    // Remove string literals
    result = result.replace(/"([^"\\]|\\.)*"/g, '""');
    result = result.replace(/'([^'\\]|\\.)*'/g, "''");
    
    // Remove line comments
    const commentIndex = result.indexOf('//');
    if (commentIndex !== -1) {
      result = result.substring(0, commentIndex);
    }
    
    return result;
  }

  protected isValidMethodCall(objectOrClass: string, method: string): boolean {
    // Skip common false positives
    const skipObjects = ['System', 'Logger', 'log', 'logger'];
    const skipMethods = ['out', 'err', 'println', 'print', 'debug', 'info', 'warn', 'error'];
    
    return !skipObjects.includes(objectOrClass) || !skipMethods.includes(method);
  }

  private isValidConstructor(className: string): boolean {
    // Skip common built-in types
    const builtinTypes = ['String', 'Integer', 'Boolean', 'Double', 'Float', 'Long', 'Object'];
    return !builtinTypes.includes(className);
  }

  private isValidDirectCall(functionName: string): boolean {
    // Skip common keywords and built-in functions
    const skipFunctions = ['if', 'for', 'while', 'switch', 'try', 'catch', 'finally', 'return', 'throw', 'assert'];
    return !skipFunctions.includes(functionName);
  }

  protected resolveMethodCall(
    object: string, 
    method: string, 
    packageName?: string, 
    imports?: Map<string, string>
  ): string {
    // Enhanced resolution for Java
    if (object === 'this') {
      return packageName ? `${packageName}.${method}` : method;
    }
    
    // Check if object type is in imports
    const objectType = this.resolveObjectType(object, imports);
    return objectType ? `${objectType}.${method}` : `${object}.${method}`;
  }

  protected resolveStaticMethodCall(
    className: string, 
    method: string, 
    packageName?: string, 
    imports?: Map<string, string>
  ): string {
    // Check imports first
    if (imports?.has(className)) {
      return `${imports.get(className)}.${method}`;
    }
    
    // Check for standard Java library classes
    const javaLangTypes = ['String', 'Object', 'Math', 'System', 'Thread', 'Class'];
    if (javaLangTypes.includes(className)) {
      return `java.lang.${className}.${method}`;
    }
    
    // Assume same package if not found in imports
    return packageName ? `${packageName}.${className}.${method}` : `${className}.${method}`;
  }

  protected resolveConstructorCall(
    className: string, 
    packageName?: string, 
    imports?: Map<string, string>
  ): string {
    // Check imports first
    if (imports?.has(className)) {
      return `${imports.get(className)}.<init>`;
    }
    
    // Check for standard Java library classes
    const javaLangTypes = ['String', 'Object', 'Exception', 'RuntimeException', 'IllegalArgumentException'];
    if (javaLangTypes.includes(className)) {
      return `java.lang.${className}.<init>`;
    }
    
    // Assume same package if not found in imports
    return packageName ? `${packageName}.${className}.<init>` : `${className}.<init>`;
  }

  private resolveObjectType(object: string, imports?: Map<string, string>): string | null {
    // This is a simplified approach - in a full implementation,
    // we would track variable declarations and their types
    return null;
  }
}


================================================
FILE: src/scanner/parsers/extractors/python/DocstringExtractor.ts
================================================
import { BaseDocumentationExtractor } from '../base/DocumentationExtractor.js';

export class DocstringExtractor extends BaseDocumentationExtractor {
  private static readonly TRIPLE_QUOTE_DOUBLE = '"""';
  private static readonly TRIPLE_QUOTE_SINGLE = "'''";

  extractDocumentation(content: string, position: number): string | undefined {
    // Look for docstring after the function/class definition
    const afterPosition = content.substring(position);
    const lines = afterPosition.split('\n');
    
    // Skip empty lines and whitespace
    let docstringStart = -1;
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();
      if (line === '') continue;
      
      // Check for docstring patterns
      if (line.startsWith(DocstringExtractor.TRIPLE_QUOTE_DOUBLE) || 
          line.startsWith(DocstringExtractor.TRIPLE_QUOTE_SINGLE)) {
        docstringStart = i;
        break;
      } else if (line.startsWith('#')) {
        continue; // Skip comments
      } else {
        break; // Found non-docstring content
      }
    }
    
    if (docstringStart === -1) return undefined;
    
    const docstringQuote = lines[docstringStart].includes(DocstringExtractor.TRIPLE_QUOTE_DOUBLE) 
      ? DocstringExtractor.TRIPLE_QUOTE_DOUBLE 
      : DocstringExtractor.TRIPLE_QUOTE_SINGLE;
    
    // Check if single-line docstring
    const firstLine = lines[docstringStart];
    const quoteCount = (firstLine.match(new RegExp(this.escapeRegex(docstringQuote), 'g')) || []).length;
    if (quoteCount >= 2) {
      // Single-line docstring
      return firstLine.replace(new RegExp(this.escapeRegex(docstringQuote), 'g'), '').trim();
    }
    
    // Multi-line docstring
    const docstringLines: string[] = [];
    docstringLines.push(firstLine.replace(docstringQuote, ''));
    
    for (let i = docstringStart + 1; i < lines.length; i++) {
      const line = lines[i];
      if (line.includes(docstringQuote)) {
        docstringLines.push(line.replace(docstringQuote, ''));
        break;
      }
      docstringLines.push(line);
    }
    
    return this.joinLines(docstringLines);
  }

  private escapeRegex(string: string): string {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  }

  extractDocstringSections(content: string): Record<string, string> {
    const sections: Record<string, string> = {};
    const lines = content.split('\n');
    
    let currentSection = 'description';
    let currentContent: string[] = [];
    
    for (const line of lines) {
      const trimmed = line.trim();
      
      // Check for common docstring sections
      const sectionMatch = trimmed.match(/^(Args?|Arguments?|Parameters?|Param|Returns?|Return|Yields?|Yield|Raises?|Raise|Examples?|Example|Notes?|Note):\s*$/i);
      if (sectionMatch) {
        // Save previous section
        if (currentContent.length > 0) {
          sections[currentSection] = currentContent.join('\n').trim();
        }
        
        // Start new section
        currentSection = sectionMatch[1].toLowerCase();
        currentContent = [];
      } else {
        currentContent.push(line);
      }
    }
    
    // Save final section
    if (currentContent.length > 0) {
      sections[currentSection] = currentContent.join('\n').trim();
    }
    
    return sections;
  }
}


================================================
FILE: src/scanner/parsers/extractors/python/PythonAnnotationExtractor.ts
================================================
import { BaseAnnotationExtractor, AnnotationExtractionResult, ParsedAnnotationParameter } from '../base/AnnotationExtractor.js';
import { AnnotationInfo } from '../../../../types.js';

/**
 * Python-specific decorator extraction
 */
export class PythonAnnotationExtractor extends BaseAnnotationExtractor {

  extractAnnotations(
    content: string,
    entityPosition: number
  ): AnnotationExtractionResult {
    const errors: string[] = [];
    const annotations: AnnotationInfo[] = [];

    try {
      const beforeEntity = content.substring(0, entityPosition);
      const lines = beforeEntity.split('\n');
      
      // Scan backwards from entity to find decorators
      for (let i = lines.length - 1; i >= 0; i--) {
        const line = lines[i].trim();
        
        if (this.isAnnotationLine(line)) {
          const match = line.match(/@([A-Za-z_][A-Za-z0-9_.]*)(?:\(([^)]*)\))?/);
          if (match) {
            const decoratorName = match[1];
            const parametersString = match[2];
            
            annotations.unshift({
              name: decoratorName,
              type: 'decorator',
              parameters: this.parseAnnotationParameters(parametersString),
              source_line: i + 1,
              framework: this.detectFramework(decoratorName),
              category: this.categorizeAnnotation(decoratorName)
            });
          }
        } else if (line && !this.isCommentLine(line)) {
          // Stop on non-comment, non-decorator content
          break;
        }
      }
    } catch (error) {
      errors.push(`Error extracting Python decorators: ${error instanceof Error ? error.message : String(error)}`);
    }

    return { annotations, errors };
  }

  parseAnnotationParameters(parametersString?: string): ParsedAnnotationParameter[] {
    if (!parametersString || !parametersString.trim()) {
      return [];
    }
    
    const params: ParsedAnnotationParameter[] = [];
    const paramString = parametersString.trim();
    
    // Handle different parameter patterns
    if (paramString.includes('=')) {
      // Named parameters like @decorator(param1=value1, param2=value2)
      const assignments = this.splitParameters(paramString);
      for (const assignment of assignments) {
        const parts = assignment.split('=').map(p => p.trim());
        if (parts.length === 2) {
          params.push({
            name: parts[0],
            value: this.removeQuotes(parts[1]),
            type: this.inferParameterType(parts[1])
          });
        }
      }
    } else {
      // Positional parameters like @decorator(value1, value2)
      const values = this.splitParameters(paramString);
      for (const value of values) {
        params.push({
          value: this.removeQuotes(value.trim()),
          type: this.inferParameterType(value.trim())
        });
      }
    }
    
    return params;
  }

  detectFramework(decoratorName: string): string | undefined {
    const frameworkMap: Record<string, string> = {
      // Flask
      'app.route': 'Flask',
      'route': 'Flask',
      'before_request': 'Flask',
      'after_request': 'Flask',
      'teardown_request': 'Flask',
      'context_processor': 'Flask',
      'template_filter': 'Flask',
      'template_global': 'Flask',
      
      // Django
      'login_required': 'Django',
      'permission_required': 'Django',
      'user_passes_test': 'Django',
      'csrf_exempt': 'Django',
      'require_http_methods': 'Django',
      'require_GET': 'Django',
      'require_POST': 'Django',
      'require_safe': 'Django',
      'cache_page': 'Django',
      'never_cache': 'Django',
      'vary_on_headers': 'Django',
      'vary_on_cookie': 'Django',
      
      // FastAPI
      'app.get': 'FastAPI',
      'app.post': 'FastAPI',
      'app.put': 'FastAPI',
      'app.delete': 'FastAPI',
      'app.patch': 'FastAPI',
      'app.options': 'FastAPI',
      'app.head': 'FastAPI',
      'app.trace': 'FastAPI',
      'Depends': 'FastAPI',
      'HTTPException': 'FastAPI',
      
      // Pytest
      'pytest.fixture': 'Pytest',
      'pytest.mark.parametrize': 'Pytest',
      'pytest.mark.skip': 'Pytest',
      'pytest.mark.skipif': 'Pytest',
      'pytest.mark.xfail': 'Pytest',
      'pytest.mark.slow': 'Pytest',
      'fixture': 'Pytest',
      'mark.parametrize': 'Pytest',
      'mark.skip': 'Pytest',
      'mark.skipif': 'Pytest',
      'mark.xfail': 'Pytest',
      
      // Celery
      'task': 'Celery',
      'periodic_task': 'Celery',
      'shared_task': 'Celery',
      
      // SQLAlchemy
      'validates': 'SQLAlchemy',
      'reconstructor': 'SQLAlchemy',
      'hybrid_property': 'SQLAlchemy',
      'hybrid_method': 'SQLAlchemy',
      
      // Pydantic
      'validator': 'Pydantic',
      'root_validator': 'Pydantic',
      'field_validator': 'Pydantic',
      'model_validator': 'Pydantic',
      
      // Python built-ins
      'property': 'Python',
      'staticmethod': 'Python',
      'classmethod': 'Python',
      'cached_property': 'Python',
      'lru_cache': 'Python',
      'singledispatch': 'Python',
      'wraps': 'Python',
      'dataclass': 'Python',
      'total_ordering': 'Python',
      
      // Click
      'click.command': 'Click',
      'click.group': 'Click',
      'click.option': 'Click',
      'click.argument': 'Click',
      'command': 'Click',
      'group': 'Click',
      'option': 'Click',
      'argument': 'Click',
      
      // Typing
      'overload': 'Typing',
      'final': 'Typing',
      'runtime_checkable': 'Typing',
      
      // Deprecated
      'deprecated': 'Deprecated'
    };
    
    return frameworkMap[decoratorName];
  }

  categorizeAnnotation(decoratorName: string): string | undefined {
    const categoryMap: Record<string, string> = {
      // Web/API
      'app.route': 'web',
      'route': 'web',
      'app.get': 'web',
      'app.post': 'web',
      'app.put': 'web',
      'app.delete': 'web',
      'app.patch': 'web',
      'require_http_methods': 'web',
      'require_GET': 'web',
      'require_POST': 'web',
      
      // Authentication/Security
      'login_required': 'security',
      'permission_required': 'security',
      'user_passes_test': 'security',
      'csrf_exempt': 'security',
      
      // Caching
      'cache_page': 'caching',
      'never_cache': 'caching',
      'lru_cache': 'caching',
      'cached_property': 'caching',
      
      // Testing
      'pytest.fixture': 'testing',
      'fixture': 'testing',
      'pytest.mark.parametrize': 'testing',
      'mark.parametrize': 'testing',
      'pytest.mark.skip': 'testing',
      'mark.skip': 'testing',
      'pytest.mark.skipif': 'testing',
      'mark.skipif': 'testing',
      'pytest.mark.xfail': 'testing',
      'mark.xfail': 'testing',
      
      // Data/Persistence
      'validates': 'persistence',
      'validator': 'validation',
      'root_validator': 'validation',
      'field_validator': 'validation',
      'model_validator': 'validation',
      
      // Language Features
      'property': 'language',
      'staticmethod': 'language',
      'classmethod': 'language',
      'dataclass': 'language',
      'total_ordering': 'language',
      'overload': 'language',
      'final': 'language',
      'runtime_checkable': 'language',
      
      // Lifecycle/Events
      'before_request': 'lifecycle',
      'after_request': 'lifecycle',
      'teardown_request': 'lifecycle',
      'reconstructor': 'lifecycle',
      
      // Async/Tasks
      'task': 'async',
      'periodic_task': 'async',
      'shared_task': 'async',
      
      // CLI
      'click.command': 'cli',
      'command': 'cli',
      'click.group': 'cli',
      'group': 'cli',
      'click.option': 'cli',
      'option': 'cli',
      'click.argument': 'cli',
      'argument': 'cli',
      
      // Utilities
      'wraps': 'utility',
      'singledispatch': 'utility',
      'deprecated': 'utility',
      'vary_on_headers': 'utility',
      'vary_on_cookie': 'utility',
      
      // Templates
      'template_filter': 'template',
      'template_global': 'template',
      'context_processor': 'template'
    };
    
    return categoryMap[decoratorName];
  }

  protected isCommentLine(line: string): boolean {
    return line.trim().startsWith('#');
  }

  protected isAnnotationLine(line: string): boolean {
    return line.trim().startsWith('@');
  }
}


================================================
FILE: src/scanner/parsers/extractors/python/PythonContentExtractor.ts
================================================
import * as path from 'path';
import { 
  BaseContentExtractor, 
  ContentExtractionResult, 
  ParsedClass, 
  ParsedInterface, 
  ParsedMethod, 
  ParsedField, 
  ParsedEnum, 
  ParsedImport,
  ParsedParameter 
} from '../base/ContentExtractor.js';

export class PythonContentExtractor extends BaseContentExtractor {
  private static readonly CLASS_PATTERN = /^(\s*)class\s+([A-Za-z_][A-Za-z0-9_]*)\s*(?:\(([^)]*)\))?\s*:/gm;
  private static readonly FUNCTION_PATTERN = /^def\s+([A-Za-z_][A-Za-z0-9_]*)\s*\(([^)]*)\)\s*(?:->\s*([^:]+))?\s*:/gm;
  private static readonly METHOD_PATTERN = /^\s+def\s+([A-Za-z_][A-Za-z0-9_]*)\s*\(([^)]*)\)\s*(?:->\s*([^:]+))?\s*:/gm;
  private static readonly ATTRIBUTE_PATTERN = /^\s+([A-Za-z_][A-Za-z0-9_]*)\s*[:=]\s*([^#\n]+)/gm;
  private static readonly IMPORT_PATTERN = /^(?:from\s+([^\s]+)\s+)?import\s+([^\n#]+)/gm;

  extractContent(content: string, filePath: string): ContentExtractionResult {
    const result: ContentExtractionResult = {
      moduleName: this.getModuleFromPath(filePath),
      imports: this.extractImports(content),
      classes: this.extractClasses(content),
      interfaces: [], // Python doesn't have interfaces, but can use ABC
      enums: this.extractEnums(content),
      functions: this.extractFunctions(content),
      fields: this.extractModuleLevelAttributes(content),
      exceptions: []
    };

    // Separate exceptions from regular classes
    result.exceptions = result.classes.filter(cls => 
      cls.extends?.some(parent => parent.includes('Exception') || parent.includes('Error')) ||
      cls.name.endsWith('Exception') || cls.name.endsWith('Error')
    );

    return result;
  }

  private extractImports(content: string): ParsedImport[] {
    const imports: ParsedImport[] = [];
    let match;
    PythonContentExtractor.IMPORT_PATTERN.lastIndex = 0;

    while ((match = PythonContentExtractor.IMPORT_PATTERN.exec(content)) !== null) {
      const [, fromModule, importItems] = match;
      
      if (fromModule) {
        // from module import items
        const items = importItems.split(',').map(item => {
          const trimmed = item.trim();
          const asMatch = trimmed.match(/^(.+?)\s+as\s+(.+)$/);
          return asMatch ? asMatch[1].trim() : trimmed;
        });
        
        imports.push({
          module: fromModule,
          items,
          isDefault: false
        });
      } else {
        // import module
        const modules = importItems.split(',').map(item => {
          const trimmed = item.trim();
          const asMatch = trimmed.match(/^(.+?)\s+as\s+(.+)$/);
          return {
            module: asMatch ? asMatch[1].trim() : trimmed,
            alias: asMatch ? asMatch[2].trim() : undefined
          };
        });
        
        for (const mod of modules) {
          imports.push({
            module: mod.module,
            alias: mod.alias,
            isDefault: false
          });
        }
      }
    }

    return imports;
  }

  private extractClasses(content: string): ParsedClass[] {
    const classes: ParsedClass[] = [];
    let match;
    PythonContentExtractor.CLASS_PATTERN.lastIndex = 0;

    while ((match = PythonContentExtractor.CLASS_PATTERN.exec(content)) !== null) {
      const [fullMatch, indentation, className, inheritance] = match;
      const lineNumber = this.findLineNumber(content, fullMatch);
      
      const parsedClass: ParsedClass = {
        name: className,
        modifiers: this.extractPythonModifiers(className),
        startLine: lineNumber,
        endLine: lineNumber
      };

      if (inheritance) {
        parsedClass.extends = inheritance.split(',').map(parent => parent.trim());
      }

      classes.push(parsedClass);
    }

    return classes;
  }

  private extractFunctions(content: string): ParsedMethod[] {
    const functions: ParsedMethod[] = [];
    let match;
    PythonContentExtractor.FUNCTION_PATTERN.lastIndex = 0;

    while ((match = PythonContentExtractor.FUNCTION_PATTERN.exec(content)) !== null) {
      const [fullMatch, functionName, paramString, returnType] = match;
      const lineNumber = this.findLineNumber(content, fullMatch);
      
      functions.push({
        name: functionName,
        parameters: this.parseParameters(paramString || ''),
        returnType: returnType?.trim(),
        modifiers: this.extractPythonModifiers(functionName),
        startLine: lineNumber,
        endLine: lineNumber
      });
    }

    // Also extract methods within classes
    PythonContentExtractor.METHOD_PATTERN.lastIndex = 0;
    while ((match = PythonContentExtractor.METHOD_PATTERN.exec(content)) !== null) {
      const [fullMatch, methodName, paramString, returnType] = match;
      const lineNumber = this.findLineNumber(content, fullMatch);
      
      functions.push({
        name: methodName,
        parameters: this.parseParameters(paramString || ''),
        returnType: returnType?.trim(),
        modifiers: this.extractPythonModifiers(methodName),
        startLine: lineNumber,
        endLine: lineNumber
      });
    }

    return functions;
  }

  private extractModuleLevelAttributes(content: string): ParsedField[] {
    const fields: ParsedField[] = [];
    const lines = content.split('\n');
    
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      
      // Skip indented lines (class/function level)
      if (line.match(/^\s+/)) continue;
      
      // Match module-level assignments
      const match = line.match(/^([A-Za-z_][A-Za-z0-9_]*)\s*[:=]\s*(.+)/);
      if (match) {
        const [, name, value] = match;
        
        fields.push({
          name,
          defaultValue: value.trim(),
          type: this.inferPythonType(value.trim()),
          modifiers: this.extractPythonModifiers(name),
          startLine: i + 1,
          endLine: i + 1
        });
      }
    }

    return fields;
  }

  private extractEnums(content: string): ParsedEnum[] {
    const enums: ParsedEnum[] = [];
    
    // Look for Enum classes
    const enumClassPattern = /class\s+([A-Za-z_][A-Za-z0-9_]*)\s*\(\s*Enum\s*\)\s*:([\s\S]*?)(?=\n\S|\n*$)/g;
    let match;

    while ((match = enumClassPattern.exec(content)) !== null) {
      const [, enumName, enumBody] = match;
      const lineNumber = this.findLineNumber(content, enumName);
      
      // Extract enum values
      const values = this.extractEnumValues(enumBody);
      
      enums.push({
        name: enumName,
        values,
        modifiers: [],
        startLine: lineNumber,
        endLine: lineNumber
      });
    }

    return enums;
  }

  private extractEnumValues(enumBody: string): string[] {
    const values: string[] = [];
    const lines = enumBody.split('\n');
    
    for (const line of lines) {
      const trimmed = line.trim();
      const match = trimmed.match(/^([A-Z_][A-Z0-9_]*)\s*=/);
      if (match) {
        values.push(match[1]);
      }
    }
    
    return values;
  }

  private extractPythonModifiers(name: string): string[] {
    const modifiers: string[] = [];
    
    if (name.startsWith('__') && name.endsWith('__')) {
      modifiers.push('dunder'); // Double underscore methods
    } else if (name.startsWith('_')) {
      modifiers.push('private');
    }
    
    return modifiers;
  }

  private inferPythonType(value: string): string | undefined {
    value = value.trim();
    
    if (value.match(/^['"].*['"]$/)) return 'str';
    if (value.match(/^\d+$/)) return 'int';
    if (value.match(/^\d*\.\d+$/)) return 'float';
    if (value === 'True' || value === 'False') return 'bool';
    if (value === 'None') return 'None';
    if (value.startsWith('[') && value.endsWith(']')) return 'list';
    if (value.startsWith('{') && value.endsWith('}')) return 'dict';
    if (value.startsWith('(') && value.endsWith(')')) return 'tuple';
    
    return undefined;
  }

  protected parseParameter(param: string): ParsedParameter | null {
    const trimmed = param.trim();
    if (!trimmed) return null;

    // Handle different Python parameter formats
    let name = trimmed;
    let type: string | undefined;
    let defaultValue: string | undefined;
    let isOptional = false;

    // Handle default values: name=value
    const defaultMatch = trimmed.match(/^([^=]+)=(.+)$/);
    if (defaultMatch) {
      name = defaultMatch[1].trim();
      defaultValue = defaultMatch[2].trim();
      isOptional = true;
    }

    // Handle type annotations: name: type
    const typeMatch = name.match(/^([^:]+):\s*(.+)$/);
    if (typeMatch) {
      name = typeMatch[1].trim();
      type = typeMatch[2].trim();
    }

    // Skip special parameters
    if (name === 'self' || name === 'cls' || name.startsWith('*')) {
      return {
        name,
        type,
        defaultValue,
        isOptional
      };
    }

    return {
      name,
      type,
      defaultValue,
      isOptional
    };
  }

  private getModuleFromPath(filePath: string): string {
    const normalized = path.normalize(filePath);
    const parsed = path.parse(normalized);
    
    if (parsed.name === '__init__') {
      // For __init__.py files, use the directory name
      return path.basename(parsed.dir);
    }
    
    return parsed.name;
  }
}


================================================
FILE: src/scanner/parsers/extractors/python/PythonMethodCallExtractor.ts
================================================
import { 
  BaseMethodCallExtractor, 
  ParsedMethodCall, 
  MethodCallExtractionResult 
} from '../base/MethodCallExtractor.js';

export class PythonMethodCallExtractor extends BaseMethodCallExtractor {
  private static readonly INSTANCE_CALL_PATTERN = /(\w+)\.(\w+)\s*\(/g;
  private static readonly STATIC_CALL_PATTERN = /([A-Z]\w*)\.(\w+)\s*\(/g;
  private static readonly CONSTRUCTOR_PATTERN = /([A-Z]\w*)\s*\(/g;
  private static readonly FUNCTION_CALL_PATTERN = /(?:^|[^\w.])(\w+)\s*\(/g;

  extractMethodCalls(
    methodBody: string,
    methodName: string,
    className?: string,
    packageName?: string,
    imports?: Map<string, string>
  ): MethodCallExtractionResult {
    const calls: ParsedMethodCall[] = [];
    const errors: string[] = [];

    try {
      const lines = methodBody.split('\n');

      lines.forEach((line, lineIndex) => {
        const cleanLine = this.removeCommentsAndStrings(line);
        
        // Extract instance method calls
        calls.push(...this.extractInstanceCalls(cleanLine, lineIndex + 1, packageName, imports));
        
        // Extract static/class method calls
        calls.push(...this.extractStaticCalls(cleanLine, lineIndex + 1, packageName, imports));
        
        // Extract constructor calls
        calls.push(...this.extractConstructorCalls(cleanLine, lineIndex + 1, packageName, imports));
        
        // Extract direct function calls
        calls.push(...this.extractFunctionCalls(cleanLine, lineIndex + 1, className, methodName));
      });

    } catch (error) {
      errors.push(`Error extracting method calls: ${error instanceof Error ? error.message : String(error)}`);
    }

    return { calls, errors };
  }

  private extractInstanceCalls(
    line: string, 
    lineNumber: number, 
    packageName?: string, 
    imports?: Map<string, string>
  ): ParsedMethodCall[] {
    const calls: ParsedMethodCall[] = [];
    const pattern = new RegExp(PythonMethodCallExtractor.INSTANCE_CALL_PATTERN.source, 'g');
    let match;

    while ((match = pattern.exec(line)) !== null) {
      const object = match[1];
      const method = match[2];
      
      if (this.isValidMethodCall(object, method)) {
        calls.push({
          targetMethod: this.resolveMethodCall(object, method, packageName, imports),
          callType: 'instance',
          lineNumber,
          callerObject: object
        });
      }
    }

    return calls;
  }

  private extractStaticCalls(
    line: string, 
    lineNumber: number, 
    packageName?: string, 
    imports?: Map<string, string>
  ): ParsedMethodCall[] {
    const calls: ParsedMethodCall[] = [];
    const pattern = new RegExp(PythonMethodCallExtractor.STATIC_CALL_PATTERN.source, 'g');
    let match;

    while ((match = pattern.exec(line)) !== null) {
      const className = match[1];
      const method = match[2];
      
      if (this.isValidMethodCall(className, method)) {
        calls.push({
          targetMethod: this.resolveStaticMethodCall(className, method, packageName, imports),
          callType: 'static',
          lineNumber,
          callerObject: className
        });
      }
    }

    return calls;
  }

  private extractConstructorCalls(
    line: string, 
    lineNumber: number, 
    packageName?: string, 
    imports?: Map<string, string>
  ): ParsedMethodCall[] {
    const calls: ParsedMethodCall[] = [];
    const pattern = new RegExp(PythonMethodCallExtractor.CONSTRUCTOR_PATTERN.source, 'g');
    let match;

    while ((match = pattern.exec(line)) !== null) {
      const className = match[1];
      
      // Skip if this looks like a method call (preceded by a dot)
      const beforeMatch = line.substring(0, match.index);
      if (beforeMatch.endsWith('.')) {
        continue;
      }
      
      if (this.isValidConstructor(className)) {
        calls.push({
          targetMethod: this.resolveConstructorCall(className, packageName, imports),
          callType: 'constructor',
          lineNumber,
          callerObject: className
        });
      }
    }

    return calls;
  }

  private extractFunctionCalls(
    line: string, 
    lineNumber: number, 
    className?: string,
    currentMethodName?: string
  ): ParsedMethodCall[] {
    const calls: ParsedMethodCall[] = [];
    const pattern = new RegExp(PythonMethodCallExtractor.FUNCTION_CALL_PATTERN.source, 'g');
    let match;

    while ((match = pattern.exec(line)) !== null) {
      const functionName = match[1];
      
      // Skip the current method itself, built-ins, and common keywords
      if (functionName !== currentMethodName && this.isValidFunctionCall(functionName)) {
        const targetMethod = className ? `${className}.${functionName}` : functionName;
        calls.push({
          targetMethod,
          callType: 'function',
          lineNumber
        });
      }
    }

    return calls;
  }

  protected removeCommentsAndStrings(line: string): string {
    let result = line;
    
    // Remove string literals (simplified approach)
    result = result.replace(/"([^"\\]|\\.)*"/g, '""');
    result = result.replace(/'([^'\\]|\\.)*'/g, "''");
    result = result.replace(/"""[\s\S]*?"""/g, '""""""');
    result = result.replace(/'''[\s\S]*?'''/g, "''''''");
    
    // Remove line comments
    const commentIndex = result.indexOf('#');
    if (commentIndex !== -1) {
      result = result.substring(0, commentIndex);
    }
    
    return result;
  }

  protected isValidMethodCall(objectOrClass: string, method: string): boolean {
    // Skip common false positives
    const skipObjects = ['print', 'len', 'str', 'int', 'float', 'bool', 'list', 'dict', 'set', 'tuple'];
    const skipMethods = ['append', 'extend', 'pop', 'remove', 'clear', 'copy', 'update', 'get', 'keys', 'values'];
    
    return !skipObjects.includes(objectOrClass) || !skipMethods.includes(method);
  }

  protected isValidFunctionCall(functionName: string): boolean {
    // Skip built-in functions and keywords
    const skipFunctions = [
      // Built-in functions
      'print', 'len', 'range', 'enumerate', 'zip', 'map', 'filter', 'sum', 'max', 'min', 
      'abs', 'all', 'any', 'sorted', 'reversed', 'open', 'input', 'type', 'isinstance', 
      'hasattr', 'getattr', 'setattr', 'delattr', 'dir', 'vars', 'globals', 'locals',
      // Keywords and control structures
      'if', 'for', 'while', 'try', 'except', 'finally', 'with', 'def', 'class', 'return', 
      'yield', 'raise', 'assert', 'import', 'from', 'pass', 'break', 'continue'
    ];
    
    return !skipFunctions.includes(functionName);
  }

  private isValidConstructor(className: string): boolean {
    // Skip built-in types and common classes
    const builtinTypes = [
      'str', 'int', 'float', 'bool', 'list', 'dict', 'set', 'tuple', 'object', 
      'Exception', 'ValueError', 'TypeError', 'KeyError', 'AttributeError', 
      'IndexError', 'RuntimeError', 'NotImplementedError'
    ];
    return !builtinTypes.includes(className);
  }

  protected resolveMethodCall(
    object: string, 
    method: string, 
    packageName?: string, 
    imports?: Map<string, string>
  ): string {
    // Enhanced resolution for Python
    if (object === 'self') {
      return packageName ? `${packageName}.${method}` : method;
    }
    
    if (object === 'cls') {
      return packageName ? `${packageName}.${method}` : method;
    }
    
    // Check if object type is in imports
    const objectType = this.resolveObjectType(object, imports);
    return objectType ? `${objectType}.${method}` : `${object}.${method}`;
  }

  protected resolveStaticMethodCall(
    className: string, 
    method: string, 
    packageName?: string, 
    imports?: Map<string, string>
  ): string {
    // Check imports first
    if (imports?.has(className)) {
      return `${imports.get(className)}.${method}`;
    }
    
    // Assume same module if not found in imports
    return packageName ? `${packageName}.${className}.${method}` : `${className}.${method}`;
  }

  protected resolveConstructorCall(
    className: string, 
    packageName?: string, 
    imports?: Map<string, string>
  ): string {
    // Check imports first
    if (imports?.has(className)) {
      return `${imports.get(className)}.__init__`;
    }
    
    // Assume same module if not found in imports
    return packageName ? `${packageName}.${className}.__init__` : `${className}.__init__`;
  }

  private resolveObjectType(object: string, imports?: Map<string, string>): string | null {
    // This is a simplified approach - in a full implementation,
    // we would track variable declarations and their types
    return null;
  }
}


================================================
FILE: src/scanner/parsers/extractors/typescript/JsDocExtractor.ts
================================================
import { BaseDocumentationExtractor } from '../base/DocumentationExtractor.js';

export class JsDocExtractor extends BaseDocumentationExtractor {
  private static readonly JSDOC_PATTERNS = [
    /\/\*\*/g,  // /** start marker
    /\*\//g,    // */ end marker
    /^\s*\*/gm  // * line continuation markers
  ];

  extractDocumentation(content: string, position: number): string | undefined {
    // Look backwards for JSDoc comment
    const beforePosition = content.substring(0, position);
    const lines = beforePosition.split('\n');
    
    // Look for /** ... */ pattern just before the declaration
    for (let i = lines.length - 1; i >= 0; i--) {
      const line = lines[i].trim();
      if (line.endsWith('*/')) {
        // Found end of JSDoc, now find the start
        const jsdocLines: string[] = [];
        let foundStart = false;
        
        for (let j = i; j >= 0; j--) {
          const docLine = lines[j].trim();
          jsdocLines.unshift(docLine);
          
          if (docLine.startsWith('/**')) {
            foundStart = true;
            break;
          }
        }
        
        if (foundStart) {
          const rawContent = this.joinLines(jsdocLines);
          return this.cleanCommentMarkers(rawContent, JsDocExtractor.JSDOC_PATTERNS);
        }
      } else if (line && !this.isEmptyOrComment(line, ['*', '//'])) {
        // Found non-comment content, stop looking
        break;
      }
    }
    
    return undefined;
  }

  extractFromAstNode(node: any): string | undefined {
    // Extract JSDoc from AST node's leading comments
    if (!node || !node.leadingComments) {
      return undefined;
    }

    for (const comment of node.leadingComments) {
      if (comment.type === 'Block' && comment.value.startsWith('*')) {
        const rawContent = `/**${comment.value}*/`;
        return this.cleanCommentMarkers(rawContent, JsDocExtractor.JSDOC_PATTERNS);
      }
    }

    return undefined;
  }

  extractJSDocTags(content: string): Record<string, string[]> {
    const tags: Record<string, string[]> = {};
    const lines = content.split('\n');
    
    for (const line of lines) {
      const trimmed = line.trim();
      const tagMatch = trimmed.match(/^@(\w+)\s*(.*)$/);
      if (tagMatch) {
        const [, tagName, tagContent] = tagMatch;
        if (!tags[tagName]) {
          tags[tagName] = [];
        }
        tags[tagName].push(tagContent.trim());
      }
    }
    
    return tags;
  }

  extractTypeScriptSpecificTags(content: string): {
    typeParameters?: string[];
    genericConstraints?: Record<string, string>;
    decorators?: string[];
  } {
    const result: any = {};
    const tags = this.extractJSDocTags(content);
    
    // Extract TypeScript-specific information
    if (tags.template) {
      result.typeParameters = tags.template;
    }
    
    if (tags.decorator) {
      result.decorators = tags.decorator;
    }
    
    // Extract generic constraints from @template tags
    if (tags.template) {
      const constraints: Record<string, string> = {};
      for (const template of tags.template) {
        const constraintMatch = template.match(/(\w+)\s+extends\s+(.+)/);
        if (constraintMatch) {
          constraints[constraintMatch[1]] = constraintMatch[2];
        }
      }
      if (Object.keys(constraints).length > 0) {
        result.genericConstraints = constraints;
      }
    }
    
    return result;
  }
}


================================================
FILE: src/scanner/parsers/extractors/typescript/TypeScriptAnnotationExtractor.ts
================================================
import { AST_NODE_TYPES, TSESTree } from '@typescript-eslint/types';
import { BaseAnnotationExtractor, AnnotationExtractionResult, ParsedAnnotationParameter } from '../base/AnnotationExtractor.js';
import { AnnotationInfo } from '../../../../types.js';

/**
 * TypeScript-specific annotation and decorator extraction
 */
export class TypeScriptAnnotationExtractor extends BaseAnnotationExtractor {

  extractAnnotations(
    content: string,
    entityPosition: number,
    astNode?: TSESTree.Node
  ): AnnotationExtractionResult {
    const errors: string[] = [];
    const annotations: AnnotationInfo[] = [];

    try {
      // If we have an AST node, extract decorators from it
      if (astNode && this.hasDecorators(astNode)) {
        const decorators = this.extractDecoratorsFromAST(astNode);
        annotations.push(...decorators);
      } else {
        // Fallback to text-based extraction
        const textDecorators = this.extractDecoratorsFromText(content, entityPosition);
        annotations.push(...textDecorators);
      }
    } catch (error) {
      errors.push(`Error extracting TypeScript annotations: ${error instanceof Error ? error.message : String(error)}`);
    }

    return { annotations, errors };
  }

  private hasDecorators(node: any): boolean {
    return node.decorators && Array.isArray(node.decorators) && node.decorators.length > 0;
  }

  private extractDecoratorsFromAST(node: any): AnnotationInfo[] {
    if (!node.decorators || !Array.isArray(node.decorators)) {
      return [];
    }

    const decorators: AnnotationInfo[] = [];
    
    for (const decorator of node.decorators) {
      if (decorator.expression.type === AST_NODE_TYPES.Identifier) {
        // Simple decorator like @Component
        const decoratorName = decorator.expression.name;
        decorators.push({
          name: `@${decoratorName}`,
          type: 'decorator',
          source_line: decorator.loc?.start.line,
          framework: this.detectFramework(decoratorName),
          category: this.categorizeAnnotation(decoratorName)
        });
      } else if (decorator.expression.type === AST_NODE_TYPES.CallExpression) {
        // Decorator with parameters like @Component({...})
        const decoratorInfo = this.parseCallExpressionDecorator(decorator.expression);
        if (decoratorInfo) {
          decorators.push({
            name: `@${decoratorInfo.name}`,
            type: 'decorator',
            parameters: decoratorInfo.parameters,
            source_line: decorator.loc?.start.line,
            framework: this.detectFramework(decoratorInfo.name),
            category: this.categorizeAnnotation(decoratorInfo.name)
          });
        }
      }
    }
    
    return decorators;
  }

  private extractDecoratorsFromText(content: string, entityPosition: number): AnnotationInfo[] {
    const beforeEntity = content.substring(0, entityPosition);
    const lines = beforeEntity.split('\n');
    const decorators: AnnotationInfo[] = [];
    
    // Scan backwards from entity to find decorators
    for (let i = lines.length - 1; i >= 0; i--) {
      const line = lines[i].trim();
      
      // Skip empty lines and comments
      if (!line || this.isCommentLine(line)) {
        continue;
      }
      
      if (this.isAnnotationLine(line)) {
        // Found a decorator line
        const match = line.match(/@([A-Za-z_][A-Za-z0-9_.]*)(?:\(([^)]*)\))?/);
        if (match) {
          const decoratorName = match[1];
          const parametersString = match[2];
          
          decorators.unshift({
            name: `@${decoratorName}`,
            type: 'decorator',
            parameters: this.parseAnnotationParameters(parametersString),
            source_line: i + 1,
            framework: this.detectFramework(decoratorName),
            category: this.categorizeAnnotation(decoratorName)
          });
        }
      } else if (this.isDecoratorRelated(line)) {
        // This line is part of decorator parameters or metadata - continue scanning
        continue;
      } else {
        // Hit actual code content - stop scanning
        break;
      }
    }
    
    return decorators;
  }
  
  private isDecoratorRelated(line: string): boolean {
    // Check if this line looks like decorator parameters, properties, or metadata
    // This includes object properties, closing braces, array elements, etc.
    return line.includes(':') || line === '}' || line === '})' || line.includes(',') || 
           line.includes("'") || line.includes('"') || line.includes('[') || line.includes(']') ||
           /^\s*\w+\s*:/.test(line) || // property: value pattern
           /^['"].*['"]$/.test(line); // string value
  }

  private parseCallExpressionDecorator(expression: TSESTree.CallExpression): {name: string; parameters: ParsedAnnotationParameter[]} | null {
    if (expression.callee.type === AST_NODE_TYPES.Identifier) {
      const decoratorName = expression.callee.name;
      const parameters = this.extractDecoratorParametersFromAST(expression.arguments);
      
      return {
        name: decoratorName,
        parameters
      };
    }
    
    return null;
  }

  private extractDecoratorParametersFromAST(args: TSESTree.CallExpressionArgument[]): ParsedAnnotationParameter[] {
    const parameters: ParsedAnnotationParameter[] = [];
    
    for (const arg of args) {
      if (arg.type === AST_NODE_TYPES.ObjectExpression) {
        // Handle object parameters like @Component({ selector: 'app-test', template: '...' })
        for (const property of arg.properties) {
          if (property.type === AST_NODE_TYPES.Property && 
              property.key.type === AST_NODE_TYPES.Identifier &&
              property.value.type === AST_NODE_TYPES.Literal) {
            parameters.push({
              name: property.key.name,
              value: String(property.value.value),
              type: typeof property.value.value
            });
          }
        }
      } else if (arg.type === AST_NODE_TYPES.Literal) {
        // Handle simple parameters like @Injectable('service')
        parameters.push({
          value: String(arg.value),
          type: typeof arg.value
        });
      } else if (arg.type === AST_NODE_TYPES.Identifier) {
        // Handle identifier parameters
        parameters.push({
          value: arg.name,
          type: 'identifier'
        });
      }
    }
    
    return parameters;
  }

  parseAnnotationParameters(parametersString?: string): ParsedAnnotationParameter[] {
    if (!parametersString || !parametersString.trim()) {
      return [];
    }

    const params: ParsedAnnotationParameter[] = [];
    const paramString = parametersString.trim();
    
    // Handle object-like parameters
    if (paramString.startsWith('{') && paramString.endsWith('}')) {
      // Object parameters like { selector: 'app-test', template: '...' }
      const objectContent = paramString.slice(1, -1);
      const assignments = this.splitParameters(objectContent);
      
      for (const assignment of assignments) {
        const colonIndex = assignment.indexOf(':');
        if (colonIndex > 0) {
          const name = assignment.substring(0, colonIndex).trim();
          const value = assignment.substring(colonIndex + 1).trim();
          params.push({
            name: this.removeQuotes(name),
            value: this.removeQuotes(value),
            type: this.inferParameterType(value)
          });
        }
      }
    } else {
      // Simple parameters
      const values = this.splitParameters(paramString);
      for (const value of values) {
        params.push({
          value: this.removeQuotes(value.trim()),
          type: this.inferParameterType(value.trim())
        });
      }
    }
    
    return params;
  }

  detectFramework(decoratorName: string): string | undefined {
    const frameworkMap: Record<string, string> = {
      // Angular
      'Component': 'Angular',
      'Injectable': 'Angular',
      'NgModule': 'Angular',
      'Directive': 'Angular',
      'Pipe': 'Angular',
      'Input': 'Angular',
      'Output': 'Angular',
      'ViewChild': 'Angular',
      'ViewChildren': 'Angular',
      'ContentChild': 'Angular',
      'ContentChildren': 'Angular',
      'HostBinding': 'Angular',
      'HostListener': 'Angular',
      
      // NestJS
      'Controller': 'NestJS',
      'Service': 'NestJS',
      'Module': 'NestJS',
      'Get': 'NestJS',
      'Post': 'NestJS',
      'Put': 'NestJS',
      'Delete': 'NestJS',
      'Patch': 'NestJS',
      'Body': 'NestJS',
      'Param': 'NestJS',
      'Query': 'NestJS',
      'Headers': 'NestJS',
      'Req': 'NestJS',
      'Res': 'NestJS',
      'Guard': 'NestJS',
      'UseGuards': 'NestJS',
      'UseFilters': 'NestJS',
      'UseInterceptors': 'NestJS',
      'UsePipes': 'NestJS',
      
      // TypeORM
      'Entity': 'TypeORM',
      'Column': 'TypeORM',
      'PrimaryGeneratedColumn': 'TypeORM',
      'PrimaryColumn': 'TypeORM',
      'OneToMany': 'TypeORM',
      'ManyToOne': 'TypeORM',
      'ManyToMany': 'TypeORM',
      'OneToOne': 'TypeORM',
      'JoinColumn': 'TypeORM',
      'JoinTable': 'TypeORM',
      'Repository': 'TypeORM',
      
      // React
      'memo': 'React',
      'forwardRef': 'React',
      'useState': 'React',
      'useEffect': 'React',
      'useContext': 'React',
      'useReducer': 'React',
      'useCallback': 'React',
      'useMemo': 'React',
      
      // MobX
      'observable': 'MobX',
      'action': 'MobX',
      'computed': 'MobX',
      'observer': 'MobX',
      
      // Inversify
      'injectable': 'Inversify',
      'inject': 'Inversify',
      'named': 'Inversify',
      'tagged': 'Inversify',
      'multiInject': 'Inversify',
      'optional': 'Inversify',
      
      // TypeScript Experimental
      'sealed': 'TypeScript',
      'enumerable': 'TypeScript',
      'override': 'TypeScript',
      'deprecated': 'TypeScript'
    };
    
    return frameworkMap[decoratorName];
  }

  categorizeAnnotation(decoratorName: string): string | undefined {
    const categoryMap: Record<string, string> = {
      // Component/UI
      'Component': 'ui',
      'Directive': 'ui',
      'Pipe': 'ui',
      'NgModule': 'ui',
      'memo': 'ui',
      'forwardRef': 'ui',
      
      // Dependency Injection
      'Injectable': 'injection',
      'Service': 'injection',
      'inject': 'injection',
      'injectable': 'injection',
      'Module': 'injection',
      
      // HTTP/API
      'Controller': 'web',
      'Get': 'web',
      'Post': 'web',
      'Put': 'web',
      'Delete': 'web',
      'Patch': 'web',
      'Body': 'web',
      'Param': 'web',
      'Query': 'web',
      'Headers': 'web',
      'Req': 'web',
      'Res': 'web',
      
      // Data/Persistence
      'Entity': 'persistence',
      'Column': 'persistence',
      'PrimaryGeneratedColumn': 'persistence',
      'PrimaryColumn': 'persistence',
      'OneToMany': 'persistence',
      'ManyToOne': 'persistence',
      'ManyToMany': 'persistence',
      'OneToOne': 'persistence',
      'JoinColumn': 'persistence',
      'JoinTable': 'persistence',
      'Repository': 'persistence',
      
      // Event Handling
      'Input': 'events',
      'Output': 'events',
      'HostListener': 'events',
      'HostBinding': 'events',
      'ViewChild': 'events',
      'ViewChildren': 'events',
      'ContentChild': 'events',
      'ContentChildren': 'events',
      
      // State Management
      'observable': 'state',
      'action': 'state',
      'computed': 'state',
      'observer': 'state',
      'useState': 'state',
      'useReducer': 'state',
      'useContext': 'state',
      
      // Performance
      'useCallback': 'performance',
      'useMemo': 'performance',
      'useEffect': 'lifecycle',
      
      // Security/Guards
      'Guard': 'security',
      'UseGuards': 'security',
      'UseFilters': 'security',
      'UseInterceptors': 'security',
      'UsePipes': 'security',
      
      // Language Features
      'override': 'language',
      'deprecated': 'language',
      'sealed': 'language',
      'enumerable': 'language'
    };
    
    return categoryMap[decoratorName];
  }

  protected isCommentLine(line: string): boolean {
    const trimmed = line.trim();
    return trimmed.startsWith('//') || trimmed.startsWith('/*') || trimmed.startsWith('*');
  }

  protected isAnnotationLine(line: string): boolean {
    return line.trim().startsWith('@');
  }
}


================================================
FILE: src/scanner/parsers/extractors/typescript/TypeScriptContentExtractor.ts
================================================
import * as path from 'path';
import { parse } from '@typescript-eslint/parser';
import { AST_NODE_TYPES, TSESTree } from '@typescript-eslint/types';
import { 
  BaseContentExtractor, 
  ContentExtractionResult, 
  ParsedClass, 
  ParsedInterface, 
  ParsedMethod, 
  ParsedField, 
  ParsedEnum, 
  ParsedImport,
  ParsedParameter 
} from '../base/ContentExtractor.js';

export class TypeScriptContentExtractor extends BaseContentExtractor {
  extractContent(content: string, filePath: string): ContentExtractionResult {
    const result: ContentExtractionResult = {
      moduleName: this.getModuleFromPath(filePath),
      imports: [],
      classes: [],
      interfaces: [],
      enums: [],
      functions: [],
      fields: [],
      exceptions: []
    };

    try {
      const ast = parse(content, {
        ecmaVersion: 'latest',
        sourceType: 'module',
        ecmaFeatures: {
          jsx: true,
          globalReturn: false,
        },
        loc: true,
        range: true,
      });

      this.visitNode(ast, result, content);
      
      // Separate exceptions from regular classes
      result.exceptions = result.classes.filter(cls => 
        cls.extends?.some(parent => parent.includes('Error')) ||
        cls.name.endsWith('Error')
      );

    } catch (error) {
      console.warn(`Failed to parse TypeScript file ${filePath}:`, error);
    }

    return result;
  }

  private visitNode(node: any, result: ContentExtractionResult, content: string): void {
    if (!node || typeof node !== 'object') return;

    switch (node.type) {
      case AST_NODE_TYPES.ImportDeclaration:
        result.imports.push(this.handleImportDeclaration(node));
        break;
      case AST_NODE_TYPES.ClassDeclaration:
        if (node.id?.name) {
          result.classes.push(this.handleClassDeclaration(node, content));
        }
        break;
      case AST_NODE_TYPES.TSInterfaceDeclaration:
        result.interfaces.push(this.handleInterfaceDeclaration(node, content));
        break;
      case AST_NODE_TYPES.TSEnumDeclaration:
        result.enums.push(this.handleEnumDeclaration(node, content));
        break;
      case AST_NODE_TYPES.FunctionDeclaration:
        if (node.id?.name) {
          result.functions.push(this.handleFunctionDeclaration(node, content));
        }
        break;
      case AST_NODE_TYPES.VariableDeclaration:
        result.fields.push(...this.handleVariableDeclaration(node, content));
        break;
    }

    // Recursively visit child nodes
    for (const key in node) {
      const child = node[key];
      if (Array.isArray(child)) {
        for (const item of child) {
          this.visitNode(item, result, content);
        }
      } else if (typeof child === 'object' && child !== null) {
        this.visitNode(child, result, content);
      }
    }
  }

  private handleImportDeclaration(node: TSESTree.ImportDeclaration): ParsedImport {
    const source = node.source.value as string;
    const items: string[] = [];
    let isDefault = false;

    if (node.specifiers) {
      for (const specifier of node.specifiers) {
        switch (specifier.type) {
          case AST_NODE_TYPES.ImportDefaultSpecifier:
            items.push(specifier.local.name);
            isDefault = true;
            break;
          case AST_NODE_TYPES.ImportSpecifier:
            items.push(specifier.imported.name);
            break;
          case AST_NODE_TYPES.ImportNamespaceSpecifier:
            items.push('*');
            break;
        }
      }
    }

    return {
      module: source,
      items,
      isDefault
    };
  }

  private handleClassDeclaration(node: TSESTree.ClassDeclaration, content: string): ParsedClass {
    const className = node.id?.name || 'Anonymous';
    const modifiers = this.extractModifiers(node);
    const location = this.getLocation(node);

    const parsedClass: ParsedClass = {
      name: className,
      modifiers,
      startLine: location.start,
      endLine: location.end
    };

    // Handle inheritance
    if (node.superClass) {
      if (node.superClass.type === AST_NODE_TYPES.Identifier) {
        parsedClass.extends = [node.superClass.name];
      }
    }

    // Handle implements
    if (node.implements) {
      parsedClass.implements = node.implements.map(impl => {
        if (impl.expression.type === AST_NODE_TYPES.Identifier) {
          return impl.expression.name;
        }
        return 'Unknown';
      });
    }

    return parsedClass;
  }

  private handleInterfaceDeclaration(node: TSESTree.TSInterfaceDeclaration, content: string): ParsedInterface {
    const interfaceName = node.id.name;
    const modifiers = this.extractModifiers(node);
    const location = this.getLocation(node);

    const parsedInterface: ParsedInterface = {
      name: interfaceName,
      modifiers,
      startLine: location.start,
      endLine: location.end
    };

    // Handle extends
    if (node.extends) {
      parsedInterface.extends = node.extends.map(extend => {
        if (extend.expression.type === AST_NODE_TYPES.Identifier) {
          return extend.expression.name;
        }
        return 'Unknown';
      });
    }

    return parsedInterface;
  }

  private handleEnumDeclaration(node: TSESTree.TSEnumDeclaration, content: string): ParsedEnum {
    const enumName = node.id.name;
    const modifiers = this.extractModifiers(node);
    const location = this.getLocation(node);

    const values = node.members.map(member => {
      if (member.id.type === AST_NODE_TYPES.Identifier) {
        return member.id.name;
      }
      return 'Unknown';
    });

    return {
      name: enumName,
      values,
      modifiers,
      startLine: location.start,
      endLine: location.end
    };
  }

  private handleFunctionDeclaration(node: TSESTree.FunctionDeclaration, content: string): ParsedMethod {
    const functionName = node.id?.name || 'Anonymous';
    const modifiers = this.extractModifiers(node);
    const location = this.getLocation(node);
    const parameters = this.extractParameters(node.params);

    let returnType: string | undefined;
    if (node.returnType) {
      returnType = this.getTypeAnnotation(node.returnType);
    }

    return {
      name: functionName,
      parameters,
      returnType,
      modifiers,
      startLine: location.start,
      endLine: location.end
    };
  }

  private handleVariableDeclaration(node: TSESTree.VariableDeclaration, content: string): ParsedField[] {
    const fields: ParsedField[] = [];
    const location = this.getLocation(node);

    for (const declarator of node.declarations) {
      if (declarator.id.type === AST_NODE_TYPES.Identifier) {
        const fieldName = declarator.id.name;
        let type: string | undefined;

        if (declarator.id.typeAnnotation) {
          type = this.getTypeAnnotation(declarator.id.typeAnnotation);
        }

        fields.push({
          name: fieldName,
          type,
          modifiers: [node.kind], // var, let, const
          startLine: location.start,
          endLine: location.end
        });
      }
    }

    return fields;
  }

  private extractModifiers(node: any): string[] {
    const modifiers: string[] = [];

    if (node.accessibility) {
      modifiers.push(node.accessibility);
    }

    if (node.static) {
      modifiers.push('static');
    }

    if (node.readonly) {
      modifiers.push('readonly');
    }

    if (node.abstract) {
      modifiers.push('abstract');
    }

    if (node.async) {
      modifiers.push('async');
    }

    if (node.export) {
      modifiers.push('export');
    }

    return modifiers;
  }

  private extractParameters(params: TSESTree.Parameter[]): ParsedParameter[] {
    return params.map(param => this.parseParameterFromAst(param)).filter(Boolean) as ParsedParameter[];
  }

  private parseParameterFromAst(param: TSESTree.Parameter): ParsedParameter | null {
    if (param.type === AST_NODE_TYPES.Identifier) {
      const name = param.name;
      let type: string | undefined;
      let isOptional = false;

      if (param.typeAnnotation) {
        type = this.getTypeAnnotation(param.typeAnnotation);
      }

      if (param.optional) {
        isOptional = true;
      }

      return {
        name,
        type,
        isOptional
      };
    }

    return null;
  }

  protected parseParameter(param: string): ParsedParameter | null {
    // This method is used by the base class but we override parameter parsing
    // for TypeScript since we use AST-based parsing
    const trimmed = param.trim();
    if (!trimmed) return null;

    const parts = trimmed.split(':');
    const name = parts[0].trim();
    const type = parts[1]?.trim();

    return {
      name,
      type,
      isOptional: name.endsWith('?')
    };
  }

  private getTypeAnnotation(typeAnnotation: any): string {
    if (!typeAnnotation || !typeAnnotation.typeAnnotation) {
      return 'unknown';
    }

    const type = typeAnnotation.typeAnnotation;
    
    switch (type.type) {
      case AST_NODE_TYPES.TSStringKeyword:
        return 'string';
      case AST_NODE_TYPES.TSNumberKeyword:
        return 'number';
      case AST_NODE_TYPES.TSBooleanKeyword:
        return 'boolean';
      case AST_NODE_TYPES.TSVoidKeyword:
        return 'void';
      case AST_NODE_TYPES.TSAnyKeyword:
        return 'any';
      case AST_NODE_TYPES.TSTypeReference:
        if (type.typeName.type === AST_NODE_TYPES.Identifier) {
          return type.typeName.name;
        }
        return 'unknown';
      default:
        return 'unknown';
    }
  }

  private getLocation(node: any): { start: number; end: number } {
    return {
      start: node.loc?.start?.line || 1,
      end: node.loc?.end?.line || 1
    };
  }

  private getModuleFromPath(filePath: string): string {
    const parsed = path.parse(filePath);
    return parsed.name;
  }
}


================================================
FILE: src/scanner/parsers/extractors/typescript/TypeScriptMethodCallExtractor.ts
================================================
import { AST_NODE_TYPES, TSESTree } from '@typescript-eslint/types';
import { 
  BaseMethodCallExtractor, 
  ParsedMethodCall, 
  MethodCallExtractionResult 
} from '../base/MethodCallExtractor.js';

export class TypeScriptMethodCallExtractor extends BaseMethodCallExtractor {
  extractMethodCalls(
    methodBody: string,
    methodName: string,
    className?: string,
    packageName?: string,
    imports?: Map<string, string>
  ): MethodCallExtractionResult {
    const calls: ParsedMethodCall[] = [];
    const errors: string[] = [];

    try {
      // For TypeScript, we can use AST-based extraction if we have the AST node
      // For now, we'll use regex-based extraction similar to Java but with TypeScript patterns
      const lines = methodBody.split('\n');

      lines.forEach((line, lineIndex) => {
        const cleanLine = this.removeCommentsAndStrings(line);
        
        // Extract method calls using TypeScript patterns
        calls.push(...this.extractInstanceCalls(cleanLine, lineIndex + 1, packageName, imports));
        calls.push(...this.extractStaticCalls(cleanLine, lineIndex + 1, packageName, imports));
        calls.push(...this.extractConstructorCalls(cleanLine, lineIndex + 1, packageName, imports));
        calls.push(...this.extractFunctionCalls(cleanLine, lineIndex + 1, className, methodName));
      });

    } catch (error) {
      errors.push(`Error extracting method calls: ${error instanceof Error ? error.message : String(error)}`);
    }

    return { calls, errors };
  }

  extractMethodCallsFromAST(
    methodBody: TSESTree.BlockStatement,
    methodName: string,
    className?: string,
    packageName?: string,
    imports?: Map<string, string>
  ): MethodCallExtractionResult {
    const calls: ParsedMethodCall[] = [];
    const errors: string[] = [];

    try {
      this.visitASTNode(methodBody, calls, packageName, imports);
    } catch (error) {
      errors.push(`Error extracting method calls from AST: ${error instanceof Error ? error.message : String(error)}`);
    }

    return { calls, errors };
  }

  private visitASTNode(
    node: TSESTree.Node, 
    calls: ParsedMethodCall[], 
    packageName?: string, 
    imports?: Map<string, string>
  ): void {
    switch (node.type) {
      case AST_NODE_TYPES.CallExpression:
        this.extractCallExpression(node, calls, packageName, imports);
        break;
      case AST_NODE_TYPES.NewExpression:
        this.extractNewExpression(node, calls, packageName, imports);
        break;
    }

    // Recursively visit child nodes
    for (const key in node) {
      const value = (node as any)[key];
      if (Array.isArray(value)) {
        value.forEach(child => {
          if (child && typeof child === 'object' && child.type) {
            this.visitASTNode(child, calls, packageName, imports);
          }
        });
      } else if (value && typeof value === 'object' && value.type) {
        this.visitASTNode(value, calls, packageName, imports);
      }
    }
  }

  private extractCallExpression(
    node: TSESTree.CallExpression, 
    calls: ParsedMethodCall[], 
    packageName?: string, 
    imports?: Map<string, string>
  ): void {
    const lineNumber = node.loc?.start.line || 0;

    if (node.callee.type === AST_NODE_TYPES.MemberExpression) {
      // Method call: object.method() or Class.method()
      const object = this.getNodeName(node.callee.object);
      const method = this.getNodeName(node.callee.property);
      
      if (object && method && this.isValidMethodCall(object, method)) {
        const callType = this.isStaticCall(object) ? 'static' : 'instance';
        calls.push({
          targetMethod: this.resolveMethodCall(object, method, packageName, imports),
          callType,
          lineNumber,
          callerObject: object
        });
      }
    } else if (node.callee.type === AST_NODE_TYPES.Identifier) {
      // Function call: function()
      const functionName = node.callee.name;
      if (this.isValidFunctionCall(functionName)) {
        calls.push({
          targetMethod: functionName,
          callType: 'function',
          lineNumber
        });
      }
    }
  }

  private extractNewExpression(
    node: TSESTree.NewExpression, 
    calls: ParsedMethodCall[], 
    packageName?: string, 
    imports?: Map<string, string>
  ): void {
    const lineNumber = node.loc?.start.line || 0;
    const className = this.getNodeName(node.callee);
    
    if (className && this.isValidConstructor(className)) {
      calls.push({
        targetMethod: this.resolveConstructorCall(className, packageName, imports),
        callType: 'constructor',
        lineNumber,
        callerObject: className
      });
    }
  }

  private extractInstanceCalls(
    line: string, 
    lineNumber: number, 
    packageName?: string, 
    imports?: Map<string, string>
  ): ParsedMethodCall[] {
    const calls: ParsedMethodCall[] = [];
    const pattern = /(\w+)\.(\w+)\s*\(/g;
    let match;

    while ((match = pattern.exec(line)) !== null) {
      const object = match[1];
      const method = match[2];
      
      if (this.isValidMethodCall(object, method)) {
        calls.push({
          targetMethod: this.resolveMethodCall(object, method, packageName, imports),
          callType: 'instance',
          lineNumber,
          callerObject: object
        });
      }
    }

    return calls;
  }

  private extractStaticCalls(
    line: string, 
    lineNumber: number, 
    packageName?: string, 
    imports?: Map<string, string>
  ): ParsedMethodCall[] {
    const calls: ParsedMethodCall[] = [];
    const pattern = /([A-Z]\w*)\.(\w+)\s*\(/g;
    let match;

    while ((match = pattern.exec(line)) !== null) {
      const className = match[1];
      const method = match[2];
      
      if (this.isValidMethodCall(className, method)) {
        calls.push({
          targetMethod: this.resolveStaticMethodCall(className, method, packageName, imports),
          callType: 'static',
          lineNumber,
          callerObject: className
        });
      }
    }

    return calls;
  }

  private extractConstructorCalls(
    line: string, 
    lineNumber: number, 
    packageName?: string, 
    imports?: Map<string, string>
  ): ParsedMethodCall[] {
    const calls: ParsedMethodCall[] = [];
    const pattern = /new\s+([A-Z]\w*)\s*\(/g;
    let match;

    while ((match = pattern.exec(line)) !== null) {
      const className = match[1];
      
      if (this.isValidConstructor(className)) {
        calls.push({
          targetMethod: this.resolveConstructorCall(className, packageName, imports),
          callType: 'constructor',
          lineNumber,
          callerObject: className
        });
      }
    }

    return calls;
  }

  private extractFunctionCalls(
    line: string, 
    lineNumber: number, 
    className?: string,
    currentMethodName?: string
  ): ParsedMethodCall[] {
    const calls: ParsedMethodCall[] = [];
    const pattern = /(?:^|[^\w.])(\w+)\s*\(/g;
    let match;

    while ((match = pattern.exec(line)) !== null) {
      const functionName = match[1];
      
      // Skip the current method itself and common keywords
      if (functionName !== currentMethodName && this.isValidFunctionCall(functionName)) {
        const targetMethod = className ? `${className}.${functionName}` : functionName;
        calls.push({
          targetMethod,
          callType: 'function',
          lineNumber
        });
      }
    }

    return calls;
  }

  private getNodeName(node: TSESTree.Node | null): string | null {
    if (!node) return null;
    
    switch (node.type) {
      case AST_NODE_TYPES.Identifier:
        return node.name;
      case AST_NODE_TYPES.MemberExpression:
        const object = this.getNodeName(node.object);
        const property = this.getNodeName(node.property);
        return object && property ? `${object}.${property}` : null;
      default:
        return null;
    }
  }

  protected removeCommentsAndStrings(line: string): string {
    let result = line;
    
    // Remove string literals
    result = result.replace(/"([^"\\]|\\.)*"/g, '""');
    result = result.replace(/'([^'\\]|\\.)*'/g, "''");
    result = result.replace(/`([^`\\]|\\.)*`/g, '``'); // Template literals
    
    // Remove line comments
    const commentIndex = result.indexOf('//');
    if (commentIndex !== -1) {
      result = result.substring(0, commentIndex);
    }
    
    return result;
  }

  protected isValidMethodCall(object: string, method: string): boolean {
    // Skip common false positives
    const skipObjects = ['console', 'window', 'document', 'JSON', 'Math', 'Object', 'Array'];
    const skipMethods = ['log', 'error', 'warn', 'info', 'debug'];
    
    return !skipObjects.includes(object) || !skipMethods.includes(method);
  }

  protected isValidFunctionCall(functionName: string): boolean {
    // Skip common built-in functions and keywords
    const skipFunctions = ['setTimeout', 'setInterval', 'clearTimeout', 'clearInterval', 
                          'parseInt', 'parseFloat', 'isNaN', 'isFinite', 'require', 'import',
                          'if', 'for', 'while', 'switch', 'try', 'catch', 'finally', 'return', 'throw'];
    
    return !skipFunctions.includes(functionName);
  }

  private isValidConstructor(className: string): boolean {
    // Skip common built-in types
    const builtinTypes = ['Object', 'Array', 'String', 'Number', 'Boolean', 'Date', 'RegExp', 'Error', 'Promise'];
    return !builtinTypes.includes(className);
  }

  protected resolveMethodCall(
    object: string, 
    method: string, 
    packageName?: string, 
    imports?: Map<string, string>
  ): string {
    // Enhanced resolution for TypeScript/JavaScript
    if (object === 'this') {
      return packageName ? `${packageName}.${method}` : method;
    }
    
    return `${object}.${method}`;
  }

  protected resolveConstructorCall(
    className: string, 
    packageName?: string, 
    imports?: Map<string, string>
  ): string {
    // Check imports first
    if (imports?.has(className)) {
      return `${imports.get(className)}.constructor`;
    }
    
    // Use package name if available
    return packageName ? `${packageName}.${className}.constructor` : `${className}.constructor`;
  }
}


================================================
FILE: src/scanner/parsers/framework-detection/FrameworkDetectionTypes.ts
================================================
import { ParsedImport } from '../extractors/base/ContentExtractor.js';

/**
 * Result of framework detection with confidence scoring
 */
export interface FrameworkDetectionResult {
  framework: string | null;
  confidence: number; // 0-100, higher is more confident
  detectionMethod: 'annotation' | 'import' | 'combined';
  details?: {
    matchedAnnotations?: string[];
    matchedImports?: string[];
    ambiguousAnnotations?: string[];
  };
}

/**
 * Import pattern for framework detection
 */
export interface ImportPattern {
  pattern: string; // Package pattern (supports wildcards with *)
  confidence: number; // Confidence boost when this pattern matches
  framework: string; // Framework name this pattern indicates
}

/**
 * Context for framework detection including both annotations and imports
 */
export interface FrameworkDetectionContext {
  annotations: string[];
  imports: ParsedImport[];
  filePath?: string;
}


================================================
FILE: src/scanner/parsers/framework-detection/FrameworkDetector.ts
================================================
export interface FrameworkDetector {
  detectFramework(annotationName: string): string | undefined;
  categorizeAnnotation(annotationName: string): string | undefined;
  getSupportedFrameworks(): string[];
  getSupportedCategories(): string[];
}

export abstract class BaseFrameworkDetector implements FrameworkDetector {
  protected abstract frameworkMap: Record<string, string>;
  protected abstract categoryMap: Record<string, string>;

  detectFramework(annotationName: string): string | undefined {
    return this.frameworkMap[annotationName];
  }

  categorizeAnnotation(annotationName: string): string | undefined {
    return this.categoryMap[annotationName];
  }

  getSupportedFrameworks(): string[] {
    return Array.from(new Set(Object.values(this.frameworkMap)));
  }

  getSupportedCategories(): string[] {
    return Array.from(new Set(Object.values(this.categoryMap)));
  }
}


================================================
FILE: src/scanner/parsers/framework-detection/FrameworkModule.ts
================================================
import { 
  FrameworkDetectionResult, 
  FrameworkDetectionContext, 
  ImportPattern 
} from './FrameworkDetectionTypes.js';
import { ParsedImport } from '../extractors/base/ContentExtractor.js';

/**
 * Abstract base class for framework modules.
 * Each framework (e.g., Spring Boot, Angular, Flask) should extend this class.
 */
export abstract class FrameworkModule {
  protected frameworkMap: Map<string, string> = new Map();
  protected categoryMap: Map<string, string> = new Map();
  protected importPatterns: ImportPattern[] = [];

  /**
   * Get the name of this framework
   */
  abstract getFrameworkName(): string;

  /**
   * Get all supported annotations for this framework
   */
  getSupportedAnnotations(): string[] {
    return Array.from(this.frameworkMap.keys());
  }

  /**
   * Get all supported categories for this framework
   */
  getSupportedCategories(): string[] {
    return Array.from(new Set(this.categoryMap.values()));
  }

  /**
   * Detect if an annotation belongs to this framework
   */
  detectFramework(annotation: string): string | null {
    return this.frameworkMap.get(annotation) || null;
  }

  /**
   * Get the category for an annotation
   */
  categorizeAnnotation(annotation: string): string | null {
    return this.categoryMap.get(annotation) || null;
  }

  /**
   * Get the framework map for this module
   */
  getFrameworkMap(): Map<string, string> {
    return new Map(this.frameworkMap);
  }

  /**
   * Get the category map for this module
   */
  getCategoryMap(): Map<string, string> {
    return new Map(this.categoryMap);
  }

  /**
   * Initialize the framework mappings
   * This method should be called in the constructor of concrete implementations
   */
  protected abstract initializeMappings(): void;

  /**
   * Detect framework from import patterns
   */
  detectFrameworkFromImports(imports: ParsedImport[]): FrameworkDetectionResult {
    let bestMatch: { framework: string; confidence: number } | null = null;
    const matchedImports: string[] = [];

    for (const importItem of imports) {
      for (const pattern of this.importPatterns) {
        if (this.matchesImportPattern(importItem.module, pattern.pattern)) {
          matchedImports.push(importItem.module);
          
          if (!bestMatch || pattern.confidence > bestMatch.confidence) {
            bestMatch = {
              framework: pattern.framework,
              confidence: pattern.confidence
            };
          }
        }
      }
    }

    if (bestMatch) {
      return {
        framework: bestMatch.framework,
        confidence: bestMatch.confidence,
        detectionMethod: 'import',
        details: {
          matchedImports
        }
      };
    }

    return {
      framework: null,
      confidence: 0,
      detectionMethod: 'import'
    };
  }

  /**
   * Enhanced framework detection using both annotations and imports
   */
  detectFrameworkWithContext(context: FrameworkDetectionContext): FrameworkDetectionResult {
    const annotationResult = this.detectFrameworkFromAnnotations(context.annotations);
    const importResult = this.detectFrameworkFromImports(context.imports);

    // If both methods agree on the framework, combine confidence
    if (annotationResult.framework === importResult.framework && annotationResult.framework) {
      return {
        framework: annotationResult.framework,
        confidence: Math.min(100, annotationResult.confidence + importResult.confidence),
        detectionMethod: 'combined',
        details: {
          matchedAnnotations: annotationResult.details?.matchedAnnotations,
          matchedImports: importResult.details?.matchedImports
        }
      };
    }

    // Return the result with higher confidence
    if (importResult.confidence > annotationResult.confidence) {
      return importResult;
    }

    return annotationResult;
  }

  /**
   * Detect framework from annotations with confidence scoring
   */
  detectFrameworkFromAnnotations(annotations: string[]): FrameworkDetectionResult {
    const matchedAnnotations: string[] = [];
    const frameworkCounts = new Map<string, number>();

    for (const annotation of annotations) {
      const framework = this.frameworkMap.get(annotation);
      if (framework) {
        matchedAnnotations.push(annotation);
        frameworkCounts.set(framework, (frameworkCounts.get(framework) || 0) + 1);
      }
    }

    if (frameworkCounts.size === 0) {
      return {
        framework: null,
        confidence: 0,
        detectionMethod: 'annotation'
      };
    }

    // Find framework with most matches
    let bestFramework = '';
    let maxCount = 0;
    for (const [framework, count] of frameworkCounts) {
      if (count > maxCount) {
        bestFramework = framework;
        maxCount = count;
      }
    }

    // Calculate confidence based on number of matches and specificity
    const confidence = Math.min(90, maxCount * 20); // Cap at 90 to leave room for import boost

    return {
      framework: bestFramework,
      confidence,
      detectionMethod: 'annotation',
      details: {
        matchedAnnotations
      }
    };
  }

  /**
   * Check if an import module matches a pattern
   */
  private matchesImportPattern(module: string, pattern: string): boolean {
    // Convert pattern to regex (handle wildcards)
    const regexPattern = pattern
      .replace(/\./g, '\\.')
      .replace(/\*/g, '.*')
      + '$';
    
    const regex = new RegExp(regexPattern);
    return regex.test(module);
  }

  /**
   * Get import patterns for this framework
   */
  getImportPatterns(): ImportPattern[] {
    return [...this.importPatterns];
  }

  /**
   * Add an import pattern for framework detection
   */
  protected addImportPattern(pattern: string, confidence: number, framework?: string): void {
    this.importPatterns.push({
      pattern,
      confidence,
      framework: framework || this.getFrameworkName()
    });
  }
}


================================================
FILE: src/scanner/parsers/framework-detection/PythonFrameworkDetector.ts
================================================
import { BaseFrameworkDetector } from './FrameworkDetector.js';

export class PythonFrameworkDetector extends BaseFrameworkDetector {
  protected frameworkMap: Record<string, string> = {
    // Flask
    'app.route': 'Flask',
    'route': 'Flask',
    'before_request': 'Flask',
    'after_request': 'Flask',
    'teardown_request': 'Flask',
    'context_processor': 'Flask',
    'template_filter': 'Flask',
    'template_global': 'Flask',
    
    // Django
    'login_required': 'Django',
    'permission_required': 'Django',
    'user_passes_test': 'Django',
    'csrf_exempt': 'Django',
    'require_http_methods': 'Django',
    'require_GET': 'Django',
    'require_POST': 'Django',
    'require_safe': 'Django',
    'cache_page': 'Django',
    'never_cache': 'Django',
    'vary_on_headers': 'Django',
    'vary_on_cookie': 'Django',
    
    // FastAPI
    'app.get': 'FastAPI',
    'app.post': 'FastAPI',
    'app.put': 'FastAPI',
    'app.delete': 'FastAPI',
    'app.patch': 'FastAPI',
    'app.options': 'FastAPI',
    'app.head': 'FastAPI',
    'app.trace': 'FastAPI',
    'Depends': 'FastAPI',
    'HTTPException': 'FastAPI',
    
    // Pytest
    'pytest.fixture': 'Pytest',
    'pytest.mark.parametrize': 'Pytest',
    'pytest.mark.skip': 'Pytest',
    'pytest.mark.skipif': 'Pytest',
    'pytest.mark.xfail': 'Pytest',
    'pytest.mark.slow': 'Pytest',
    'fixture': 'Pytest',
    'mark.parametrize': 'Pytest',
    'mark.skip': 'Pytest',
    'mark.skipif': 'Pytest',
    'mark.xfail': 'Pytest',
    
    // Celery
    'task': 'Celery',
    'periodic_task': 'Celery',
    'shared_task': 'Celery',
    
    // SQLAlchemy
    'validates': 'SQLAlchemy',
    'reconstructor': 'SQLAlchemy',
    'hybrid_property': 'SQLAlchemy',
    'hybrid_method': 'SQLAlchemy',
    
    // Pydantic
    'validator': 'Pydantic',
    'root_validator': 'Pydantic',
    'field_validator': 'Pydantic',
    'model_validator': 'Pydantic',
    
    // Python Core
    'property': 'Python',
    'staticmethod': 'Python',
    'classmethod': 'Python',
    'cached_property': 'Python',
    'lru_cache': 'Python',
    'singledispatch': 'Python',
    'wraps': 'Python',
    'dataclass': 'Python',
    'total_ordering': 'Python',
    
    // Click
    'click.command': 'Click',
    'click.group': 'Click',
    'click.option': 'Click',
    'click.argument': 'Click',
    'command': 'Click',
    'group': 'Click',
    'option': 'Click',
    'argument': 'Click',
    
    // Typing
    'overload': 'Typing',
    'final': 'Typing',
    'runtime_checkable': 'Typing',
    
    // Deprecated
    'deprecated': 'Deprecated'
  };

  protected categoryMap: Record<string, string> = {
    // Web
    'app.route': 'web',
    'route': 'web',
    'app.get': 'web',
    'app.post': 'web',
    'app.put': 'web',
    'app.delete': 'web',
    'app.patch': 'web',
    'app.options': 'web',
    'app.head': 'web',
    'app.trace': 'web',
    'require_http_methods': 'web',
    'require_GET': 'web',
    'require_POST': 'web',
    'require_safe': 'web',
    'HTTPException': 'web',
    
    // Security
    'login_required': 'security',
    'permission_required': 'security',
    'user_passes_test': 'security',
    'csrf_exempt': 'security',
    
    // Caching
    'cache_page': 'caching',
    'never_cache': 'caching',
    'vary_on_headers': 'caching',
    'vary_on_cookie': 'caching',
    'cached_property': 'caching',
    'lru_cache': 'caching',
    
    // Testing
    'pytest.fixture': 'testing',
    'pytest.mark.parametrize': 'testing',
    'pytest.mark.skip': 'testing',
    'pytest.mark.skipif': 'testing',
    'pytest.mark.xfail': 'testing',
    'pytest.mark.slow': 'testing',
    'fixture': 'testing',
    'mark.parametrize': 'testing',
    'mark.skip': 'testing',
    'mark.skipif': 'testing',
    'mark.xfail': 'testing',
    
    // Persistence
    'validates': 'persistence',
    'reconstructor': 'persistence',
    'hybrid_property': 'persistence',
    'hybrid_method': 'persistence',
    
    // Validation
    'validator': 'validation',
    'root_validator': 'validation',
    'field_validator': 'validation',
    'model_validator': 'validation',
    
    // Language
    'property': 'language',
    'staticmethod': 'language',
    'classmethod': 'language',
    'singledispatch': 'language',
    'wraps': 'language',
    'dataclass': 'language',
    'total_ordering': 'language',
    'overload': 'language',
    'final': 'language',
    'runtime_checkable': 'language',
    'deprecated': 'language',
    
    // Lifecycle
    'before_request': 'lifecycle',
    'after_request': 'lifecycle',
    'teardown_request': 'lifecycle',
    'context_processor': 'lifecycle',
    
    // Async
    'task': 'async',
    'periodic_task': 'async',
    'shared_task': 'async',
    
    // CLI
    'click.command': 'cli',
    'click.group': 'cli',
    'click.option': 'cli',
    'click.argument': 'cli',
    'command': 'cli',
    'group': 'cli',
    'option': 'cli',
    'argument': 'cli',
    
    // Utility
    'Depends': 'utility',
    
    // Template
    'template_filter': 'template',
    'template_global': 'template'
  };
}


================================================
FILE: src/scanner/parsers/framework-detection/java/JavaFrameworkDetector.ts
================================================
import { BaseFrameworkDetector } from '../FrameworkDetector.js';
import { FrameworkModule } from '../FrameworkModule.js';
import { 
  FrameworkDetectionResult, 
  FrameworkDetectionContext 
} from '../FrameworkDetectionTypes.js';
import { ParsedImport } from '../../extractors/base/ContentExtractor.js';
import { SpringBootFramework } from './frameworks/SpringBootFramework.js';
import { JPAFramework } from './frameworks/JPAFramework.js';
import { JUnitFramework } from './frameworks/JUnitFramework.js';
import { MockitoFramework } from './frameworks/MockitoFramework.js';
import { BeanValidationFramework } from './frameworks/BeanValidationFramework.js';
import { LombokFramework } from './frameworks/LombokFramework.js';
import { JavaCoreFramework } from './frameworks/JavaCoreFramework.js';

/**
 * Java framework detector that aggregates multiple framework modules
 */
export class JavaFrameworkDetector extends BaseFrameworkDetector {
  private frameworkModules: FrameworkModule[];
  protected frameworkMap: Record<string, string> = {};
  protected categoryMap: Record<string, string> = {};

  constructor() {
    super();
    this.frameworkModules = [
      new SpringBootFramework(),
      new JPAFramework(),
      new JUnitFramework(),
      new MockitoFramework(),
      new BeanValidationFramework(),
      new LombokFramework(),
      new JavaCoreFramework()
    ];
    this.initializeMaps();
  }

  /**
   * Initialize the aggregated framework and category maps from all modules
   */
  private initializeMaps(): void {
    for (const module of this.frameworkModules) {
      // Merge framework maps
      const moduleFrameworkMap = module.getFrameworkMap();
      for (const [annotation, framework] of moduleFrameworkMap) {
        this.frameworkMap[annotation] = framework;
      }

      // Merge category maps
      const moduleCategoryMap = module.getCategoryMap();
      for (const [annotation, category] of moduleCategoryMap) {
        this.categoryMap[annotation] = category;
      }
    }
  }

  /**
   * Get all framework modules
   */
  getFrameworkModules(): FrameworkModule[] {
    return [...this.frameworkModules];
  }

  /**
   * Get a specific framework module by name
   */
  getFrameworkModule(frameworkName: string): FrameworkModule | undefined {
    return this.frameworkModules.find(module => 
      module.getFrameworkName() === frameworkName
    );
  }

  /**
   * Add a new framework module
   */
  addFrameworkModule(module: FrameworkModule): void {
    this.frameworkModules.push(module);
    
    // Update maps with new module data
    const moduleFrameworkMap = module.getFrameworkMap();
    for (const [annotation, framework] of moduleFrameworkMap) {
      this.frameworkMap[annotation] = framework;
    }

    const moduleCategoryMap = module.getCategoryMap();
    for (const [annotation, category] of moduleCategoryMap) {
      this.categoryMap[annotation] = category;
    }
  }

  /**
   * Remove a framework module by name
   */
  removeFrameworkModule(frameworkName: string): boolean {
    const index = this.frameworkModules.findIndex(module => 
      module.getFrameworkName() === frameworkName
    );
    
    if (index === -1) {
      return false;
    }

    this.frameworkModules.splice(index, 1);
    this.reinitializeMaps();
    return true;
  }

  /**
   * Reinitialize maps after module removal
   */
  private reinitializeMaps(): void {
    this.frameworkMap = {};
    this.categoryMap = {};
    this.initializeMaps();
  }

  /**
   * Enhanced framework detection using both annotations and imports
   */
  detectFrameworkWithContext(context: FrameworkDetectionContext): FrameworkDetectionResult {
    const results: FrameworkDetectionResult[] = [];
    
    // Get detection results from all framework modules
    for (const module of this.frameworkModules) {
      const result = module.detectFrameworkWithContext(context);
      if (result.framework && result.confidence > 0) {
        results.push(result);
      }
    }

    if (results.length === 0) {
      return {
        framework: null,
        confidence: 0,
        detectionMethod: 'combined'
      };
    }

    // Return the result with highest confidence
    return results.reduce((best, current) => 
      current.confidence > best.confidence ? current : best
    );
  }

  /**
   * Detect framework from imports across all modules
   */
  detectFrameworkFromImports(imports: ParsedImport[]): FrameworkDetectionResult {
    const results: FrameworkDetectionResult[] = [];
    
    for (const module of this.frameworkModules) {
      const result = module.detectFrameworkFromImports(imports);
      if (result.framework && result.confidence > 0) {
        results.push(result);
      }
    }

    if (results.length === 0) {
      return {
        framework: null,
        confidence: 0,
        detectionMethod: 'import'
      };
    }

    // Return the result with highest confidence
    return results.reduce((best, current) => 
      current.confidence > best.confidence ? current : best
    );
  }

  /**
   * Get statistics about loaded framework modules
   */
  getFrameworkStatistics(): {
    totalModules: number;
    totalAnnotations: number;
    totalImportPatterns: number;
    moduleBreakdown: Array<{
      name: string;
      annotationCount: number;
      categoryCount: number;
      importPatternCount: number;
    }>;
  } {
    const moduleBreakdown = this.frameworkModules.map(module => ({
      name: module.getFrameworkName(),
      annotationCount: module.getSupportedAnnotations().length,
      categoryCount: module.getSupportedCategories().length,
      importPatternCount: module.getImportPatterns().length
    }));

    const totalImportPatterns = this.frameworkModules.reduce(
      (total, module) => total + module.getImportPatterns().length, 
      0
    );

    return {
      totalModules: this.frameworkModules.length,
      totalAnnotations: Object.keys(this.frameworkMap).length,
      totalImportPatterns,
      moduleBreakdown
    };
  }
}


================================================
FILE: src/scanner/parsers/framework-detection/java/frameworks/AxonFramework.ts
================================================
import { FrameworkModule } from '../../FrameworkModule.js';

/**
 * Axon Framework detection module
 * Handles CQRS, Event Sourcing, and DDD annotations from AxonIQ
 */
export class AxonFramework extends FrameworkModule {
  constructor() {
    super();
    this.initializeMappings();
  }

  getFrameworkName(): string {
    return 'Axon Framework';
  }

  protected initializeMappings(): void {
    this.initializeAnnotationMappings();
    this.initializeImportPatterns();
  }

  private initializeAnnotationMappings(): void {
    // Axon Core Annotations
    this.frameworkMap.set('Aggregate', 'Axon Framework');
    this.frameworkMap.set('AggregateRoot', 'Axon Framework');
    this.frameworkMap.set('AggregateIdentifier', 'Axon Framework');
    this.frameworkMap.set('CommandHandler', 'Axon Framework');
    this.frameworkMap.set('EventHandler', 'Axon Framework');
    this.frameworkMap.set('QueryHandler', 'Axon Framework');
    this.frameworkMap.set('EventSourcingHandler', 'Axon Framework');
    this.frameworkMap.set('CreationPolicy', 'Axon Framework');
    this.frameworkMap.set('AggregateMember', 'Axon Framework');

    // Axon Command Model
    this.frameworkMap.set('TargetAggregateIdentifier', 'Axon Framework');
    this.frameworkMap.set('TargetAggregateVersion', 'Axon Framework');
    this.frameworkMap.set('CommandHandlerInterceptor', 'Axon Framework');
    this.frameworkMap.set('RoutingKey', 'Axon Framework');

    // Axon Event Model
    this.frameworkMap.set('EventBus', 'Axon Framework');
    this.frameworkMap.set('DomainEvent', 'Axon Framework');
    this.frameworkMap.set('EventHandlerInterceptor', 'Axon Framework');
    this.frameworkMap.set('ReplayStatus', 'Axon Framework');
    this.frameworkMap.set('SequenceNumber', 'Axon Framework');
    this.frameworkMap.set('Timestamp', 'Axon Framework');

    // Axon Query Model
    this.frameworkMap.set('QueryHandlerInterceptor', 'Axon Framework');
    this.frameworkMap.set('MetaDataValue', 'Axon Framework');

    // Axon Saga
    this.frameworkMap.set('Saga', 'Axon Framework');
    this.frameworkMap.set('SagaOrchestrationStart', 'Axon Framework');
    this.frameworkMap.set('SagaOrchestrationEnd', 'Axon Framework');
    this.frameworkMap.set('StartSaga', 'Axon Framework');
    this.frameworkMap.set('EndSaga', 'Axon Framework');
    this.frameworkMap.set('SagaStart', 'Axon Framework');

    // Axon Spring Integration
    this.frameworkMap.set('ProcessingGroup', 'Axon Framework');
    this.frameworkMap.set('Component', 'Axon Framework');

    // Axon Test Support
    this.frameworkMap.set('AxonTest', 'Axon Framework');

    // Categories
    this.categoryMap.set('Aggregate', 'ddd');
    this.categoryMap.set('AggregateRoot', 'ddd');
    this.categoryMap.set('AggregateIdentifier', 'ddd');
    this.categoryMap.set('AggregateMember', 'ddd');
    
    this.categoryMap.set('CommandHandler', 'cqrs');
    this.categoryMap.set('QueryHandler', 'cqrs');
    this.categoryMap.set('TargetAggregateIdentifier', 'cqrs');
    this.categoryMap.set('TargetAggregateVersion', 'cqrs');
    this.categoryMap.set('CommandHandlerInterceptor', 'cqrs');
    this.categoryMap.set('QueryHandlerInterceptor', 'cqrs');
    this.categoryMap.set('RoutingKey', 'cqrs');
    
    this.categoryMap.set('EventHandler', 'event-sourcing');
    this.categoryMap.set('EventSourcingHandler', 'event-sourcing');
    this.categoryMap.set('DomainEvent', 'event-sourcing');
    this.categoryMap.set('EventBus', 'event-sourcing');
    this.categoryMap.set('EventHandlerInterceptor', 'event-sourcing');
    this.categoryMap.set('ReplayStatus', 'event-sourcing');
    this.categoryMap.set('SequenceNumber', 'event-sourcing');
    this.categoryMap.set('Timestamp', 'event-sourcing');
    
    this.categoryMap.set('Saga', 'saga');
    this.categoryMap.set('SagaOrchestrationStart', 'saga');
    this.categoryMap.set('SagaOrchestrationEnd', 'saga');
    this.categoryMap.set('StartSaga', 'saga');
    this.categoryMap.set('EndSaga', 'saga');
    this.categoryMap.set('SagaStart', 'saga');
    
    this.categoryMap.set('ProcessingGroup', 'configuration');
    this.categoryMap.set('Component', 'configuration');
    this.categoryMap.set('CreationPolicy', 'configuration');
    this.categoryMap.set('MetaDataValue', 'configuration');
    
    this.categoryMap.set('AxonTest', 'testing');
  }

  private initializeImportPatterns(): void {
    // Axon Framework Core - High confidence
    this.addImportPattern('org.axonframework.*', 95, 'Axon Framework');
    this.addImportPattern('org.axonframework.commandhandling.*', 95, 'Axon Framework');
    this.addImportPattern('org.axonframework.eventhandling.*', 95, 'Axon Framework');
    this.addImportPattern('org.axonframework.queryhandling.*', 95, 'Axon Framework');
    this.addImportPattern('org.axonframework.modelling.*', 95, 'Axon Framework');
    this.addImportPattern('org.axonframework.eventsourcing.*', 95, 'Axon Framework');
    this.addImportPattern('org.axonframework.modelling.saga.*', 95, 'Axon Framework');
    
    // Axon Spring Boot Starter
    this.addImportPattern('org.axonframework.springboot.*', 95, 'Axon Framework');
    this.addImportPattern('org.axonframework.spring.*', 90, 'Axon Framework');
    
    // Axon Test Support
    this.addImportPattern('org.axonframework.test.*', 90, 'Axon Framework');
    
    // Axon Extensions
    this.addImportPattern('org.axonframework.extensions.*', 85, 'Axon Framework');
    this.addImportPattern('org.axonframework.messaging.*', 85, 'Axon Framework');
    this.addImportPattern('org.axonframework.serialization.*', 80, 'Axon Framework');
    this.addImportPattern('org.axonframework.common.*', 75, 'Axon Framework');
  }
}


================================================
FILE: src/scanner/parsers/framework-detection/java/frameworks/BeanValidationFramework.ts
================================================
import { FrameworkModule } from '../../FrameworkModule.js';

/**
 * Bean Validation framework detection module
 * Handles JSR-303/380 validation annotations
 */
export class BeanValidationFramework extends FrameworkModule {
  constructor() {
    super();
    this.initializeMappings();
  }

  getFrameworkName(): string {
    return 'Bean Validation';
  }

  protected initializeMappings(): void {
    this.initializeAnnotationMappings();
    this.initializeImportPatterns();
  }

  private initializeAnnotationMappings(): void {
    // Bean Validation Annotations
    this.frameworkMap.set('NotNull', 'Bean Validation');
    this.frameworkMap.set('NotEmpty', 'Bean Validation');
    this.frameworkMap.set('NotBlank', 'Bean Validation');
    this.frameworkMap.set('Size', 'Bean Validation');
    this.frameworkMap.set('Min', 'Bean Validation');
    this.frameworkMap.set('Max', 'Bean Validation');
    this.frameworkMap.set('Email', 'Bean Validation');
    this.frameworkMap.set('Pattern', 'Bean Validation');
    this.frameworkMap.set('Valid', 'Bean Validation');
    this.frameworkMap.set('AssertTrue', 'Bean Validation');
    this.frameworkMap.set('AssertFalse', 'Bean Validation');
    this.frameworkMap.set('DecimalMax', 'Bean Validation');
    this.frameworkMap.set('DecimalMin', 'Bean Validation');
    this.frameworkMap.set('Digits', 'Bean Validation');
    this.frameworkMap.set('Future', 'Bean Validation');
    this.frameworkMap.set('FutureOrPresent', 'Bean Validation');
    this.frameworkMap.set('Past', 'Bean Validation');
    this.frameworkMap.set('PastOrPresent', 'Bean Validation');
    this.frameworkMap.set('Negative', 'Bean Validation');
    this.frameworkMap.set('NegativeOrZero', 'Bean Validation');
    this.frameworkMap.set('Positive', 'Bean Validation');
    this.frameworkMap.set('PositiveOrZero', 'Bean Validation');

    // Categories - all are validation
    this.categoryMap.set('NotNull', 'validation');
    this.categoryMap.set('NotEmpty', 'validation');
    this.categoryMap.set('NotBlank', 'validation');
    this.categoryMap.set('Size', 'validation');
    this.categoryMap.set('Min', 'validation');
    this.categoryMap.set('Max', 'validation');
    this.categoryMap.set('Email', 'validation');
    this.categoryMap.set('Pattern', 'validation');
    this.categoryMap.set('Valid', 'validation');
    this.categoryMap.set('AssertTrue', 'validation');
    this.categoryMap.set('AssertFalse', 'validation');
    this.categoryMap.set('DecimalMax', 'validation');
    this.categoryMap.set('DecimalMin', 'validation');
    this.categoryMap.set('Digits', 'validation');
    this.categoryMap.set('Future', 'validation');
    this.categoryMap.set('FutureOrPresent', 'validation');
    this.categoryMap.set('Past', 'validation');
    this.categoryMap.set('PastOrPresent', 'validation');
    this.categoryMap.set('Negative', 'validation');
    this.categoryMap.set('NegativeOrZero', 'validation');
    this.categoryMap.set('Positive', 'validation');
    this.categoryMap.set('PositiveOrZero', 'validation');
  }

  private initializeImportPatterns(): void {
    // Bean Validation (Jakarta) - High confidence
    this.addImportPattern('jakarta.validation.*', 95, 'Bean Validation');
    this.addImportPattern('jakarta.validation.constraints.*', 95, 'Bean Validation');
    this.addImportPattern('jakarta.validation.groups.*', 85, 'Bean Validation');
    this.addImportPattern('jakarta.validation.metadata.*', 80, 'Bean Validation');

    // Bean Validation (Legacy javax) - High confidence
    this.addImportPattern('javax.validation.*', 90, 'Bean Validation');
    this.addImportPattern('javax.validation.constraints.*', 90, 'Bean Validation');
    this.addImportPattern('javax.validation.groups.*', 80, 'Bean Validation');
    this.addImportPattern('javax.validation.metadata.*', 75, 'Bean Validation');
  }
}


================================================
FILE: src/scanner/parsers/framework-detection/java/frameworks/BladeFramework.ts
================================================
import { FrameworkModule } from '../../FrameworkModule.js';

/**
 * Blade framework detection module
 * Handles lightweight, fast web framework for REST APIs and microservices
 */
export class BladeFramework extends FrameworkModule {
  constructor() {
    super();
    this.initializeMappings();
  }

  getFrameworkName(): string {
    return 'Blade';
  }

  protected initializeMappings(): void {
    this.initializeAnnotationMappings();
    this.initializeImportPatterns();
  }

  private initializeAnnotationMappings(): void {
    // Blade Route Annotations
    this.frameworkMap.set('Path', 'Blade');
    this.frameworkMap.set('GetRoute', 'Blade');
    this.frameworkMap.set('PostRoute', 'Blade');
    this.frameworkMap.set('PutRoute', 'Blade');
    this.frameworkMap.set('DeleteRoute', 'Blade');
    this.frameworkMap.set('RouteGroup', 'Blade');

    // Blade Injection Annotations
    this.frameworkMap.set('Inject', 'Blade');

    // Blade Parameter Annotations
    this.frameworkMap.set('PathParam', 'Blade');
    this.frameworkMap.set('Param', 'Blade');
    this.frameworkMap.set('BodyParam', 'Blade');
    this.frameworkMap.set('HeaderParam', 'Blade');
    this.frameworkMap.set('CookieParam', 'Blade');

    // Categories
    this.categoryMap.set('Path', 'web');
    this.categoryMap.set('GetRoute', 'web');
    this.categoryMap.set('PostRoute', 'web');
    this.categoryMap.set('PutRoute', 'web');
    this.categoryMap.set('DeleteRoute', 'web');
    this.categoryMap.set('RouteGroup', 'web');
    this.categoryMap.set('PathParam', 'web');
    this.categoryMap.set('Param', 'web');
    this.categoryMap.set('BodyParam', 'web');
    this.categoryMap.set('HeaderParam', 'web');
    this.categoryMap.set('CookieParam', 'web');

    this.categoryMap.set('Inject', 'injection');
  }

  private initializeImportPatterns(): void {
    // Blade Core - High confidence
    this.addImportPattern('com.blade.*', 95, 'Blade');
    this.addImportPattern('com.blade.mvc.*', 95, 'Blade');
    this.addImportPattern('com.blade.mvc.annotation.*', 95, 'Blade');

    // Blade HTTP
    this.addImportPattern('com.blade.mvc.http.*', 90, 'Blade');

    // Blade IoC
    this.addImportPattern('com.blade.ioc.*', 85, 'Blade');

    // Blade Kit (utilities)
    this.addImportPattern('com.blade.kit.*', 80, 'Blade');

    // Blade Validator
    this.addImportPattern('com.blade.validator.*', 80, 'Blade');

    // Blade Template
    this.addImportPattern('com.blade.mvc.view.*', 75, 'Blade');

    // Blade Exception
    this.addImportPattern('com.blade.exception.*', 75, 'Blade');
  }
}


================================================
FILE: src/scanner/parsers/framework-detection/java/frameworks/CamelFramework.ts
================================================
import { FrameworkModule } from '../../FrameworkModule.js';

/**
 * Apache Camel framework detection module
 * Handles integration framework for routing and mediation rules
 */
export class CamelFramework extends FrameworkModule {
  constructor() {
    super();
    this.initializeMappings();
  }

  getFrameworkName(): string {
    return 'Apache Camel';
  }

  protected initializeMappings(): void {
    this.initializeAnnotationMappings();
    this.initializeImportPatterns();
  }

  private initializeAnnotationMappings(): void {
    // Camel Route Annotations
    this.frameworkMap.set('Consume', 'Camel');
    this.frameworkMap.set('Produce', 'Camel');
    this.frameworkMap.set('RecipientList', 'Camel');
    this.frameworkMap.set('RoutingSlip', 'Camel');
    this.frameworkMap.set('DynamicRouter', 'Camel');

    // Camel Bean Integration
    this.frameworkMap.set('Handler', 'Camel');
    this.frameworkMap.set('Header', 'Camel');
    this.frameworkMap.set('Headers', 'Camel');
    this.frameworkMap.set('Body', 'Camel');
    this.frameworkMap.set('ExchangeException', 'Camel');
    this.frameworkMap.set('Property', 'Camel');
    this.frameworkMap.set('Properties', 'Camel');

    // Camel Expression Language
    this.frameworkMap.set('Language', 'Camel');
    this.frameworkMap.set('Simple', 'Camel');
    this.frameworkMap.set('XPath', 'Camel');
    this.frameworkMap.set('JsonPath', 'Camel');

    // Camel Endpoint Injection
    this.frameworkMap.set('EndpointInject', 'Camel');
    this.frameworkMap.set('BeanInject', 'Camel');
    this.frameworkMap.set('PropertyInject', 'Camel');

    // Camel Configuration
    this.frameworkMap.set('UriEndpoint', 'Camel');
    this.frameworkMap.set('UriParam', 'Camel');
    this.frameworkMap.set('UriParams', 'Camel');
    this.frameworkMap.set('UriPath', 'Camel');

    // Categories
    this.categoryMap.set('Consume', 'integration');
    this.categoryMap.set('Produce', 'integration');
    this.categoryMap.set('RecipientList', 'integration');
    this.categoryMap.set('RoutingSlip', 'integration');
    this.categoryMap.set('DynamicRouter', 'integration');

    this.categoryMap.set('Handler', 'bean');
    this.categoryMap.set('Header', 'bean');
    this.categoryMap.set('Headers', 'bean');
    this.categoryMap.set('Body', 'bean');
    this.categoryMap.set('ExchangeException', 'bean');
    this.categoryMap.set('Property', 'bean');
    this.categoryMap.set('Properties', 'bean');

    this.categoryMap.set('Language', 'expression');
    this.categoryMap.set('Simple', 'expression');
    this.categoryMap.set('XPath', 'expression');
    this.categoryMap.set('JsonPath', 'expression');

    this.categoryMap.set('EndpointInject', 'injection');
    this.categoryMap.set('BeanInject', 'injection');
    this.categoryMap.set('PropertyInject', 'injection');

    this.categoryMap.set('UriEndpoint', 'configuration');
    this.categoryMap.set('UriParam', 'configuration');
    this.categoryMap.set('UriParams', 'configuration');
    this.categoryMap.set('UriPath', 'configuration');
  }

  private initializeImportPatterns(): void {
    // Camel Core - High confidence
    this.addImportPattern('org.apache.camel.*', 95, 'Camel');
    this.addImportPattern('org.apache.camel.builder.*', 90, 'Camel');
    this.addImportPattern('org.apache.camel.model.*', 85, 'Camel');
    this.addImportPattern('org.apache.camel.processor.*', 85, 'Camel');

    // Camel Component
    this.addImportPattern('org.apache.camel.component.*', 85, 'Camel');

    // Camel Spring
    this.addImportPattern('org.apache.camel.spring.*', 85, 'Camel Spring');

    // Camel CDI
    this.addImportPattern('org.apache.camel.cdi.*', 85, 'Camel CDI');

    // Camel Testing
    this.addImportPattern('org.apache.camel.test.*', 90, 'Camel Test');

    // Camel Language
    this.addImportPattern('org.apache.camel.language.*', 80, 'Camel');

    // Camel Converter
    this.addImportPattern('org.apache.camel.converter.*', 80, 'Camel');

    // Camel Util
    this.addImportPattern('org.apache.camel.util.*', 75, 'Camel');

    // Camel SPI
    this.addImportPattern('org.apache.camel.spi.*', 75, 'Camel');
  }
}


================================================
FILE: src/scanner/parsers/framework-detection/java/frameworks/DropWizardFramework.ts
================================================
import { FrameworkModule } from '../../FrameworkModule.js';

/**
 * DropWizard framework detection module
 * Handles production-ready RESTful web services with minimal configuration
 */
export class DropWizardFramework extends FrameworkModule {
  constructor() {
    super();
    this.initializeMappings();
  }

  getFrameworkName(): string {
    return 'DropWizard';
  }

  protected initializeMappings(): void {
    this.initializeAnnotationMappings();
    this.initializeImportPatterns();
  }

  private initializeAnnotationMappings(): void {
    // DropWizard Core
    this.frameworkMap.set('JsonProperty', 'DropWizard');
    this.frameworkMap.set('JsonIgnore', 'DropWizard');
    this.frameworkMap.set('JsonCreator', 'DropWizard');

    // JAX-RS (DropWizard uses Jersey)
    this.frameworkMap.set('Path', 'DropWizard');
    this.frameworkMap.set('GET', 'DropWizard');
    this.frameworkMap.set('POST', 'DropWizard');
    this.frameworkMap.set('PUT', 'DropWizard');
    this.frameworkMap.set('DELETE', 'DropWizard');
    this.frameworkMap.set('PATCH', 'DropWizard');
    this.frameworkMap.set('HEAD', 'DropWizard');
    this.frameworkMap.set('OPTIONS', 'DropWizard');
    this.frameworkMap.set('Produces', 'DropWizard');
    this.frameworkMap.set('Consumes', 'DropWizard');
    this.frameworkMap.set('PathParam', 'DropWizard');
    this.frameworkMap.set('QueryParam', 'DropWizard');
    this.frameworkMap.set('HeaderParam', 'DropWizard');
    this.frameworkMap.set('FormParam', 'DropWizard');
    this.frameworkMap.set('Context', 'DropWizard');

    // DropWizard Validation
    this.frameworkMap.set('Valid', 'DropWizard');
    this.frameworkMap.set('NotNull', 'DropWizard');
    this.frameworkMap.set('NotEmpty', 'DropWizard');
    this.frameworkMap.set('Size', 'DropWizard');
    this.frameworkMap.set('Min', 'DropWizard');
    this.frameworkMap.set('Max', 'DropWizard');
    this.frameworkMap.set('Pattern', 'DropWizard');
    this.frameworkMap.set('Email', 'DropWizard');

    // DropWizard Metrics
    this.frameworkMap.set('Timed', 'DropWizard Metrics');
    this.frameworkMap.set('Metered', 'DropWizard Metrics');
    this.frameworkMap.set('Counted', 'DropWizard Metrics');
    this.frameworkMap.set('Gauge', 'DropWizard Metrics');
    this.frameworkMap.set('ExceptionMetered', 'DropWizard Metrics');
    this.frameworkMap.set('CachedGauge', 'DropWizard Metrics');

    // DropWizard Health Checks
    this.frameworkMap.set('HealthCheck', 'DropWizard Health');

    // DropWizard Auth
    this.frameworkMap.set('Auth', 'DropWizard Auth');
    this.frameworkMap.set('RolesAllowed', 'DropWizard Auth');
    this.frameworkMap.set('PermitAll', 'DropWizard Auth');
    this.frameworkMap.set('DenyAll', 'DropWizard Auth');

    // DropWizard Configuration
    this.frameworkMap.set('Configuration', 'DropWizard');

    // Categories
    this.categoryMap.set('JsonProperty', 'serialization');
    this.categoryMap.set('JsonIgnore', 'serialization');
    this.categoryMap.set('JsonCreator', 'serialization');

    this.categoryMap.set('Path', 'web');
    this.categoryMap.set('GET', 'web');
    this.categoryMap.set('POST', 'web');
    this.categoryMap.set('PUT', 'web');
    this.categoryMap.set('DELETE', 'web');
    this.categoryMap.set('PATCH', 'web');
    this.categoryMap.set('HEAD', 'web');
    this.categoryMap.set('OPTIONS', 'web');
    this.categoryMap.set('Produces', 'web');
    this.categoryMap.set('Consumes', 'web');
    this.categoryMap.set('PathParam', 'web');
    this.categoryMap.set('QueryParam', 'web');
    this.categoryMap.set('HeaderParam', 'web');
    this.categoryMap.set('FormParam', 'web');
    this.categoryMap.set('Context', 'web');

    this.categoryMap.set('Valid', 'validation');
    this.categoryMap.set('NotNull', 'validation');
    this.categoryMap.set('NotEmpty', 'validation');
    this.categoryMap.set('Size', 'validation');
    this.categoryMap.set('Min', 'validation');
    this.categoryMap.set('Max', 'validation');
    this.categoryMap.set('Pattern', 'validation');
    this.categoryMap.set('Email', 'validation');

    this.categoryMap.set('Timed', 'monitoring');
    this.categoryMap.set('Metered', 'monitoring');
    this.categoryMap.set('Counted', 'monitoring');
    this.categoryMap.set('Gauge', 'monitoring');
    this.categoryMap.set('ExceptionMetered', 'monitoring');
    this.categoryMap.set('CachedGauge', 'monitoring');
    this.categoryMap.set('HealthCheck', 'monitoring');

    this.categoryMap.set('Auth', 'security');
    this.categoryMap.set('RolesAllowed', 'security');
    this.categoryMap.set('PermitAll', 'security');
    this.categoryMap.set('DenyAll', 'security');

    this.categoryMap.set('Configuration', 'configuration');
  }

  private initializeImportPatterns(): void {
    // DropWizard Core - High confidence
    this.addImportPattern('io.dropwizard.*', 95, 'DropWizard');
    this.addImportPattern('io.dropwizard.core.*', 95, 'DropWizard');
    this.addImportPattern('io.dropwizard.configuration.*', 90, 'DropWizard');

    // DropWizard Metrics
    this.addImportPattern('com.codahale.metrics.*', 85, 'DropWizard Metrics');
    this.addImportPattern('io.dropwizard.metrics.*', 90, 'DropWizard Metrics');

    // DropWizard Health
    this.addImportPattern('com.codahale.metrics.health.*', 85, 'DropWizard Health');
    this.addImportPattern('io.dropwizard.health.*', 90, 'DropWizard Health');

    // DropWizard Auth
    this.addImportPattern('io.dropwizard.auth.*', 90, 'DropWizard Auth');

    // JAX-RS (Jersey)
    this.addImportPattern('javax.ws.rs.*', 80, 'DropWizard');
    this.addImportPattern('jakarta.ws.rs.*', 85, 'DropWizard');

    // Jackson (JSON processing)
    this.addImportPattern('com.fasterxml.jackson.*', 75, 'DropWizard');

    // Validation
    this.addImportPattern('javax.validation.*', 75, 'DropWizard');
    this.addImportPattern('jakarta.validation.*', 80, 'DropWizard');

    // DropWizard DB
    this.addImportPattern('io.dropwizard.db.*', 85, 'DropWizard');
    this.addImportPattern('io.dropwizard.jdbi.*', 85, 'DropWizard');

    // DropWizard Testing
    this.addImportPattern('io.dropwizard.testing.*', 90, 'DropWizard');
  }
}


================================================
FILE: src/scanner/parsers/framework-detection/java/frameworks/GrailsFramework.ts
================================================
import { FrameworkModule } from '../../FrameworkModule.js';

/**
 * Grails framework detection module
 * Handles Groovy-based web framework with convention over configuration
 */
export class GrailsFramework extends FrameworkModule {
  constructor() {
    super();
    this.initializeMappings();
  }

  getFrameworkName(): string {
    return 'Grails';
  }

  protected initializeMappings(): void {
    this.initializeAnnotationMappings();
    this.initializeImportPatterns();
  }

  private initializeAnnotationMappings(): void {
    // Grails Artefact Annotations
    this.frameworkMap.set('Entity', 'Grails');
    this.frameworkMap.set('Resource', 'Grails');
    this.frameworkMap.set('Secured', 'Grails Security');
    
    // Grails Service Annotations
    this.frameworkMap.set('Transactional', 'Grails');

    // Grails Testing Annotations
    this.frameworkMap.set('TestFor', 'Grails Test');
    this.frameworkMap.set('Mock', 'Grails Test');

    // Categories
    this.categoryMap.set('Entity', 'persistence');
    this.categoryMap.set('Resource', 'web');
    this.categoryMap.set('Secured', 'security');
    this.categoryMap.set('Transactional', 'persistence');
    this.categoryMap.set('TestFor', 'testing');
    this.categoryMap.set('Mock', 'testing');
  }

  private initializeImportPatterns(): void {
    // Grails Core - High confidence
    this.addImportPattern('grails.*', 95, 'Grails');
    this.addImportPattern('org.grails.*', 95, 'Grails');

    // Grails Services
    this.addImportPattern('grails.gorm.services.*', 90, 'Grails GORM');
    this.addImportPattern('grails.gorm.transactions.*', 85, 'Grails GORM');

    // Grails Web
    this.addImportPattern('grails.web.controllers.*', 90, 'Grails');
    this.addImportPattern('grails.converters.*', 85, 'Grails');

    // Grails Plugin
    this.addImportPattern('grails.plugins.*', 85, 'Grails');

    // Grails Testing
    this.addImportPattern('grails.test.*', 90, 'Grails Test');

    // Grails Util
    this.addImportPattern('grails.util.*', 80, 'Grails');

    // GORM (Grails ORM)
    this.addImportPattern('grails.gorm.*', 90, 'Grails GORM');

    // Grails Configuration
    this.addImportPattern('grails.config.*', 80, 'Grails');
  }
}


================================================
FILE: src/scanner/parsers/framework-detection/java/frameworks/GWTFramework.ts
================================================
import { FrameworkModule } from '../../FrameworkModule.js';

/**
 * GWT (Google Web Toolkit) framework detection module
 * Handles Java-to-JavaScript compilation framework
 */
export class GWTFramework extends FrameworkModule {
  constructor() {
    super();
    this.initializeMappings();
  }

  getFrameworkName(): string {
    return 'GWT';
  }

  protected initializeMappings(): void {
    this.initializeAnnotationMappings();
    this.initializeImportPatterns();
  }

  private initializeAnnotationMappings(): void {
    // GWT RPC Annotations
    this.frameworkMap.set('RemoteServiceRelativePath', 'GWT RPC');
    
    // GWT UiBinder Annotations
    this.frameworkMap.set('UiField', 'GWT UiBinder');
    this.frameworkMap.set('UiHandler', 'GWT UiBinder');
    this.frameworkMap.set('UiTemplate', 'GWT UiBinder');
    this.frameworkMap.set('UiConstructor', 'GWT UiBinder');
    this.frameworkMap.set('UiChild', 'GWT UiBinder');
    this.frameworkMap.set('UiFactory', 'GWT UiBinder');

    // GWT RequestFactory Annotations
    this.frameworkMap.set('Service', 'GWT RequestFactory');
    this.frameworkMap.set('ServiceName', 'GWT RequestFactory');
    this.frameworkMap.set('ProxyFor', 'GWT RequestFactory');
    this.frameworkMap.set('ProxyForName', 'GWT RequestFactory');

    // GWT Editor Framework
    this.frameworkMap.set('Path', 'GWT Editor');
    this.frameworkMap.set('Ignore', 'GWT Editor');

    // Categories
    this.categoryMap.set('RemoteServiceRelativePath', 'rpc');
    
    this.categoryMap.set('UiField', 'ui');
    this.categoryMap.set('UiHandler', 'ui');
    this.categoryMap.set('UiTemplate', 'ui');
    this.categoryMap.set('UiConstructor', 'ui');
    this.categoryMap.set('UiChild', 'ui');
    this.categoryMap.set('UiFactory', 'ui');

    this.categoryMap.set('Service', 'requestfactory');
    this.categoryMap.set('ServiceName', 'requestfactory');
    this.categoryMap.set('ProxyFor', 'requestfactory');
    this.categoryMap.set('ProxyForName', 'requestfactory');

    this.categoryMap.set('Path', 'editor');
    this.categoryMap.set('Ignore', 'editor');
  }

  private initializeImportPatterns(): void {
    // GWT Core - High confidence
    this.addImportPattern('com.google.gwt.*', 95, 'GWT');
    this.addImportPattern('com.google.gwt.core.client.*', 95, 'GWT');
    this.addImportPattern('com.google.gwt.user.client.*', 95, 'GWT');

    // GWT UI
    this.addImportPattern('com.google.gwt.user.client.ui.*', 95, 'GWT');
    this.addImportPattern('com.google.gwt.uibinder.client.*', 90, 'GWT UiBinder');

    // GWT RPC
    this.addImportPattern('com.google.gwt.user.client.rpc.*', 90, 'GWT RPC');
    this.addImportPattern('com.google.gwt.user.server.rpc.*', 90, 'GWT RPC');

    // GWT RequestFactory
    this.addImportPattern('com.google.web.bindery.requestfactory.*', 85, 'GWT RequestFactory');

    // GWT Editor
    this.addImportPattern('com.google.gwt.editor.client.*', 85, 'GWT Editor');

    // GWT DOM
    this.addImportPattern('com.google.gwt.dom.client.*', 80, 'GWT');

    // GWT Event
    this.addImportPattern('com.google.gwt.event.*', 80, 'GWT');

    // GWT Resources
    this.addImportPattern('com.google.gwt.resources.client.*', 80, 'GWT');

    // GWT Place
    this.addImportPattern('com.google.gwt.place.shared.*', 75, 'GWT');
    this.addImportPattern('com.google.gwt.activity.shared.*', 75, 'GWT');

    // GWT Testing
    this.addImportPattern('com.google.gwt.junit.client.*', 85, 'GWT Test');
  }
}


================================================
FILE: src/scanner/parsers/framework-detection/java/frameworks/HibernateFramework.ts
================================================
import { FrameworkModule } from '../../FrameworkModule.js';

/**
 * Hibernate ORM framework detection module
 * Handles Hibernate-specific annotations and features beyond standard JPA
 */
export class HibernateFramework extends FrameworkModule {
  constructor() {
    super();
    this.initializeMappings();
  }

  getFrameworkName(): string {
    return 'Hibernate';
  }

  protected initializeMappings(): void {
    this.initializeAnnotationMappings();
    this.initializeImportPatterns();
  }

  private initializeAnnotationMappings(): void {
    // Hibernate Core Annotations
    this.frameworkMap.set('DynamicInsert', 'Hibernate');
    this.frameworkMap.set('DynamicUpdate', 'Hibernate');
    this.frameworkMap.set('SelectBeforeUpdate', 'Hibernate');
    this.frameworkMap.set('Immutable', 'Hibernate');
    this.frameworkMap.set('Entity', 'Hibernate');
    this.frameworkMap.set('Cache', 'Hibernate');
    this.frameworkMap.set('CacheConcurrencyStrategy', 'Hibernate');
    this.frameworkMap.set('NaturalId', 'Hibernate');
    this.frameworkMap.set('NaturalIdCache', 'Hibernate');

    // Hibernate Mapping Annotations
    this.frameworkMap.set('JoinFormula', 'Hibernate');
    this.frameworkMap.set('Formula', 'Hibernate');
    this.frameworkMap.set('ColumnDefault', 'Hibernate');
    this.frameworkMap.set('Generated', 'Hibernate');
    this.frameworkMap.set('GenerationTime', 'Hibernate');
    this.frameworkMap.set('GenericGenerator', 'Hibernate');
    this.frameworkMap.set('Parameter', 'Hibernate');
    this.frameworkMap.set('Type', 'Hibernate');
    this.frameworkMap.set('TypeDef', 'Hibernate');
    this.frameworkMap.set('TypeDefs', 'Hibernate');

    // Hibernate Collection Annotations
    this.frameworkMap.set('IndexColumn', 'Hibernate');
    this.frameworkMap.set('Sort', 'Hibernate');
    this.frameworkMap.set('SortNatural', 'Hibernate');
    this.frameworkMap.set('SortComparator', 'Hibernate');
    this.frameworkMap.set('OrderBy', 'Hibernate');
    this.frameworkMap.set('Where', 'Hibernate');
    this.frameworkMap.set('WhereJoinTable', 'Hibernate');
    this.frameworkMap.set('Filter', 'Hibernate');
    this.frameworkMap.set('FilterDef', 'Hibernate');
    this.frameworkMap.set('FilterDefs', 'Hibernate');
    this.frameworkMap.set('FilterJoinTable', 'Hibernate');

    // Hibernate Lazy Loading
    this.frameworkMap.set('LazyToOne', 'Hibernate');
    this.frameworkMap.set('LazyCollection', 'Hibernate');
    this.frameworkMap.set('LazyGroup', 'Hibernate');
    this.frameworkMap.set('Fetch', 'Hibernate');
    this.frameworkMap.set('FetchMode', 'Hibernate');
    this.frameworkMap.set('BatchSize', 'Hibernate');

    // Hibernate Cascade
    this.frameworkMap.set('Cascade', 'Hibernate');
    this.frameworkMap.set('OnDelete', 'Hibernate');

    // Hibernate Validation
    this.frameworkMap.set('Check', 'Hibernate');

    // Hibernate Proxy
    this.frameworkMap.set('Proxy', 'Hibernate');
    this.frameworkMap.set('LazyToOneOption', 'Hibernate');

    // Hibernate Search
    this.frameworkMap.set('Indexed', 'Hibernate Search');
    this.frameworkMap.set('Field', 'Hibernate Search');
    this.frameworkMap.set('FullTextField', 'Hibernate Search');
    this.frameworkMap.set('KeywordField', 'Hibernate Search');
    this.frameworkMap.set('IndexedEmbedded', 'Hibernate Search');
    this.frameworkMap.set('DocumentId', 'Hibernate Search');

    // Hibernate Validator
    this.frameworkMap.set('NotNull', 'Hibernate Validator');
    this.frameworkMap.set('NotEmpty', 'Hibernate Validator');
    this.frameworkMap.set('NotBlank', 'Hibernate Validator');
    this.frameworkMap.set('Length', 'Hibernate Validator');
    this.frameworkMap.set('Range', 'Hibernate Validator');
    this.frameworkMap.set('Email', 'Hibernate Validator');
    this.frameworkMap.set('CreditCardNumber', 'Hibernate Validator');
    this.frameworkMap.set('URL', 'Hibernate Validator');

    // Categories
    this.categoryMap.set('DynamicInsert', 'persistence');
    this.categoryMap.set('DynamicUpdate', 'persistence');
    this.categoryMap.set('SelectBeforeUpdate', 'persistence');
    this.categoryMap.set('Immutable', 'persistence');
    this.categoryMap.set('Entity', 'persistence');
    this.categoryMap.set('NaturalId', 'persistence');
    this.categoryMap.set('NaturalIdCache', 'persistence');

    this.categoryMap.set('Cache', 'performance');
    this.categoryMap.set('CacheConcurrencyStrategy', 'performance');
    this.categoryMap.set('LazyToOne', 'performance');
    this.categoryMap.set('LazyCollection', 'performance');
    this.categoryMap.set('LazyGroup', 'performance');
    this.categoryMap.set('Fetch', 'performance');
    this.categoryMap.set('FetchMode', 'performance');
    this.categoryMap.set('BatchSize', 'performance');

    this.categoryMap.set('JoinFormula', 'persistence');
    this.categoryMap.set('Formula', 'persistence');
    this.categoryMap.set('ColumnDefault', 'persistence');
    this.categoryMap.set('Generated', 'persistence');
    this.categoryMap.set('GenerationTime', 'persistence');
    this.categoryMap.set('GenericGenerator', 'persistence');
    this.categoryMap.set('Parameter', 'persistence');
    this.categoryMap.set('Type', 'persistence');
    this.categoryMap.set('TypeDef', 'persistence');
    this.categoryMap.set('TypeDefs', 'persistence');

    this.categoryMap.set('IndexColumn', 'persistence');
    this.categoryMap.set('Sort', 'persistence');
    this.categoryMap.set('SortNatural', 'persistence');
    this.categoryMap.set('SortComparator', 'persistence');
    this.categoryMap.set('OrderBy', 'persistence');
    this.categoryMap.set('Where', 'persistence');
    this.categoryMap.set('WhereJoinTable', 'persistence');
    this.categoryMap.set('Filter', 'persistence');
    this.categoryMap.set('FilterDef', 'persistence');
    this.categoryMap.set('FilterDefs', 'persistence');
    this.categoryMap.set('FilterJoinTable', 'persistence');

    this.categoryMap.set('Cascade', 'persistence');
    this.categoryMap.set('OnDelete', 'persistence');
    this.categoryMap.set('Check', 'persistence');
    this.categoryMap.set('Proxy', 'persistence');
    this.categoryMap.set('LazyToOneOption', 'persistence');

    // Hibernate Search categories
    this.categoryMap.set('Indexed', 'search');
    this.categoryMap.set('Field', 'search');
    this.categoryMap.set('FullTextField', 'search');
    this.categoryMap.set('KeywordField', 'search');
    this.categoryMap.set('IndexedEmbedded', 'search');
    this.categoryMap.set('DocumentId', 'search');

    // Hibernate Validator categories
    this.categoryMap.set('NotNull', 'validation');
    this.categoryMap.set('NotEmpty', 'validation');
    this.categoryMap.set('NotBlank', 'validation');
    this.categoryMap.set('Length', 'validation');
    this.categoryMap.set('Range', 'validation');
    this.categoryMap.set('Email', 'validation');
    this.categoryMap.set('CreditCardNumber', 'validation');
    this.categoryMap.set('URL', 'validation');
  }

  private initializeImportPatterns(): void {
    // Hibernate Core - High confidence
    this.addImportPattern('org.hibernate.*', 95, 'Hibernate');
    this.addImportPattern('org.hibernate.annotations.*', 95, 'Hibernate');
    this.addImportPattern('org.hibernate.type.*', 90, 'Hibernate');
    this.addImportPattern('org.hibernate.engine.*', 85, 'Hibernate');
    this.addImportPattern('org.hibernate.mapping.*', 80, 'Hibernate');
    this.addImportPattern('org.hibernate.cfg.*', 85, 'Hibernate');

    // Hibernate Search
    this.addImportPattern('org.hibernate.search.*', 95, 'Hibernate Search');
    this.addImportPattern('org.hibernate.search.annotations.*', 95, 'Hibernate Search');
    this.addImportPattern('org.hibernate.search.mapper.pojo.mapping.definition.annotation.*', 95, 'Hibernate Search');

    // Hibernate Validator
    this.addImportPattern('org.hibernate.validator.*', 95, 'Hibernate Validator');
    this.addImportPattern('org.hibernate.validator.constraints.*', 95, 'Hibernate Validator');

    // Hibernate Envers (Auditing)
    this.addImportPattern('org.hibernate.envers.*', 90, 'Hibernate Envers');

    // Hibernate Spatial
    this.addImportPattern('org.hibernate.spatial.*', 85, 'Hibernate Spatial');
  }
}


================================================
FILE: src/scanner/parsers/framework-detection/java/frameworks/JavaCoreFramework.ts
================================================
import { FrameworkModule } from '../../FrameworkModule.js';

/**
 * Java Core framework detection module
 * Handles built-in Java language annotations
 */
export class JavaCoreFramework extends FrameworkModule {
  constructor() {
    super();
    this.initializeMappings();
  }

  getFrameworkName(): string {
    return 'Java';
  }

  protected initializeMappings(): void {
    this.initializeAnnotationMappings();
    this.initializeImportPatterns();
  }

  private initializeAnnotationMappings(): void {
    // Java Core Annotations
    this.frameworkMap.set('Override', 'Java');
    this.frameworkMap.set('Deprecated', 'Java');
    this.frameworkMap.set('SuppressWarnings', 'Java');
    this.frameworkMap.set('FunctionalInterface', 'Java');
    this.frameworkMap.set('SafeVarargs', 'Java');

    // Categories - all are language features
    this.categoryMap.set('Override', 'language');
    this.categoryMap.set('Deprecated', 'language');
    this.categoryMap.set('SuppressWarnings', 'language');
    this.categoryMap.set('FunctionalInterface', 'language');
    this.categoryMap.set('SafeVarargs', 'language');
  }

  private initializeImportPatterns(): void {
    // Java core packages - High confidence
    this.addImportPattern('java.lang.*', 95, 'Java');
    this.addImportPattern('java.util.*', 90, 'Java');
    this.addImportPattern('java.io.*', 85, 'Java');
    this.addImportPattern('java.nio.*', 85, 'Java');
    this.addImportPattern('java.net.*', 80, 'Java');
    this.addImportPattern('java.time.*', 85, 'Java');
    this.addImportPattern('java.text.*', 80, 'Java');
    this.addImportPattern('java.math.*', 80, 'Java');
    this.addImportPattern('java.security.*', 75, 'Java');
    this.addImportPattern('java.beans.*', 75, 'Java');
    this.addImportPattern('java.sql.*', 80, 'Java');
    this.addImportPattern('java.concurrent.*', 80, 'Java');
    this.addImportPattern('java.util.concurrent.*', 85, 'Java');
    this.addImportPattern('java.util.stream.*', 85, 'Java');
    this.addImportPattern('java.util.function.*', 85, 'Java');
    this.addImportPattern('java.util.regex.*', 80, 'Java');
  }
}


================================================
FILE: src/scanner/parsers/framework-detection/java/frameworks/JerseyFramework.ts
================================================
import { FrameworkModule } from '../../FrameworkModule.js';

/**
 * Jersey JAX-RS framework detection module
 * Handles reference implementation of JAX-RS for RESTful web services
 */
export class JerseyFramework extends FrameworkModule {
  constructor() {
    super();
    this.initializeMappings();
  }

  getFrameworkName(): string {
    return 'Jersey';
  }

  protected initializeMappings(): void {
    this.initializeAnnotationMappings();
    this.initializeImportPatterns();
  }

  private initializeAnnotationMappings(): void {
    // JAX-RS Core Annotations
    this.frameworkMap.set('Path', 'Jersey');
    this.frameworkMap.set('GET', 'Jersey');
    this.frameworkMap.set('POST', 'Jersey');
    this.frameworkMap.set('PUT', 'Jersey');
    this.frameworkMap.set('DELETE', 'Jersey');
    this.frameworkMap.set('PATCH', 'Jersey');
    this.frameworkMap.set('HEAD', 'Jersey');
    this.frameworkMap.set('OPTIONS', 'Jersey');
    this.frameworkMap.set('Produces', 'Jersey');
    this.frameworkMap.set('Consumes', 'Jersey');
    this.frameworkMap.set('PathParam', 'Jersey');
    this.frameworkMap.set('QueryParam', 'Jersey');
    this.frameworkMap.set('HeaderParam', 'Jersey');
    this.frameworkMap.set('FormParam', 'Jersey');
    this.frameworkMap.set('MatrixParam', 'Jersey');
    this.frameworkMap.set('CookieParam', 'Jersey');
    this.frameworkMap.set('BeanParam', 'Jersey');
    this.frameworkMap.set('Context', 'Jersey');
    this.frameworkMap.set('DefaultValue', 'Jersey');
    this.frameworkMap.set('Encoded', 'Jersey');

    // Jersey-specific Annotations
    this.frameworkMap.set('JerseyTest', 'Jersey Test');
    this.frameworkMap.set('InMemoryTestContainer', 'Jersey Test');

    // Jersey Client Annotations
    this.frameworkMap.set('ClientConfig', 'Jersey Client');

    // Jersey Validation
    this.frameworkMap.set('Valid', 'Jersey');
    this.frameworkMap.set('NotNull', 'Jersey');
    this.frameworkMap.set('NotEmpty', 'Jersey');
    this.frameworkMap.set('Size', 'Jersey');
    this.frameworkMap.set('Min', 'Jersey');
    this.frameworkMap.set('Max', 'Jersey');
    this.frameworkMap.set('Pattern', 'Jersey');
    this.frameworkMap.set('Email', 'Jersey');

    // Jersey Security
    this.frameworkMap.set('RolesAllowed', 'Jersey Security');
    this.frameworkMap.set('PermitAll', 'Jersey Security');
    this.frameworkMap.set('DenyAll', 'Jersey Security');

    // Jersey Filters and Interceptors
    this.frameworkMap.set('Provider', 'Jersey');
    this.frameworkMap.set('PreMatching', 'Jersey');
    this.frameworkMap.set('Priority', 'Jersey');

    // Categories
    this.categoryMap.set('Path', 'web');
    this.categoryMap.set('GET', 'web');
    this.categoryMap.set('POST', 'web');
    this.categoryMap.set('PUT', 'web');
    this.categoryMap.set('DELETE', 'web');
    this.categoryMap.set('PATCH', 'web');
    this.categoryMap.set('HEAD', 'web');
    this.categoryMap.set('OPTIONS', 'web');
    this.categoryMap.set('Produces', 'web');
    this.categoryMap.set('Consumes', 'web');
    this.categoryMap.set('PathParam', 'web');
    this.categoryMap.set('QueryParam', 'web');
    this.categoryMap.set('HeaderParam', 'web');
    this.categoryMap.set('FormParam', 'web');
    this.categoryMap.set('MatrixParam', 'web');
    this.categoryMap.set('CookieParam', 'web');
    this.categoryMap.set('BeanParam', 'web');
    this.categoryMap.set('Context', 'web');
    this.categoryMap.set('DefaultValue', 'web');
    this.categoryMap.set('Encoded', 'web');

    this.categoryMap.set('JerseyTest', 'testing');
    this.categoryMap.set('InMemoryTestContainer', 'testing');

    this.categoryMap.set('ClientConfig', 'client');

    this.categoryMap.set('Valid', 'validation');
    this.categoryMap.set('NotNull', 'validation');
    this.categoryMap.set('NotEmpty', 'validation');
    this.categoryMap.set('Size', 'validation');
    this.categoryMap.set('Min', 'validation');
    this.categoryMap.set('Max', 'validation');
    this.categoryMap.set('Pattern', 'validation');
    this.categoryMap.set('Email', 'validation');

    this.categoryMap.set('RolesAllowed', 'security');
    this.categoryMap.set('PermitAll', 'security');
    this.categoryMap.set('DenyAll', 'security');

    this.categoryMap.set('Provider', 'filter');
    this.categoryMap.set('PreMatching', 'filter');
    this.categoryMap.set('Priority', 'filter');
  }

  private initializeImportPatterns(): void {
    // JAX-RS Core - High confidence
    this.addImportPattern('javax.ws.rs.*', 95, 'Jersey');
    this.addImportPattern('jakarta.ws.rs.*', 95, 'Jersey');

    // Jersey Core - High confidence
    this.addImportPattern('org.glassfish.jersey.*', 95, 'Jersey');
    this.addImportPattern('org.glassfish.jersey.server.*', 95, 'Jersey');
    this.addImportPattern('org.glassfish.jersey.client.*', 90, 'Jersey Client');

    // Jersey Testing
    this.addImportPattern('org.glassfish.jersey.test.*', 95, 'Jersey Test');

    // Jersey Media Support
    this.addImportPattern('org.glassfish.jersey.media.*', 85, 'Jersey');

    // Jersey Injection (HK2)
    this.addImportPattern('org.glassfish.hk2.*', 80, 'Jersey');

    // Bean Validation
    this.addImportPattern('javax.validation.*', 75, 'Jersey');
    this.addImportPattern('jakarta.validation.*', 80, 'Jersey');

    // Security
    this.addImportPattern('javax.annotation.security.*', 75, 'Jersey Security');
    this.addImportPattern('jakarta.annotation.security.*', 80, 'Jersey Security');

    // Jersey Extensions
    this.addImportPattern('org.glassfish.jersey.jackson.*', 80, 'Jersey');
    this.addImportPattern('org.glassfish.jersey.moxy.*', 75, 'Jersey');
  }
}


================================================
FILE: src/scanner/parsers/framework-detection/java/frameworks/JHipsterFramework.ts
================================================
import { FrameworkModule } from '../../FrameworkModule.js';

/**
 * JHipster framework detection module
 * Handles rapid application generation for Spring Boot + Angular/React/Vue
 */
export class JHipsterFramework extends FrameworkModule {
  constructor() {
    super();
    this.initializeMappings();
  }

  getFrameworkName(): string {
    return 'JHipster';
  }

  protected initializeMappings(): void {
    this.initializeAnnotationMappings();
    this.initializeImportPatterns();
  }

  private initializeAnnotationMappings(): void {
    // JHipster uses standard Spring Boot annotations, but may have some specific ones
    // Most JHipster identification comes from import patterns and generated code structures
    
    // Categories for any JHipster-specific annotations would go here
  }

  private initializeImportPatterns(): void {
    // JHipster Core - Moderate confidence (as it generates standard Spring Boot code)
    this.addImportPattern('io.github.jhipster.*', 90, 'JHipster');
    this.addImportPattern('tech.jhipster.*', 95, 'JHipster');

    // JHipster Config
    this.addImportPattern('tech.jhipster.config.*', 90, 'JHipster');

    // JHipster Security
    this.addImportPattern('tech.jhipster.security.*', 85, 'JHipster');

    // JHipster Web
    this.addImportPattern('tech.jhipster.web.*', 85, 'JHipster');

    // JHipster Service
    this.addImportPattern('tech.jhipster.service.*', 80, 'JHipster');

    // JHipster Domain (generated entities often have specific patterns)
    this.addImportPattern('tech.jhipster.domain.*', 80, 'JHipster');

    // Legacy JHipster packages
    this.addImportPattern('io.github.jhipster.config.*', 85, 'JHipster');
    this.addImportPattern('io.github.jhipster.security.*', 80, 'JHipster');
    this.addImportPattern('io.github.jhipster.web.*', 80, 'JHipster');
  }
}


================================================
FILE: src/scanner/parsers/framework-detection/java/frameworks/JPAFramework.ts
================================================
import { FrameworkModule } from '../../FrameworkModule.js';

/**
 * JPA (Java Persistence API) framework detection module
 * Handles JPA entity and relationship annotations
 */
export class JPAFramework extends FrameworkModule {
  constructor() {
    super();
    this.initializeMappings();
  }

  getFrameworkName(): string {
    return 'JPA';
  }

  protected initializeMappings(): void {
    // JPA Annotations
    this.frameworkMap.set('Entity', 'JPA');
    this.frameworkMap.set('Table', 'JPA');
    this.frameworkMap.set('Id', 'JPA');
    this.frameworkMap.set('GeneratedValue', 'JPA');
    this.frameworkMap.set('Column', 'JPA');
    this.frameworkMap.set('JoinColumn', 'JPA');
    this.frameworkMap.set('OneToMany', 'JPA');
    this.frameworkMap.set('ManyToOne', 'JPA');
    this.frameworkMap.set('ManyToMany', 'JPA');
    this.frameworkMap.set('OneToOne', 'JPA');

    // Categories - all JPA annotations are persistence-related
    this.categoryMap.set('Entity', 'persistence');
    this.categoryMap.set('Table', 'persistence');
    this.categoryMap.set('Id', 'persistence');
    this.categoryMap.set('GeneratedValue', 'persistence');
    this.categoryMap.set('Column', 'persistence');
    this.categoryMap.set('JoinColumn', 'persistence');
    this.categoryMap.set('OneToMany', 'persistence');
    this.categoryMap.set('ManyToOne', 'persistence');
    this.categoryMap.set('ManyToMany', 'persistence');
    this.categoryMap.set('OneToOne', 'persistence');
  }
}


================================================
FILE: src/scanner/parsers/framework-detection/java/frameworks/JSFFramework.ts
================================================
import { FrameworkModule } from '../../FrameworkModule.js';

/**
 * JSF (JavaServer Faces) framework detection module
 * Handles component-based UI framework
 */
export class JSFFramework extends FrameworkModule {
  constructor() {
    super();
    this.initializeMappings();
  }

  getFrameworkName(): string {
    return 'JSF';
  }

  protected initializeMappings(): void {
    this.initializeAnnotationMappings();
    this.initializeImportPatterns();
  }

  private initializeAnnotationMappings(): void {
    // JSF Core Annotations
    this.frameworkMap.set('ManagedBean', 'JSF');
    this.frameworkMap.set('Named', 'JSF');
    this.frameworkMap.set('RequestScoped', 'JSF');
    this.frameworkMap.set('ViewScoped', 'JSF');
    this.frameworkMap.set('SessionScoped', 'JSF');
    this.frameworkMap.set('ApplicationScoped', 'JSF');
    this.frameworkMap.set('ConversationScoped', 'JSF');
    this.frameworkMap.set('CustomScoped', 'JSF');
    this.frameworkMap.set('NoneScoped', 'JSF');

    // JSF Navigation
    this.frameworkMap.set('NavigationCase', 'JSF');

    // JSF Components
    this.frameworkMap.set('FacesComponent', 'JSF');
    this.frameworkMap.set('FacesRenderer', 'JSF');
    this.frameworkMap.set('FacesConverter', 'JSF');
    this.frameworkMap.set('FacesValidator', 'JSF');
    this.frameworkMap.set('ListenerFor', 'JSF');
    this.frameworkMap.set('ListenersFor', 'JSF');
    this.frameworkMap.set('ResourceDependency', 'JSF');
    this.frameworkMap.set('ResourceDependencies', 'JSF');

    // JSF Validation
    this.frameworkMap.set('FacesValidatorFor', 'JSF');

    // JSF Events
    this.frameworkMap.set('NamedEvent', 'JSF');

    // JSF Behavior
    this.frameworkMap.set('FacesBehavior', 'JSF');
    this.frameworkMap.set('FacesBehaviorRenderer', 'JSF');

    // CDI Integration
    this.frameworkMap.set('Inject', 'JSF');
    this.frameworkMap.set('Produces', 'JSF');
    this.frameworkMap.set('Qualifier', 'JSF');

    // Bean Validation Integration
    this.frameworkMap.set('Valid', 'JSF');
    this.frameworkMap.set('NotNull', 'JSF');
    this.frameworkMap.set('NotEmpty', 'JSF');
    this.frameworkMap.set('Size', 'JSF');
    this.frameworkMap.set('Pattern', 'JSF');

    // Categories
    this.categoryMap.set('ManagedBean', 'injection');
    this.categoryMap.set('Named', 'injection');
    this.categoryMap.set('RequestScoped', 'injection');
    this.categoryMap.set('ViewScoped', 'injection');
    this.categoryMap.set('SessionScoped', 'injection');
    this.categoryMap.set('ApplicationScoped', 'injection');
    this.categoryMap.set('ConversationScoped', 'injection');
    this.categoryMap.set('CustomScoped', 'injection');
    this.categoryMap.set('NoneScoped', 'injection');
    this.categoryMap.set('Inject', 'injection');
    this.categoryMap.set('Produces', 'injection');
    this.categoryMap.set('Qualifier', 'injection');

    this.categoryMap.set('NavigationCase', 'navigation');

    this.categoryMap.set('FacesComponent', 'ui');
    this.categoryMap.set('FacesRenderer', 'ui');
    this.categoryMap.set('ResourceDependency', 'ui');
    this.categoryMap.set('ResourceDependencies', 'ui');

    this.categoryMap.set('FacesConverter', 'conversion');

    this.categoryMap.set('FacesValidator', 'validation');
    this.categoryMap.set('FacesValidatorFor', 'validation');
    this.categoryMap.set('Valid', 'validation');
    this.categoryMap.set('NotNull', 'validation');
    this.categoryMap.set('NotEmpty', 'validation');
    this.categoryMap.set('Size', 'validation');
    this.categoryMap.set('Pattern', 'validation');

    this.categoryMap.set('ListenerFor', 'events');
    this.categoryMap.set('ListenersFor', 'events');
    this.categoryMap.set('NamedEvent', 'events');

    this.categoryMap.set('FacesBehavior', 'behavior');
    this.categoryMap.set('FacesBehaviorRenderer', 'behavior');
  }

  private initializeImportPatterns(): void {
    // JSF Core - High confidence
    this.addImportPattern('javax.faces.*', 95, 'JSF');
    this.addImportPattern('jakarta.faces.*', 95, 'JSF');
    this.addImportPattern('javax.faces.annotation.*', 95, 'JSF');
    this.addImportPattern('jakarta.faces.annotation.*', 95, 'JSF');

    // JSF Bean Management
    this.addImportPattern('javax.faces.bean.*', 90, 'JSF');
    this.addImportPattern('jakarta.faces.bean.*', 90, 'JSF');

    // JSF Components
    this.addImportPattern('javax.faces.component.*', 85, 'JSF');
    this.addImportPattern('jakarta.faces.component.*', 85, 'JSF');

    // JSF Context
    this.addImportPattern('javax.faces.context.*', 85, 'JSF');
    this.addImportPattern('jakarta.faces.context.*', 85, 'JSF');

    // JSF Validation
    this.addImportPattern('javax.faces.validator.*', 85, 'JSF');
    this.addImportPattern('jakarta.faces.validator.*', 85, 'JSF');

    // JSF Conversion
    this.addImportPattern('javax.faces.convert.*', 80, 'JSF');
    this.addImportPattern('jakarta.faces.convert.*', 80, 'JSF');

    // JSF Events
    this.addImportPattern('javax.faces.event.*', 80, 'JSF');
    this.addImportPattern('jakarta.faces.event.*', 80, 'JSF');

    // JSF Application
    this.addImportPattern('javax.faces.application.*', 75, 'JSF');
    this.addImportPattern('jakarta.faces.application.*', 75, 'JSF');

    // JSF Render Kit
    this.addImportPattern('javax.faces.render.*', 75, 'JSF');
    this.addImportPattern('jakarta.faces.render.*', 75, 'JSF');

    // CDI Integration
    this.addImportPattern('javax.enterprise.context.*', 70, 'JSF');
    this.addImportPattern('jakarta.enterprise.context.*', 75, 'JSF');
    this.addImportPattern('javax.inject.*', 70, 'JSF');
    this.addImportPattern('jakarta.inject.*', 75, 'JSF');

    // Bean Validation
    this.addImportPattern('javax.validation.*', 70, 'JSF');
    this.addImportPattern('jakarta.validation.*', 75, 'JSF');
  }
}


================================================
FILE: src/scanner/parsers/framework-detection/java/frameworks/JUnitFramework.ts
================================================
import { FrameworkModule } from '../../FrameworkModule.js';

/**
 * JUnit testing framework detection module
 * Handles JUnit 5 lifecycle and test annotations
 */
export class JUnitFramework extends FrameworkModule {
  constructor() {
    super();
    this.initializeMappings();
  }

  getFrameworkName(): string {
    return 'JUnit';
  }

  protected initializeMappings(): void {
    this.initializeAnnotationMappings();
    this.initializeImportPatterns();
  }

  private initializeAnnotationMappings(): void {
    // JUnit 5 Core Annotations
    this.frameworkMap.set('Test', 'JUnit');
    this.frameworkMap.set('BeforeEach', 'JUnit');
    this.frameworkMap.set('AfterEach', 'JUnit');
    this.frameworkMap.set('BeforeAll', 'JUnit');
    this.frameworkMap.set('AfterAll', 'JUnit');
    this.frameworkMap.set('DisplayName', 'JUnit');
    this.frameworkMap.set('DisplayNameGeneration', 'JUnit');
    this.frameworkMap.set('Nested', 'JUnit');
    this.frameworkMap.set('Tag', 'JUnit');
    this.frameworkMap.set('Tags', 'JUnit');

    // JUnit 5 Conditional Execution
    this.frameworkMap.set('Disabled', 'JUnit');
    this.frameworkMap.set('EnabledIf', 'JUnit');
    this.frameworkMap.set('DisabledIf', 'JUnit');
    this.frameworkMap.set('EnabledOnOs', 'JUnit');
    this.frameworkMap.set('DisabledOnOs', 'JUnit');
    this.frameworkMap.set('EnabledOnJre', 'JUnit');
    this.frameworkMap.set('DisabledOnJre', 'JUnit');
    this.frameworkMap.set('EnabledIfSystemProperty', 'JUnit');
    this.frameworkMap.set('DisabledIfSystemProperty', 'JUnit');
    this.frameworkMap.set('EnabledIfEnvironmentVariable', 'JUnit');
    this.frameworkMap.set('DisabledIfEnvironmentVariable', 'JUnit');

    // JUnit 5 Parameterized Tests
    this.frameworkMap.set('ParameterizedTest', 'JUnit');
    this.frameworkMap.set('ValueSource', 'JUnit');
    this.frameworkMap.set('EnumSource', 'JUnit');
    this.frameworkMap.set('MethodSource', 'JUnit');
    this.frameworkMap.set('CsvSource', 'JUnit');
    this.frameworkMap.set('CsvFileSource', 'JUnit');
    this.frameworkMap.set('ArgumentsSource', 'JUnit');

    // JUnit 5 Dynamic Tests
    this.frameworkMap.set('TestFactory', 'JUnit');

    // JUnit 5 Repeated Tests
    this.frameworkMap.set('RepeatedTest', 'JUnit');

    // JUnit 5 Timeouts
    this.frameworkMap.set('Timeout', 'JUnit');

    // JUnit 5 Order
    this.frameworkMap.set('TestMethodOrder', 'JUnit');
    this.frameworkMap.set('Order', 'JUnit');

    // JUnit 5 Extensions
    this.frameworkMap.set('ExtendWith', 'JUnit');
    this.frameworkMap.set('RegisterExtension', 'JUnit');

    // JUnit 4 Legacy Annotations (for detection)
    this.frameworkMap.set('Before', 'JUnit 4');
    this.frameworkMap.set('After', 'JUnit 4');
    this.frameworkMap.set('BeforeClass', 'JUnit 4');
    this.frameworkMap.set('AfterClass', 'JUnit 4');
    this.frameworkMap.set('Ignore', 'JUnit 4');
    this.frameworkMap.set('RunWith', 'JUnit 4');

    // Categories
    this.categoryMap.set('Test', 'testing');
    this.categoryMap.set('ParameterizedTest', 'testing');
    this.categoryMap.set('RepeatedTest', 'testing');
    this.categoryMap.set('TestFactory', 'testing');

    this.categoryMap.set('BeforeEach', 'lifecycle');
    this.categoryMap.set('AfterEach', 'lifecycle');
    this.categoryMap.set('BeforeAll', 'lifecycle');
    this.categoryMap.set('AfterAll', 'lifecycle');
    this.categoryMap.set('Before', 'lifecycle');
    this.categoryMap.set('After', 'lifecycle');
    this.categoryMap.set('BeforeClass', 'lifecycle');
    this.categoryMap.set('AfterClass', 'lifecycle');

    this.categoryMap.set('DisplayName', 'metadata');
    this.categoryMap.set('DisplayNameGeneration', 'metadata');
    this.categoryMap.set('Tag', 'metadata');
    this.categoryMap.set('Tags', 'metadata');
    this.categoryMap.set('Order', 'metadata');
    this.categoryMap.set('TestMethodOrder', 'metadata');

    this.categoryMap.set('Nested', 'organization');

    this.categoryMap.set('Disabled', 'conditional');
    this.categoryMap.set('EnabledIf', 'conditional');
    this.categoryMap.set('DisabledIf', 'conditional');
    this.categoryMap.set('EnabledOnOs', 'conditional');
    this.categoryMap.set('DisabledOnOs', 'conditional');
    this.categoryMap.set('EnabledOnJre', 'conditional');
    this.categoryMap.set('DisabledOnJre', 'conditional');
    this.categoryMap.set('EnabledIfSystemProperty', 'conditional');
    this.categoryMap.set('DisabledIfSystemProperty', 'conditional');
    this.categoryMap.set('EnabledIfEnvironmentVariable', 'conditional');
    this.categoryMap.set('DisabledIfEnvironmentVariable', 'conditional');
    this.categoryMap.set('Ignore', 'conditional');

    this.categoryMap.set('ValueSource', 'parameterized');
    this.categoryMap.set('EnumSource', 'parameterized');
    this.categoryMap.set('MethodSource', 'parameterized');
    this.categoryMap.set('CsvSource', 'parameterized');
    this.categoryMap.set('CsvFileSource', 'parameterized');
    this.categoryMap.set('ArgumentsSource', 'parameterized');

    this.categoryMap.set('Timeout', 'performance');

    this.categoryMap.set('ExtendWith', 'extension');
    this.categoryMap.set('RegisterExtension', 'extension');
    this.categoryMap.set('RunWith', 'extension');
  }

  private initializeImportPatterns(): void {
    // JUnit 5 - High confidence
    this.addImportPattern('org.junit.jupiter.*', 95, 'JUnit');
    this.addImportPattern('org.junit.jupiter.api.*', 95, 'JUnit');
    this.addImportPattern('org.junit.jupiter.params.*', 90, 'JUnit');
    this.addImportPattern('org.junit.jupiter.api.condition.*', 85, 'JUnit');
    this.addImportPattern('org.junit.jupiter.api.extension.*', 85, 'JUnit');

    // JUnit 4 Legacy - Medium confidence
    this.addImportPattern('org.junit.*', 80, 'JUnit 4');
    this.addImportPattern('org.junit.runner.*', 75, 'JUnit 4');
    this.addImportPattern('org.junit.runners.*', 75, 'JUnit 4');

    // JUnit Platform
    this.addImportPattern('org.junit.platform.*', 80, 'JUnit Platform');

    // JUnit Vintage (for running JUnit 4 tests in JUnit 5)
    this.addImportPattern('org.junit.vintage.*', 75, 'JUnit Vintage');

    // Assertions (could be from different libraries)
    this.addImportPattern('org.junit.jupiter.api.Assertions', 85, 'JUnit');
    this.addImportPattern('org.junit.Assert', 75, 'JUnit 4');
  }
}


================================================
FILE: src/scanner/parsers/framework-detection/java/frameworks/LombokFramework.ts
================================================
import { FrameworkModule } from '../../FrameworkModule.js';

/**
 * Lombok framework detection module
 * Handles Lombok code generation annotations
 */
export class LombokFramework extends FrameworkModule {
  constructor() {
    super();
    this.initializeMappings();
  }

  getFrameworkName(): string {
    return 'Lombok';
  }

  protected initializeMappings(): void {
    this.initializeAnnotationMappings();
    this.initializeImportPatterns();
  }

  private initializeAnnotationMappings(): void {
    // Lombok Core Annotations
    this.frameworkMap.set('Data', 'Lombok');
    this.frameworkMap.set('Builder', 'Lombok');
    this.frameworkMap.set('AllArgsConstructor', 'Lombok');
    this.frameworkMap.set('NoArgsConstructor', 'Lombok');
    this.frameworkMap.set('RequiredArgsConstructor', 'Lombok');
    this.frameworkMap.set('Getter', 'Lombok');
    this.frameworkMap.set('Setter', 'Lombok');
    this.frameworkMap.set('ToString', 'Lombok');
    this.frameworkMap.set('EqualsAndHashCode', 'Lombok');

    // Lombok Additional Annotations
    this.frameworkMap.set('Value', 'Lombok');
    this.frameworkMap.set('NonNull', 'Lombok');
    this.frameworkMap.set('Cleanup', 'Lombok');
    this.frameworkMap.set('SneakyThrows', 'Lombok');
    this.frameworkMap.set('Synchronized', 'Lombok');
    this.frameworkMap.set('Delegate', 'Lombok');
    this.frameworkMap.set('Lazy', 'Lombok');
    this.frameworkMap.set('Log', 'Lombok');
    this.frameworkMap.set('Slf4j', 'Lombok');
    this.frameworkMap.set('Log4j', 'Lombok');
    this.frameworkMap.set('Log4j2', 'Lombok');
    this.frameworkMap.set('CommonsLog', 'Lombok');
    this.frameworkMap.set('JBossLog', 'Lombok');
    this.frameworkMap.set('Flogger', 'Lombok');
    this.frameworkMap.set('CustomLog', 'Lombok');

    // Categories
    this.categoryMap.set('Data', 'codegen');
    this.categoryMap.set('Builder', 'codegen');
    this.categoryMap.set('AllArgsConstructor', 'codegen');
    this.categoryMap.set('NoArgsConstructor', 'codegen');
    this.categoryMap.set('RequiredArgsConstructor', 'codegen');
    this.categoryMap.set('Getter', 'codegen');
    this.categoryMap.set('Setter', 'codegen');
    this.categoryMap.set('ToString', 'codegen');
    this.categoryMap.set('EqualsAndHashCode', 'codegen');
    this.categoryMap.set('Value', 'codegen');

    this.categoryMap.set('NonNull', 'validation');
    this.categoryMap.set('Cleanup', 'cleanup');
    this.categoryMap.set('SneakyThrows', 'exception');
    this.categoryMap.set('Synchronized', 'concurrency');
    this.categoryMap.set('Delegate', 'codegen');
    this.categoryMap.set('Lazy', 'performance');

    this.categoryMap.set('Log', 'logging');
    this.categoryMap.set('Slf4j', 'logging');
    this.categoryMap.set('Log4j', 'logging');
    this.categoryMap.set('Log4j2', 'logging');
    this.categoryMap.set('CommonsLog', 'logging');
    this.categoryMap.set('JBossLog', 'logging');
    this.categoryMap.set('Flogger', 'logging');
    this.categoryMap.set('CustomLog', 'logging');
  }

  private initializeImportPatterns(): void {
    // Lombok Core - High confidence
    this.addImportPattern('lombok.*', 95, 'Lombok');
    this.addImportPattern('lombok.experimental.*', 85, 'Lombok');
    this.addImportPattern('lombok.extern.*', 90, 'Lombok');
    this.addImportPattern('lombok.extern.slf4j.*', 90, 'Lombok');
    this.addImportPattern('lombok.extern.log4j.*', 85, 'Lombok');
    this.addImportPattern('lombok.extern.java.*', 85, 'Lombok');
    this.addImportPattern('lombok.extern.apachecommons.*', 80, 'Lombok');
    this.addImportPattern('lombok.extern.jbosslog.*', 80, 'Lombok');
    this.addImportPattern('lombok.extern.flogger.*', 80, 'Lombok');
  }
}


================================================
FILE: src/scanner/parsers/framework-detection/java/frameworks/MicronautFramework.ts
================================================
import { FrameworkModule } from '../../FrameworkModule.js';

/**
 * Micronaut framework detection module
 * Handles modern, JVM-based, full-stack framework for microservices
 */
export class MicronautFramework extends FrameworkModule {
  constructor() {
    super();
    this.initializeMappings();
  }

  getFrameworkName(): string {
    return 'Micronaut';
  }

  protected initializeMappings(): void {
    this.initializeAnnotationMappings();
    this.initializeImportPatterns();
  }

  private initializeAnnotationMappings(): void {
    // Micronaut Core Annotations
    this.frameworkMap.set('MicronautApplication', 'Micronaut');
    this.frameworkMap.set('Singleton', 'Micronaut');
    this.frameworkMap.set('Prototype', 'Micronaut');
    this.frameworkMap.set('RequestScope', 'Micronaut');
    this.frameworkMap.set('Inject', 'Micronaut');
    this.frameworkMap.set('Named', 'Micronaut');
    this.frameworkMap.set('Qualifier', 'Micronaut');
    this.frameworkMap.set('Primary', 'Micronaut');
    this.frameworkMap.set('Secondary', 'Micronaut');
    this.frameworkMap.set('Factory', 'Micronaut');
    this.frameworkMap.set('Bean', 'Micronaut');
    this.frameworkMap.set('Context', 'Micronaut');

    // Micronaut HTTP
    this.frameworkMap.set('Controller', 'Micronaut');
    this.frameworkMap.set('Get', 'Micronaut');
    this.frameworkMap.set('Post', 'Micronaut');
    this.frameworkMap.set('Put', 'Micronaut');
    this.frameworkMap.set('Delete', 'Micronaut');
    this.frameworkMap.set('Patch', 'Micronaut');
    this.frameworkMap.set('Head', 'Micronaut');
    this.frameworkMap.set('Options', 'Micronaut');
    this.frameworkMap.set('Produces', 'Micronaut');
    this.frameworkMap.set('Consumes', 'Micronaut');
    this.frameworkMap.set('PathVariable', 'Micronaut');
    this.frameworkMap.set('QueryValue', 'Micronaut');
    this.frameworkMap.set('Header', 'Micronaut');
    this.frameworkMap.set('CookieValue', 'Micronaut');
    this.frameworkMap.set('Body', 'Micronaut');
    this.frameworkMap.set('Part', 'Micronaut');

    // Micronaut Configuration
    this.frameworkMap.set('ConfigurationProperties', 'Micronaut');
    this.frameworkMap.set('Property', 'Micronaut');
    this.frameworkMap.set('Value', 'Micronaut');
    this.frameworkMap.set('EachProperty', 'Micronaut');
    this.frameworkMap.set('EachBean', 'Micronaut');

    // Micronaut Validation
    this.frameworkMap.set('Valid', 'Micronaut');
    this.frameworkMap.set('NotNull', 'Micronaut');
    this.frameworkMap.set('NotEmpty', 'Micronaut');
    this.frameworkMap.set('NotBlank', 'Micronaut');
    this.frameworkMap.set('Size', 'Micronaut');
    this.frameworkMap.set('Min', 'Micronaut');
    this.frameworkMap.set('Max', 'Micronaut');
    this.frameworkMap.set('Email', 'Micronaut');
    this.frameworkMap.set('Pattern', 'Micronaut');

    // Micronaut Security
    this.frameworkMap.set('Secured', 'Micronaut Security');
    this.frameworkMap.set('RolesAllowed', 'Micronaut Security');
    this.frameworkMap.set('PreAuthorize', 'Micronaut Security');
    this.frameworkMap.set('PostAuthorize', 'Micronaut Security');

    // Micronaut AOP
    this.frameworkMap.set('Around', 'Micronaut');
    this.frameworkMap.set('AroundConstruct', 'Micronaut');
    this.frameworkMap.set('InterceptorBean', 'Micronaut');
    this.frameworkMap.set('Introduction', 'Micronaut');

    // Micronaut Events
    this.frameworkMap.set('EventListener', 'Micronaut');
    this.frameworkMap.set('Async', 'Micronaut');

    // Micronaut Scheduling
    this.frameworkMap.set('Scheduled', 'Micronaut');

    // Micronaut Data
    this.frameworkMap.set('Repository', 'Micronaut Data');
    this.frameworkMap.set('JdbcRepository', 'Micronaut Data');
    this.frameworkMap.set('Query', 'Micronaut Data');
    this.frameworkMap.set('Id', 'Micronaut Data');
    this.frameworkMap.set('GeneratedValue', 'Micronaut Data');
    this.frameworkMap.set('MappedEntity', 'Micronaut Data');
    this.frameworkMap.set('Transactional', 'Micronaut Data');

    // Micronaut Testing
    this.frameworkMap.set('MicronautTest', 'Micronaut Test');
    this.frameworkMap.set('MockBean', 'Micronaut Test');
    this.frameworkMap.set('TestPropertyProvider', 'Micronaut Test');

    // Micronaut Cache
    this.frameworkMap.set('Cacheable', 'Micronaut Cache');
    this.frameworkMap.set('CacheInvalidate', 'Micronaut Cache');
    this.frameworkMap.set('CachePut', 'Micronaut Cache');

    // Micronaut Retry
    this.frameworkMap.set('Retryable', 'Micronaut');
    this.frameworkMap.set('CircuitBreaker', 'Micronaut');

    // Micronaut Client
    this.frameworkMap.set('Client', 'Micronaut HTTP Client');

    // Categories
    this.categoryMap.set('MicronautApplication', 'language');
    
    this.categoryMap.set('Singleton', 'injection');
    this.categoryMap.set('Prototype', 'injection');
    this.categoryMap.set('RequestScope', 'injection');
    this.categoryMap.set('Inject', 'injection');
    this.categoryMap.set('Named', 'injection');
    this.categoryMap.set('Qualifier', 'injection');
    this.categoryMap.set('Primary', 'injection');
    this.categoryMap.set('Secondary', 'injection');
    this.categoryMap.set('Factory', 'injection');
    this.categoryMap.set('Bean', 'injection');
    this.categoryMap.set('Context', 'injection');

    this.categoryMap.set('Controller', 'web');
    this.categoryMap.set('Get', 'web');
    this.categoryMap.set('Post', 'web');
    this.categoryMap.set('Put', 'web');
    this.categoryMap.set('Delete', 'web');
    this.categoryMap.set('Patch', 'web');
    this.categoryMap.set('Head', 'web');
    this.categoryMap.set('Options', 'web');
    this.categoryMap.set('Produces', 'web');
    this.categoryMap.set('Consumes', 'web');
    this.categoryMap.set('PathVariable', 'web');
    this.categoryMap.set('QueryValue', 'web');
    this.categoryMap.set('Header', 'web');
    this.categoryMap.set('CookieValue', 'web');
    this.categoryMap.set('Body', 'web');
    this.categoryMap.set('Part', 'web');
    this.categoryMap.set('Client', 'web');

    this.categoryMap.set('ConfigurationProperties', 'configuration');
    this.categoryMap.set('Property', 'configuration');
    this.categoryMap.set('Value', 'configuration');
    this.categoryMap.set('EachProperty', 'configuration');
    this.categoryMap.set('EachBean', 'configuration');

    this.categoryMap.set('Valid', 'validation');
    this.categoryMap.set('NotNull', 'validation');
    this.categoryMap.set('NotEmpty', 'validation');
    this.categoryMap.set('NotBlank', 'validation');
    this.categoryMap.set('Size', 'validation');
    this.categoryMap.set('Min', 'validation');
    this.categoryMap.set('Max', 'validation');
    this.categoryMap.set('Email', 'validation');
    this.categoryMap.set('Pattern', 'validation');

    this.categoryMap.set('Secured', 'security');
    this.categoryMap.set('RolesAllowed', 'security');
    this.categoryMap.set('PreAuthorize', 'security');
    this.categoryMap.set('PostAuthorize', 'security');

    this.categoryMap.set('Around', 'aop');
    this.categoryMap.set('AroundConstruct', 'aop');
    this.categoryMap.set('InterceptorBean', 'aop');
    this.categoryMap.set('Introduction', 'aop');

    this.categoryMap.set('EventListener', 'events');
    this.categoryMap.set('Async', 'performance');
    this.categoryMap.set('Scheduled', 'performance');

    this.categoryMap.set('Repository', 'persistence');
    this.categoryMap.set('JdbcRepository', 'persistence');
    this.categoryMap.set('Query', 'persistence');
    this.categoryMap.set('Id', 'persistence');
    this.categoryMap.set('GeneratedValue', 'persistence');
    this.categoryMap.set('MappedEntity', 'persistence');
    this.categoryMap.set('Transactional', 'persistence');

    this.categoryMap.set('MicronautTest', 'testing');
    this.categoryMap.set('MockBean', 'testing');
    this.categoryMap.set('TestPropertyProvider', 'testing');

    this.categoryMap.set('Cacheable', 'performance');
    this.categoryMap.set('CacheInvalidate', 'performance');
    this.categoryMap.set('CachePut', 'performance');
    this.categoryMap.set('Retryable', 'performance');
    this.categoryMap.set('CircuitBreaker', 'performance');
  }

  private initializeImportPatterns(): void {
    // Micronaut Core - High confidence
    this.addImportPattern('io.micronaut.*', 95, 'Micronaut');
    this.addImportPattern('io.micronaut.context.*', 95, 'Micronaut');
    this.addImportPattern('io.micronaut.runtime.*', 95, 'Micronaut');
    this.addImportPattern('io.micronaut.core.*', 90, 'Micronaut');

    // Micronaut HTTP
    this.addImportPattern('io.micronaut.http.*', 95, 'Micronaut');
    this.addImportPattern('io.micronaut.http.annotation.*', 95, 'Micronaut');
    this.addImportPattern('io.micronaut.http.client.*', 90, 'Micronaut HTTP Client');

    // Micronaut Configuration
    this.addImportPattern('io.micronaut.context.annotation.*', 90, 'Micronaut');
    this.addImportPattern('io.micronaut.configuration.*', 85, 'Micronaut');

    // Micronaut Validation
    this.addImportPattern('io.micronaut.validation.*', 85, 'Micronaut');
    this.addImportPattern('jakarta.validation.*', 80, 'Micronaut');
    this.addImportPattern('javax.validation.*', 75, 'Micronaut');

    // Micronaut Security
    this.addImportPattern('io.micronaut.security.*', 90, 'Micronaut Security');

    // Micronaut AOP
    this.addImportPattern('io.micronaut.aop.*', 85, 'Micronaut');

    // Micronaut Data
    this.addImportPattern('io.micronaut.data.*', 95, 'Micronaut Data');

    // Micronaut Testing
    this.addImportPattern('io.micronaut.test.*', 95, 'Micronaut Test');

    // Micronaut Cache
    this.addImportPattern('io.micronaut.cache.*', 85, 'Micronaut Cache');

    // Micronaut Scheduling
    this.addImportPattern('io.micronaut.scheduling.*', 85, 'Micronaut');

    // Micronaut Inject
    this.addImportPattern('jakarta.inject.*', 75, 'Micronaut');
    this.addImportPattern('javax.inject.*', 70, 'Micronaut');
  }
}


================================================
FILE: src/scanner/parsers/framework-detection/java/frameworks/MockitoFramework.ts
================================================
import { FrameworkModule } from '../../FrameworkModule.js';

/**
 * Mockito testing framework detection module
 * Handles Mockito mocking annotations
 */
export class MockitoFramework extends FrameworkModule {
  constructor() {
    super();
    this.initializeMappings();
  }

  getFrameworkName(): string {
    return 'Mockito';
  }

  protected initializeMappings(): void {
    this.initializeAnnotationMappings();
    this.initializeImportPatterns();
  }

  private initializeAnnotationMappings(): void {
    // Mockito Core Annotations
    this.frameworkMap.set('Mock', 'Mockito');
    this.frameworkMap.set('Spy', 'Mockito');
    this.frameworkMap.set('InjectMocks', 'Mockito');
    this.frameworkMap.set('Captor', 'Mockito');
    this.frameworkMap.set('MockBean', 'Mockito');
    this.frameworkMap.set('SpyBean', 'Mockito');

    // Mockito BDD Annotations
    this.frameworkMap.set('MockitoSettings', 'Mockito');
    this.frameworkMap.set('ExtendWith', 'Mockito');

    // Categories - all are testing
    this.categoryMap.set('Mock', 'testing');
    this.categoryMap.set('Spy', 'testing');
    this.categoryMap.set('InjectMocks', 'testing');
    this.categoryMap.set('Captor', 'testing');
    this.categoryMap.set('MockBean', 'testing');
    this.categoryMap.set('SpyBean', 'testing');
    this.categoryMap.set('MockitoSettings', 'testing');
    this.categoryMap.set('ExtendWith', 'testing');
  }

  private initializeImportPatterns(): void {
    // Mockito Core - High confidence
    this.addImportPattern('org.mockito.*', 95, 'Mockito');
    this.addImportPattern('org.mockito.junit.*', 90, 'Mockito');
    this.addImportPattern('org.mockito.runners.*', 85, 'Mockito');

    // Mockito BDD
    this.addImportPattern('org.mockito.BDDMockito', 85, 'Mockito');

    // Mockito ArgumentMatchers
    this.addImportPattern('org.mockito.ArgumentMatchers', 85, 'Mockito');

    // Mockito Verification
    this.addImportPattern('org.mockito.verification.*', 80, 'Mockito');

    // Mockito Answers
    this.addImportPattern('org.mockito.stubbing.*', 80, 'Mockito');

    // Mockito Inline (for final classes)
    this.addImportPattern('org.mockito.MockedStatic', 80, 'Mockito');
    this.addImportPattern('org.mockito.MockedConstruction', 80, 'Mockito');

    // Spring Boot Test Integration
    this.addImportPattern('org.springframework.boot.test.mock.mockito.*', 85, 'Mockito');
  }
}


================================================
FILE: src/scanner/parsers/framework-detection/java/frameworks/PlayFramework.ts
================================================
import { FrameworkModule } from '../../FrameworkModule.js';

/**
 * Play Framework detection module
 * Handles reactive web framework for Java and Scala
 */
export class PlayFramework extends FrameworkModule {
  constructor() {
    super();
    this.initializeMappings();
  }

  getFrameworkName(): string {
    return 'Play Framework';
  }

  protected initializeMappings(): void {
    this.initializeAnnotationMappings();
    this.initializeImportPatterns();
  }

  private initializeAnnotationMappings(): void {
    // Play Framework Core Annotations
    this.frameworkMap.set('Controller', 'Play Framework');
    this.frameworkMap.set('With', 'Play Framework');
    this.frameworkMap.set('BodyParser', 'Play Framework');
    this.frameworkMap.set('Security', 'Play Framework');

    // Play Framework Dependency Injection
    this.frameworkMap.set('Inject', 'Play Framework');
    this.frameworkMap.set('Singleton', 'Play Framework');
    this.frameworkMap.set('Named', 'Play Framework');

    // Play Framework Caching
    this.frameworkMap.set('Cached', 'Play Framework');

    // Play Framework Database
    this.frameworkMap.set('Transactional', 'Play Framework');

    // Play Framework Validation (using Bean Validation)
    this.frameworkMap.set('Valid', 'Play Framework');
    this.frameworkMap.set('NotNull', 'Play Framework');
    this.frameworkMap.set('NotEmpty', 'Play Framework');
    this.frameworkMap.set('Size', 'Play Framework');
    this.frameworkMap.set('Min', 'Play Framework');
    this.frameworkMap.set('Max', 'Play Framework');
    this.frameworkMap.set('Pattern', 'Play Framework');
    this.frameworkMap.set('Email', 'Play Framework');

    // Play Framework Forms
    this.frameworkMap.set('Constraints', 'Play Framework');

    // Categories
    this.categoryMap.set('Controller', 'web');
    this.categoryMap.set('With', 'web');
    this.categoryMap.set('BodyParser', 'web');

    this.categoryMap.set('Security', 'security');

    this.categoryMap.set('Inject', 'injection');
    this.categoryMap.set('Singleton', 'injection');
    this.categoryMap.set('Named', 'injection');

    this.categoryMap.set('Cached', 'performance');

    this.categoryMap.set('Transactional', 'persistence');

    this.categoryMap.set('Valid', 'validation');
    this.categoryMap.set('NotNull', 'validation');
    this.categoryMap.set('NotEmpty', 'validation');
    this.categoryMap.set('Size', 'validation');
    this.categoryMap.set('Min', 'validation');
    this.categoryMap.set('Max', 'validation');
    this.categoryMap.set('Pattern', 'validation');
    this.categoryMap.set('Email', 'validation');
    this.categoryMap.set('Constraints', 'validation');
  }

  private initializeImportPatterns(): void {
    // Play Framework Core - High confidence
    this.addImportPattern('play.*', 95, 'Play Framework');
    this.addImportPattern('play.mvc.*', 95, 'Play Framework');
    this.addImportPattern('play.data.*', 90, 'Play Framework');
    this.addImportPattern('play.libs.*', 85, 'Play Framework');
    this.addImportPattern('play.cache.*', 85, 'Play Framework');
    this.addImportPattern('play.db.*', 85, 'Play Framework');

    // Play Framework Security
    this.addImportPattern('play.mvc.Security.*', 90, 'Play Framework');

    // Play Framework Validation
    this.addImportPattern('play.data.validation.*', 85, 'Play Framework');

    // Play Framework Configuration
    this.addImportPattern('play.Configuration', 85, 'Play Framework');
    this.addImportPattern('play.inject.*', 85, 'Play Framework');

    // Play Framework Testing
    this.addImportPattern('play.test.*', 90, 'Play Framework');

    // Play Framework JSON
    this.addImportPattern('play.libs.Json', 80, 'Play Framework');

    // Play Framework Akka (for reactive features)
    this.addImportPattern('akka.*', 70, 'Play Framework');

    // Dependency injection (Google Guice)
    this.addImportPattern('com.google.inject.*', 75, 'Play Framework');
    this.addImportPattern('javax.inject.*', 70, 'Play Framework');
    this.addImportPattern('jakarta.inject.*', 75, 'Play Framework');
  }
}


================================================
FILE: src/scanner/parsers/framework-detection/java/frameworks/QuarkusFramework.ts
================================================
import { FrameworkModule } from '../../FrameworkModule.js';

/**
 * Quarkus framework detection module
 * Handles supersonic, subatomic Java for cloud-native and Kubernetes
 */
export class QuarkusFramework extends FrameworkModule {
  constructor() {
    super();
    this.initializeMappings();
  }

  getFrameworkName(): string {
    return 'Quarkus';
  }

  protected initializeMappings(): void {
    this.initializeAnnotationMappings();
    this.initializeImportPatterns();
  }

  private initializeAnnotationMappings(): void {
    // Quarkus Core Annotations
    this.frameworkMap.set('QuarkusMain', 'Quarkus');
    this.frameworkMap.set('QuarkusApplication', 'Quarkus');
    this.frameworkMap.set('ApplicationScoped', 'Quarkus');
    this.frameworkMap.set('Singleton', 'Quarkus');
    this.frameworkMap.set('RequestScoped', 'Quarkus');
    this.frameworkMap.set('Dependent', 'Quarkus');

    // Quarkus REST (JAX-RS)
    this.frameworkMap.set('Path', 'Quarkus');
    this.frameworkMap.set('GET', 'Quarkus');
    this.frameworkMap.set('POST', 'Quarkus');
    this.frameworkMap.set('PUT', 'Quarkus');
    this.frameworkMap.set('DELETE', 'Quarkus');
    this.frameworkMap.set('PATCH', 'Quarkus');
    this.frameworkMap.set('Produces', 'Quarkus');
    this.frameworkMap.set('Consumes', 'Quarkus');
    this.frameworkMap.set('PathParam', 'Quarkus');
    this.frameworkMap.set('QueryParam', 'Quarkus');
    this.frameworkMap.set('HeaderParam', 'Quarkus');
    this.frameworkMap.set('FormParam', 'Quarkus');

    // Quarkus Configuration
    this.frameworkMap.set('ConfigProperty', 'Quarkus');
    this.frameworkMap.set('ConfigMapping', 'Quarkus');
    this.frameworkMap.set('ConfigRoot', 'Quarkus');

    // Quarkus Injection
    this.frameworkMap.set('Inject', 'Quarkus');
    this.frameworkMap.set('Named', 'Quarkus');
    this.frameworkMap.set('Produces', 'Quarkus');
    this.frameworkMap.set('Alternative', 'Quarkus');
    this.frameworkMap.set('Priority', 'Quarkus');

    // Quarkus Reactive
    this.frameworkMap.set('Blocking', 'Quarkus');
    this.frameworkMap.set('NonBlocking', 'Quarkus');
    this.frameworkMap.set('RunOnVirtualThread', 'Quarkus');

    // Quarkus Security
    this.frameworkMap.set('RolesAllowed', 'Quarkus Security');
    this.frameworkMap.set('PermitAll', 'Quarkus Security');
    this.frameworkMap.set('DenyAll', 'Quarkus Security');
    this.frameworkMap.set('Authenticated', 'Quarkus Security');

    // Quarkus Persistence
    this.frameworkMap.set('PersistenceContext', 'Quarkus');
    this.frameworkMap.set('Transactional', 'Quarkus');

    // Quarkus Scheduler
    this.frameworkMap.set('Scheduled', 'Quarkus');

    // Quarkus Events
    this.frameworkMap.set('Observes', 'Quarkus');
    this.frameworkMap.set('ObservesAsync', 'Quarkus');

    // Quarkus Testing
    this.frameworkMap.set('QuarkusTest', 'Quarkus Test');
    this.frameworkMap.set('NativeImageTest', 'Quarkus Test');
    this.frameworkMap.set('TestProfile', 'Quarkus Test');
    this.frameworkMap.set('QuarkusTestResource', 'Quarkus Test');
    this.frameworkMap.set('QuarkusIntegrationTest', 'Quarkus Test');

    // Quarkus Health
    this.frameworkMap.set('Health', 'Quarkus Health');
    this.frameworkMap.set('Liveness', 'Quarkus Health');
    this.frameworkMap.set('Readiness', 'Quarkus Health');

    // Quarkus Metrics
    this.frameworkMap.set('Counted', 'Quarkus Metrics');
    this.frameworkMap.set('Timed', 'Quarkus Metrics');
    this.frameworkMap.set('Gauge', 'Quarkus Metrics');
    this.frameworkMap.set('Metered', 'Quarkus Metrics');

    // Quarkus OpenAPI
    this.frameworkMap.set('Operation', 'Quarkus OpenAPI');
    this.frameworkMap.set('APIResponse', 'Quarkus OpenAPI');
    this.frameworkMap.set('Parameter', 'Quarkus OpenAPI');
    this.frameworkMap.set('Schema', 'Quarkus OpenAPI');

    // Categories
    this.categoryMap.set('QuarkusMain', 'language');
    this.categoryMap.set('QuarkusApplication', 'language');
    
    this.categoryMap.set('ApplicationScoped', 'injection');
    this.categoryMap.set('Singleton', 'injection');
    this.categoryMap.set('RequestScoped', 'injection');
    this.categoryMap.set('Dependent', 'injection');
    this.categoryMap.set('Inject', 'injection');
    this.categoryMap.set('Named', 'injection');
    this.categoryMap.set('Produces', 'injection');
    this.categoryMap.set('Alternative', 'injection');
    this.categoryMap.set('Priority', 'injection');

    this.categoryMap.set('Path', 'web');
    this.categoryMap.set('GET', 'web');
    this.categoryMap.set('POST', 'web');
    this.categoryMap.set('PUT', 'web');
    this.categoryMap.set('DELETE', 'web');
    this.categoryMap.set('PATCH', 'web');
    this.categoryMap.set('Produces', 'web');
    this.categoryMap.set('Consumes', 'web');
    this.categoryMap.set('PathParam', 'web');
    this.categoryMap.set('QueryParam', 'web');
    this.categoryMap.set('HeaderParam', 'web');
    this.categoryMap.set('FormParam', 'web');

    this.categoryMap.set('ConfigProperty', 'configuration');
    this.categoryMap.set('ConfigMapping', 'configuration');
    this.categoryMap.set('ConfigRoot', 'configuration');

    this.categoryMap.set('Blocking', 'performance');
    this.categoryMap.set('NonBlocking', 'performance');
    this.categoryMap.set('RunOnVirtualThread', 'performance');
    this.categoryMap.set('Scheduled', 'performance');

    this.categoryMap.set('RolesAllowed', 'security');
    this.categoryMap.set('PermitAll', 'security');
    this.categoryMap.set('DenyAll', 'security');
    this.categoryMap.set('Authenticated', 'security');

    this.categoryMap.set('PersistenceContext', 'persistence');
    this.categoryMap.set('Transactional', 'persistence');

    this.categoryMap.set('Observes', 'events');
    this.categoryMap.set('ObservesAsync', 'events');

    this.categoryMap.set('QuarkusTest', 'testing');
    this.categoryMap.set('NativeImageTest', 'testing');
    this.categoryMap.set('TestProfile', 'testing');
    this.categoryMap.set('QuarkusTestResource', 'testing');
    this.categoryMap.set('QuarkusIntegrationTest', 'testing');

    this.categoryMap.set('Health', 'monitoring');
    this.categoryMap.set('Liveness', 'monitoring');
    this.categoryMap.set('Readiness', 'monitoring');
    this.categoryMap.set('Counted', 'monitoring');
    this.categoryMap.set('Timed', 'monitoring');
    this.categoryMap.set('Gauge', 'monitoring');
    this.categoryMap.set('Metered', 'monitoring');

    this.categoryMap.set('Operation', 'documentation');
    this.categoryMap.set('APIResponse', 'documentation');
    this.categoryMap.set('Parameter', 'documentation');
    this.categoryMap.set('Schema', 'documentation');
  }

  private initializeImportPatterns(): void {
    // Quarkus Core - High confidence
    this.addImportPattern('io.quarkus.*', 95, 'Quarkus');
    this.addImportPattern('io.quarkus.runtime.*', 95, 'Quarkus');
    this.addImportPattern('io.quarkus.arc.*', 90, 'Quarkus');

    // Quarkus REST/JAX-RS
    this.addImportPattern('jakarta.ws.rs.*', 85, 'Quarkus');
    this.addImportPattern('javax.ws.rs.*', 80, 'Quarkus');

    // Quarkus Configuration
    this.addImportPattern('io.smallrye.config.*', 85, 'Quarkus');
    this.addImportPattern('org.eclipse.microprofile.config.*', 80, 'Quarkus');

    // Quarkus Testing
    this.addImportPattern('io.quarkus.test.*', 95, 'Quarkus Test');

    // Quarkus Security
    this.addImportPattern('io.quarkus.security.*', 90, 'Quarkus Security');
    this.addImportPattern('jakarta.annotation.security.*', 80, 'Quarkus Security');

    // Quarkus Health & Metrics
    this.addImportPattern('org.eclipse.microprofile.health.*', 85, 'Quarkus Health');
    this.addImportPattern('org.eclipse.microprofile.metrics.*', 85, 'Quarkus Metrics');

    // Quarkus OpenAPI
    this.addImportPattern('org.eclipse.microprofile.openapi.*', 85, 'Quarkus OpenAPI');

    // CDI (Context and Dependency Injection)
    this.addImportPattern('jakarta.enterprise.context.*', 75, 'Quarkus');
    this.addImportPattern('jakarta.inject.*', 75, 'Quarkus');
    this.addImportPattern('javax.enterprise.context.*', 70, 'Quarkus');
    this.addImportPattern('javax.inject.*', 70, 'Quarkus');

    // Quarkus Reactive
    this.addImportPattern('io.smallrye.mutiny.*', 80, 'Quarkus');
    this.addImportPattern('io.smallrye.common.annotation.*', 75, 'Quarkus');
  }
}


================================================
FILE: src/scanner/parsers/framework-detection/java/frameworks/SparkFramework.ts
================================================
import { FrameworkModule } from '../../FrameworkModule.js';

/**
 * Apache Spark framework detection module
 * Handles big data processing and analytics framework
 */
export class SparkFramework extends FrameworkModule {
  constructor() {
    super();
    this.initializeMappings();
  }

  getFrameworkName(): string {
    return 'Apache Spark';
  }

  protected initializeMappings(): void {
    this.initializeAnnotationMappings();
    this.initializeImportPatterns();
  }

  private initializeAnnotationMappings(): void {
    // Spark SQL Annotations (limited annotations in Spark)
    this.frameworkMap.set('Transient', 'Spark');

    // Categories
    this.categoryMap.set('Transient', 'serialization');
  }

  private initializeImportPatterns(): void {
    // Spark Core - High confidence
    this.addImportPattern('org.apache.spark.*', 95, 'Spark');
    this.addImportPattern('org.apache.spark.api.java.*', 95, 'Spark');
    this.addImportPattern('org.apache.spark.api.java.function.*', 90, 'Spark');

    // Spark SQL
    this.addImportPattern('org.apache.spark.sql.*', 95, 'Spark SQL');
    this.addImportPattern('org.apache.spark.sql.types.*', 90, 'Spark SQL');
    this.addImportPattern('org.apache.spark.sql.functions.*', 90, 'Spark SQL');

    // Spark Streaming
    this.addImportPattern('org.apache.spark.streaming.*', 95, 'Spark Streaming');
    this.addImportPattern('org.apache.spark.streaming.api.java.*', 90, 'Spark Streaming');

    // Spark MLlib
    this.addImportPattern('org.apache.spark.mllib.*', 90, 'Spark MLlib');
    this.addImportPattern('org.apache.spark.ml.*', 90, 'Spark ML');

    // Spark GraphX
    this.addImportPattern('org.apache.spark.graphx.*', 85, 'Spark GraphX');

    // Spark Util
    this.addImportPattern('org.apache.spark.util.*', 80, 'Spark');

    // Spark Storage
    this.addImportPattern('org.apache.spark.storage.*', 80, 'Spark');

    // Spark Broadcast
    this.addImportPattern('org.apache.spark.broadcast.*', 80, 'Spark');

    // Spark Serializer
    this.addImportPattern('org.apache.spark.serializer.*', 75, 'Spark');
  }
}


================================================
FILE: src/scanner/parsers/framework-detection/java/frameworks/SpringBootFramework.ts
================================================
import { FrameworkModule } from '../../FrameworkModule.js';

/**
 * Spring Boot framework detection module
 * Handles Spring Boot, Spring Security, and Spring Test annotations
 */
export class SpringBootFramework extends FrameworkModule {
  constructor() {
    super();
    this.initializeMappings();
  }

  getFrameworkName(): string {
    return 'Spring Boot';
  }

  protected initializeMappings(): void {
    this.initializeAnnotationMappings();
    this.initializeImportPatterns();
  }

  private initializeAnnotationMappings(): void {
    // Spring Boot Core
    this.frameworkMap.set('SpringBootApplication', 'Spring Boot');
    this.frameworkMap.set('RestController', 'Spring Boot');
    this.frameworkMap.set('Controller', 'Spring Boot');
    this.frameworkMap.set('Service', 'Spring Boot');
    this.frameworkMap.set('Component', 'Spring Boot');
    this.frameworkMap.set('Repository', 'Spring Boot');
    this.frameworkMap.set('Autowired', 'Spring Boot');
    this.frameworkMap.set('Value', 'Spring Boot');
    this.frameworkMap.set('Configuration', 'Spring Boot');
    this.frameworkMap.set('Bean', 'Spring Boot');
    this.frameworkMap.set('RequestMapping', 'Spring Boot');
    this.frameworkMap.set('GetMapping', 'Spring Boot');
    this.frameworkMap.set('PostMapping', 'Spring Boot');
    this.frameworkMap.set('PutMapping', 'Spring Boot');
    this.frameworkMap.set('DeleteMapping', 'Spring Boot');
    this.frameworkMap.set('PathVariable', 'Spring Boot');
    this.frameworkMap.set('RequestParam', 'Spring Boot');
    this.frameworkMap.set('RequestBody', 'Spring Boot');
    this.frameworkMap.set('ResponseBody', 'Spring Boot');
    this.frameworkMap.set('CrossOrigin', 'Spring Boot');
    this.frameworkMap.set('Valid', 'Spring Boot');
    this.frameworkMap.set('Validated', 'Spring Boot');
    this.frameworkMap.set('Transactional', 'Spring Boot');

    // Spring Security
    this.frameworkMap.set('PreAuthorize', 'Spring Security');
    this.frameworkMap.set('PostAuthorize', 'Spring Security');
    this.frameworkMap.set('Secured', 'Spring Security');
    this.frameworkMap.set('RolesAllowed', 'Spring Security');

    // Spring Test
    this.frameworkMap.set('MockBean', 'Spring Test');
    this.frameworkMap.set('WebMvcTest', 'Spring Test');
    this.frameworkMap.set('SpringBootTest', 'Spring Test');
    this.frameworkMap.set('DataJpaTest', 'Spring Test');
    this.frameworkMap.set('TestConfiguration', 'Spring Test');
    this.frameworkMap.set('MockMvcTest', 'Spring Test');
    this.frameworkMap.set('JsonTest', 'Spring Test');
    this.frameworkMap.set('JdbcTest', 'Spring Test');

    // Spring Boot Configuration
    this.frameworkMap.set('ConfigurationProperties', 'Spring Boot');
    this.frameworkMap.set('EnableConfigurationProperties', 'Spring Boot');
    this.frameworkMap.set('ConditionalOnProperty', 'Spring Boot');
    this.frameworkMap.set('ConditionalOnClass', 'Spring Boot');
    this.frameworkMap.set('ConditionalOnBean', 'Spring Boot');
    this.frameworkMap.set('ConditionalOnMissingBean', 'Spring Boot');

    // Spring Boot Caching
    this.frameworkMap.set('EnableCaching', 'Spring Boot');
    this.frameworkMap.set('Cacheable', 'Spring Boot');
    this.frameworkMap.set('CacheEvict', 'Spring Boot');
    this.frameworkMap.set('CachePut', 'Spring Boot');

    // Spring Boot Scheduling
    this.frameworkMap.set('EnableScheduling', 'Spring Boot');
    this.frameworkMap.set('Scheduled', 'Spring Boot');
    this.frameworkMap.set('Async', 'Spring Boot');
    this.frameworkMap.set('EnableAsync', 'Spring Boot');

    // Spring Boot JPA
    this.frameworkMap.set('EnableJpaRepositories', 'Spring Boot');
    this.frameworkMap.set('Query', 'Spring Boot');
    this.frameworkMap.set('Modifying', 'Spring Boot');

    // Spring Boot Actuator
    this.frameworkMap.set('Endpoint', 'Spring Boot Actuator');
    this.frameworkMap.set('ReadOperation', 'Spring Boot Actuator');
    this.frameworkMap.set('WriteOperation', 'Spring Boot Actuator');
    this.frameworkMap.set('DeleteOperation', 'Spring Boot Actuator');

    // Spring Cloud
    this.frameworkMap.set('EnableEurekaClient', 'Spring Cloud');
    this.frameworkMap.set('FeignClient', 'Spring Cloud');
    this.frameworkMap.set('LoadBalanced', 'Spring Cloud');
    this.frameworkMap.set('CircuitBreaker', 'Spring Cloud');

    // Categories
    this.categoryMap.set('SpringBootApplication', 'language');
    this.categoryMap.set('Autowired', 'injection');
    this.categoryMap.set('Value', 'injection');
    this.categoryMap.set('Component', 'injection');
    this.categoryMap.set('Service', 'injection');
    this.categoryMap.set('Repository', 'injection');
    this.categoryMap.set('Bean', 'injection');
    this.categoryMap.set('Configuration', 'injection');
    
    this.categoryMap.set('RestController', 'web');
    this.categoryMap.set('Controller', 'web');
    this.categoryMap.set('RequestMapping', 'web');
    this.categoryMap.set('GetMapping', 'web');
    this.categoryMap.set('PostMapping', 'web');
    this.categoryMap.set('PutMapping', 'web');
    this.categoryMap.set('DeleteMapping', 'web');
    this.categoryMap.set('PathVariable', 'web');
    this.categoryMap.set('RequestParam', 'web');
    this.categoryMap.set('RequestBody', 'web');
    this.categoryMap.set('ResponseBody', 'web');
    this.categoryMap.set('CrossOrigin', 'web');
    
    this.categoryMap.set('Transactional', 'persistence');
    this.categoryMap.set('Valid', 'validation');
    this.categoryMap.set('Validated', 'validation');
    
    this.categoryMap.set('PreAuthorize', 'security');
    this.categoryMap.set('PostAuthorize', 'security');
    this.categoryMap.set('Secured', 'security');
    this.categoryMap.set('RolesAllowed', 'security');
    
    this.categoryMap.set('MockBean', 'testing');
    this.categoryMap.set('WebMvcTest', 'testing');
    this.categoryMap.set('SpringBootTest', 'testing');
    this.categoryMap.set('DataJpaTest', 'testing');
    this.categoryMap.set('TestConfiguration', 'testing');
    this.categoryMap.set('MockMvcTest', 'testing');
    this.categoryMap.set('JsonTest', 'testing');
    this.categoryMap.set('JdbcTest', 'testing');

    // Configuration categories
    this.categoryMap.set('ConfigurationProperties', 'injection');
    this.categoryMap.set('EnableConfigurationProperties', 'injection');
    this.categoryMap.set('ConditionalOnProperty', 'injection');
    this.categoryMap.set('ConditionalOnClass', 'injection');
    this.categoryMap.set('ConditionalOnBean', 'injection');
    this.categoryMap.set('ConditionalOnMissingBean', 'injection');

    // Performance categories
    this.categoryMap.set('EnableCaching', 'performance');
    this.categoryMap.set('Cacheable', 'performance');
    this.categoryMap.set('CacheEvict', 'performance');
    this.categoryMap.set('CachePut', 'performance');
    this.categoryMap.set('Scheduled', 'performance');
    this.categoryMap.set('Async', 'performance');
    this.categoryMap.set('EnableScheduling', 'performance');
    this.categoryMap.set('EnableAsync', 'performance');

    // Persistence categories
    this.categoryMap.set('EnableJpaRepositories', 'persistence');
    this.categoryMap.set('Query', 'persistence');
    this.categoryMap.set('Modifying', 'persistence');

    // Web/Infrastructure categories
    this.categoryMap.set('Endpoint', 'web');
    this.categoryMap.set('ReadOperation', 'web');
    this.categoryMap.set('WriteOperation', 'web');
    this.categoryMap.set('DeleteOperation', 'web');
    this.categoryMap.set('EnableEurekaClient', 'web');
    this.categoryMap.set('FeignClient', 'web');
    this.categoryMap.set('LoadBalanced', 'web');
    this.categoryMap.set('CircuitBreaker', 'web');
  }

  private initializeImportPatterns(): void {
    // Spring Boot Core - High confidence
    this.addImportPattern('org.springframework.boot.*', 95, 'Spring Boot');
    this.addImportPattern('org.springframework.boot.autoconfigure.*', 95, 'Spring Boot');
    this.addImportPattern('org.springframework.boot.context.*', 90, 'Spring Boot');
    
    // Spring Framework - Medium-high confidence (could be plain Spring)
    this.addImportPattern('org.springframework.web.bind.annotation.*', 85, 'Spring Boot');
    this.addImportPattern('org.springframework.stereotype.*', 80, 'Spring Boot');
    this.addImportPattern('org.springframework.beans.factory.annotation.*', 75, 'Spring Boot');
    this.addImportPattern('org.springframework.context.annotation.*', 75, 'Spring Boot');
    this.addImportPattern('org.springframework.web.*', 70, 'Spring Boot');
    this.addImportPattern('org.springframework.data.*', 70, 'Spring Boot');
    
    // Spring Security
    this.addImportPattern('org.springframework.security.*', 85, 'Spring Security');
    this.addImportPattern('org.springframework.security.access.prepost.*', 90, 'Spring Security');
    this.addImportPattern('org.springframework.security.config.annotation.*', 85, 'Spring Security');
    
    // Spring Test
    this.addImportPattern('org.springframework.boot.test.*', 95, 'Spring Test');
    this.addImportPattern('org.springframework.test.*', 80, 'Spring Test');
    
    // Spring Cloud
    this.addImportPattern('org.springframework.cloud.*', 95, 'Spring Cloud');
    this.addImportPattern('org.springframework.cloud.openfeign.*', 95, 'Spring Cloud');
    this.addImportPattern('org.springframework.cloud.netflix.*', 90, 'Spring Cloud');
    this.addImportPattern('org.springframework.cloud.circuitbreaker.*', 90, 'Spring Cloud');
    
    // Spring Boot Actuator
    this.addImportPattern('org.springframework.boot.actuate.*', 95, 'Spring Boot Actuator');
  }
}


================================================
FILE: src/scanner/parsers/framework-detection/java/frameworks/StrutsFramework.ts
================================================
import { FrameworkModule } from '../../FrameworkModule.js';

/**
 * Apache Struts framework detection module
 * Handles MVC framework for web applications
 */
export class StrutsFramework extends FrameworkModule {
  constructor() {
    super();
    this.initializeMappings();
  }

  getFrameworkName(): string {
    return 'Apache Struts';
  }

  protected initializeMappings(): void {
    this.initializeAnnotationMappings();
    this.initializeImportPatterns();
  }

  private initializeAnnotationMappings(): void {
    // Struts2 Core Annotations
    this.frameworkMap.set('Action', 'Struts');
    this.frameworkMap.set('Actions', 'Struts');
    this.frameworkMap.set('Result', 'Struts');
    this.frameworkMap.set('Results', 'Struts');
    this.frameworkMap.set('Namespace', 'Struts');
    this.frameworkMap.set('ParentPackage', 'Struts');
    this.frameworkMap.set('InterceptorRef', 'Struts');
    this.frameworkMap.set('InterceptorRefs', 'Struts');

    // Struts2 Convention Plugin
    this.frameworkMap.set('ExceptionMapping', 'Struts');
    this.frameworkMap.set('ExceptionMappings', 'Struts');

    // Struts2 Validation
    this.frameworkMap.set('Validations', 'Struts');
    this.frameworkMap.set('RequiredFieldValidator', 'Struts');
    this.frameworkMap.set('RequiredStringValidator', 'Struts');
    this.frameworkMap.set('StringLengthFieldValidator', 'Struts');
    this.frameworkMap.set('EmailValidator', 'Struts');
    this.frameworkMap.set('RegexFieldValidator', 'Struts');
    this.frameworkMap.set('IntRangeFieldValidator', 'Struts');
    this.frameworkMap.set('DoubleRangeFieldValidator', 'Struts');
    this.frameworkMap.set('DateRangeFieldValidator', 'Struts');
    this.frameworkMap.set('ConditionalVisitorFieldValidator', 'Struts');
    this.frameworkMap.set('VisitorFieldValidator', 'Struts');
    this.frameworkMap.set('ConversionErrorFieldValidator', 'Struts');
    this.frameworkMap.set('ExpressionValidator', 'Struts');

    // Struts2 JSON Plugin
    this.frameworkMap.set('JSON', 'Struts JSON');
    this.frameworkMap.set('SMDMethod', 'Struts JSON');

    // Categories
    this.categoryMap.set('Action', 'web');
    this.categoryMap.set('Actions', 'web');
    this.categoryMap.set('Result', 'web');
    this.categoryMap.set('Results', 'web');
    this.categoryMap.set('Namespace', 'web');
    this.categoryMap.set('ParentPackage', 'web');
    this.categoryMap.set('InterceptorRef', 'web');
    this.categoryMap.set('InterceptorRefs', 'web');

    this.categoryMap.set('ExceptionMapping', 'error-handling');
    this.categoryMap.set('ExceptionMappings', 'error-handling');

    this.categoryMap.set('Validations', 'validation');
    this.categoryMap.set('RequiredFieldValidator', 'validation');
    this.categoryMap.set('RequiredStringValidator', 'validation');
    this.categoryMap.set('StringLengthFieldValidator', 'validation');
    this.categoryMap.set('EmailValidator', 'validation');
    this.categoryMap.set('RegexFieldValidator', 'validation');
    this.categoryMap.set('IntRangeFieldValidator', 'validation');
    this.categoryMap.set('DoubleRangeFieldValidator', 'validation');
    this.categoryMap.set('DateRangeFieldValidator', 'validation');
    this.categoryMap.set('ConditionalVisitorFieldValidator', 'validation');
    this.categoryMap.set('VisitorFieldValidator', 'validation');
    this.categoryMap.set('ConversionErrorFieldValidator', 'validation');
    this.categoryMap.set('ExpressionValidator', 'validation');

    this.categoryMap.set('JSON', 'serialization');
    this.categoryMap.set('SMDMethod', 'serialization');
  }

  private initializeImportPatterns(): void {
    // Struts2 Core - High confidence
    this.addImportPattern('org.apache.struts2.*', 95, 'Struts');
    this.addImportPattern('com.opensymphony.xwork2.*', 90, 'Struts');

    // Struts2 Convention Plugin
    this.addImportPattern('org.apache.struts2.convention.annotation.*', 95, 'Struts');

    // Struts2 Validation
    this.addImportPattern('com.opensymphony.xwork2.validator.annotations.*', 90, 'Struts');

    // Struts2 JSON Plugin
    this.addImportPattern('org.apache.struts2.json.*', 85, 'Struts JSON');

    // Struts2 Spring Plugin
    this.addImportPattern('org.apache.struts2.spring.*', 80, 'Struts Spring');

    // Struts2 Tiles Plugin
    this.addImportPattern('org.apache.struts2.tiles.*', 80, 'Struts Tiles');

    // Struts2 JUnit Plugin
    this.addImportPattern('org.apache.struts2.junit.*', 85, 'Struts Test');

    // Struts2 Config Browser Plugin
    this.addImportPattern('org.apache.struts2.config_browser.*', 75, 'Struts');

    // Struts2 REST Plugin
    this.addImportPattern('org.apache.struts2.rest.*', 80, 'Struts REST');

    // ActionSupport and related
    this.addImportPattern('com.opensymphony.xwork2.ActionSupport', 85, 'Struts');
    this.addImportPattern('com.opensymphony.xwork2.Action', 85, 'Struts');
  }
}


================================================
FILE: src/scanner/parsers/framework-detection/java/frameworks/VaadinFramework.ts
================================================
import { FrameworkModule } from '../../FrameworkModule.js';

/**
 * Vaadin framework detection module
 * Handles server-side UI framework for building rich web applications
 */
export class VaadinFramework extends FrameworkModule {
  constructor() {
    super();
    this.initializeMappings();
  }

  getFrameworkName(): string {
    return 'Vaadin';
  }

  protected initializeMappings(): void {
    this.initializeAnnotationMappings();
    this.initializeImportPatterns();
  }

  private initializeAnnotationMappings(): void {
    // Vaadin Route Annotations
    this.frameworkMap.set('Route', 'Vaadin');
    this.frameworkMap.set('RouteAlias', 'Vaadin');
    this.frameworkMap.set('RoutePrefix', 'Vaadin');
    this.frameworkMap.set('ParentLayout', 'Vaadin');
    this.frameworkMap.set('PageTitle', 'Vaadin');

    // Vaadin Theme Annotations
    this.frameworkMap.set('Theme', 'Vaadin');
    this.frameworkMap.set('NoTheme', 'Vaadin');
    this.frameworkMap.set('CssImport', 'Vaadin');
    this.frameworkMap.set('StyleSheet', 'Vaadin');
    this.frameworkMap.set('JavaScript', 'Vaadin');
    this.frameworkMap.set('HtmlImport', 'Vaadin');

    // Vaadin Security Annotations
    this.frameworkMap.set('PermitAll', 'Vaadin Security');
    this.frameworkMap.set('DenyAll', 'Vaadin Security');
    this.frameworkMap.set('RolesAllowed', 'Vaadin Security');
    this.frameworkMap.set('AnonymousAllowed', 'Vaadin Security');

    // Vaadin Component Annotations
    this.frameworkMap.set('Id', 'Vaadin');
    this.frameworkMap.set('Uses', 'Vaadin');

    // Vaadin PWA Annotations
    this.frameworkMap.set('PWA', 'Vaadin PWA');
    this.frameworkMap.set('Viewport', 'Vaadin');
    this.frameworkMap.set('Meta', 'Vaadin');
    this.frameworkMap.set('Inline', 'Vaadin');
    this.frameworkMap.set('BodySize', 'Vaadin');

    // Vaadin Spring Integration
    this.frameworkMap.set('SpringComponent', 'Vaadin Spring');
    this.frameworkMap.set('UIScope', 'Vaadin Spring');
    this.frameworkMap.set('VaadinSessionScope', 'Vaadin Spring');

    // Vaadin CDI Integration
    this.frameworkMap.set('VaadinServiceScoped', 'Vaadin CDI');
    this.frameworkMap.set('VaadinSessionScoped', 'Vaadin CDI');
    this.frameworkMap.set('VaadinServiceEnabled', 'Vaadin CDI');
    this.frameworkMap.set('RouteScoped', 'Vaadin CDI');

    // Vaadin Push
    this.frameworkMap.set('Push', 'Vaadin Push');

    // Categories
    this.categoryMap.set('Route', 'routing');
    this.categoryMap.set('RouteAlias', 'routing');
    this.categoryMap.set('RoutePrefix', 'routing');
    this.categoryMap.set('ParentLayout', 'routing');
    this.categoryMap.set('PageTitle', 'routing');

    this.categoryMap.set('Theme', 'styling');
    this.categoryMap.set('NoTheme', 'styling');
    this.categoryMap.set('CssImport', 'styling');
    this.categoryMap.set('StyleSheet', 'styling');
    this.categoryMap.set('JavaScript', 'styling');
    this.categoryMap.set('HtmlImport', 'styling');

    this.categoryMap.set('PermitAll', 'security');
    this.categoryMap.set('DenyAll', 'security');
    this.categoryMap.set('RolesAllowed', 'security');
    this.categoryMap.set('AnonymousAllowed', 'security');

    this.categoryMap.set('Id', 'ui');
    this.categoryMap.set('Uses', 'ui');

    this.categoryMap.set('PWA', 'pwa');
    this.categoryMap.set('Viewport', 'pwa');
    this.categoryMap.set('Meta', 'pwa');
    this.categoryMap.set('Inline', 'pwa');
    this.categoryMap.set('BodySize', 'pwa');

    this.categoryMap.set('SpringComponent', 'injection');
    this.categoryMap.set('UIScope', 'injection');
    this.categoryMap.set('VaadinSessionScope', 'injection');
    this.categoryMap.set('VaadinServiceScoped', 'injection');
    this.categoryMap.set('VaadinSessionScoped', 'injection');
    this.categoryMap.set('VaadinServiceEnabled', 'injection');
    this.categoryMap.set('RouteScoped', 'injection');

    this.categoryMap.set('Push', 'communication');
  }

  private initializeImportPatterns(): void {
    // Vaadin Core - High confidence
    this.addImportPattern('com.vaadin.*', 95, 'Vaadin');
    this.addImportPattern('com.vaadin.flow.*', 95, 'Vaadin');
    this.addImportPattern('com.vaadin.flow.component.*', 95, 'Vaadin');
    this.addImportPattern('com.vaadin.flow.router.*', 95, 'Vaadin');

    // Vaadin Components
    this.addImportPattern('com.vaadin.flow.component.button.*', 90, 'Vaadin');
    this.addImportPattern('com.vaadin.flow.component.textfield.*', 90, 'Vaadin');
    this.addImportPattern('com.vaadin.flow.component.grid.*', 90, 'Vaadin');
    this.addImportPattern('com.vaadin.flow.component.html.*', 90, 'Vaadin');
    this.addImportPattern('com.vaadin.flow.component.orderedlayout.*', 90, 'Vaadin');
    this.addImportPattern('com.vaadin.flow.component.formlayout.*', 85, 'Vaadin');
    this.addImportPattern('com.vaadin.flow.component.notification.*', 85, 'Vaadin');
    this.addImportPattern('com.vaadin.flow.component.dialog.*', 85, 'Vaadin');

    // Vaadin Data
    this.addImportPattern('com.vaadin.flow.data.*', 85, 'Vaadin');
    this.addImportPattern('com.vaadin.flow.data.binder.*', 85, 'Vaadin');
    this.addImportPattern('com.vaadin.flow.data.provider.*', 85, 'Vaadin');

    // Vaadin Server
    this.addImportPattern('com.vaadin.flow.server.*', 85, 'Vaadin');

    // Vaadin Theme
    this.addImportPattern('com.vaadin.flow.theme.*', 85, 'Vaadin');

    // Vaadin Security
    this.addImportPattern('com.vaadin.flow.server.auth.*', 85, 'Vaadin Security');

    // Vaadin Spring
    this.addImportPattern('com.vaadin.flow.spring.*', 90, 'Vaadin Spring');

    // Vaadin CDI
    this.addImportPattern('com.vaadin.cdi.*', 90, 'Vaadin CDI');

    // Vaadin Push
    this.addImportPattern('com.vaadin.flow.shared.communication.*', 80, 'Vaadin Push');

    // Vaadin Legacy (for Vaadin 8 and earlier)
    this.addImportPattern('com.vaadin.ui.*', 75, 'Vaadin Legacy');
    this.addImportPattern('com.vaadin.server.VaadinRequest', 75, 'Vaadin Legacy');
    this.addImportPattern('com.vaadin.annotations.*', 75, 'Vaadin Legacy');
  }
}


================================================
FILE: src/scanner/parsers/framework-detection/java/frameworks/VertxFramework.ts
================================================
import { FrameworkModule } from '../../FrameworkModule.js';

/**
 * Eclipse Vert.x framework detection module
 * Handles event-driven applications on the JVM
 */
export class VertxFramework extends FrameworkModule {
  constructor() {
    super();
    this.initializeMappings();
  }

  getFrameworkName(): string {
    return 'Eclipse Vert.x';
  }

  protected initializeMappings(): void {
    this.initializeAnnotationMappings();
    this.initializeImportPatterns();
  }

  private initializeAnnotationMappings(): void {
    // Vert.x Web Annotations
    this.frameworkMap.set('RouteHandler', 'Vert.x Web');
    this.frameworkMap.set('Route', 'Vert.x Web');

    // Vert.x Service Proxy Annotations
    this.frameworkMap.set('ProxyGen', 'Vert.x Service Proxy');
    this.frameworkMap.set('VertxGen', 'Vert.x Service Proxy');

    // Vert.x Reactive Annotations
    this.frameworkMap.set('Fluent', 'Vert.x');
    this.frameworkMap.set('GenIgnore', 'Vert.x');
    this.frameworkMap.set('CacheReturn', 'Vert.x');

    // Vert.x Unit Testing
    this.frameworkMap.set('Test', 'Vert.x Unit');
    this.frameworkMap.set('Before', 'Vert.x Unit');
    this.frameworkMap.set('After', 'Vert.x Unit');
    this.frameworkMap.set('BeforeClass', 'Vert.x Unit');
    this.frameworkMap.set('AfterClass', 'Vert.x Unit');
    this.frameworkMap.set('Timeout', 'Vert.x Unit');
    this.frameworkMap.set('Repeat', 'Vert.x Unit');

    // Vert.x Config Annotations
    this.frameworkMap.set('DataObject', 'Vert.x Config');

    // Vert.x Micrometer Metrics
    this.frameworkMap.set('Timed', 'Vert.x Metrics');
    this.frameworkMap.set('Counted', 'Vert.x Metrics');

    // Categories
    this.categoryMap.set('RouteHandler', 'web');
    this.categoryMap.set('Route', 'web');

    this.categoryMap.set('ProxyGen', 'service');
    this.categoryMap.set('VertxGen', 'service');

    this.categoryMap.set('Fluent', 'reactive');
    this.categoryMap.set('GenIgnore', 'reactive');
    this.categoryMap.set('CacheReturn', 'reactive');

    this.categoryMap.set('Test', 'testing');
    this.categoryMap.set('Before', 'testing');
    this.categoryMap.set('After', 'testing');
    this.categoryMap.set('BeforeClass', 'testing');
    this.categoryMap.set('AfterClass', 'testing');
    this.categoryMap.set('Timeout', 'testing');
    this.categoryMap.set('Repeat', 'testing');

    this.categoryMap.set('DataObject', 'configuration');

    this.categoryMap.set('Timed', 'monitoring');
    this.categoryMap.set('Counted', 'monitoring');
  }

  private initializeImportPatterns(): void {
    // Vert.x Core - High confidence
    this.addImportPattern('io.vertx.*', 95, 'Vert.x');
    this.addImportPattern('io.vertx.core.*', 95, 'Vert.x');
    this.addImportPattern('io.vertx.core.http.*', 90, 'Vert.x');
    this.addImportPattern('io.vertx.core.eventbus.*', 90, 'Vert.x');

    // Vert.x Web
    this.addImportPattern('io.vertx.ext.web.*', 95, 'Vert.x Web');
    this.addImportPattern('io.vertx.ext.web.handler.*', 90, 'Vert.x Web');

    // Vert.x Auth
    this.addImportPattern('io.vertx.ext.auth.*', 90, 'Vert.x Auth');

    // Vert.x JDBC Client
    this.addImportPattern('io.vertx.ext.jdbc.*', 85, 'Vert.x JDBC');
    this.addImportPattern('io.vertx.ext.sql.*', 85, 'Vert.x SQL');

    // Vert.x MongoDB Client
    this.addImportPattern('io.vertx.ext.mongo.*', 85, 'Vert.x MongoDB');

    // Vert.x Service Discovery
    this.addImportPattern('io.vertx.servicediscovery.*', 85, 'Vert.x Service Discovery');

    // Vert.x Circuit Breaker
    this.addImportPattern('io.vertx.circuitbreaker.*', 85, 'Vert.x Circuit Breaker');

    // Vert.x Config
    this.addImportPattern('io.vertx.config.*', 85, 'Vert.x Config');

    // Vert.x Health Check
    this.addImportPattern('io.vertx.ext.healthchecks.*', 85, 'Vert.x Health');

    // Vert.x Metrics
    this.addImportPattern('io.vertx.micrometer.*', 80, 'Vert.x Metrics');

    // Vert.x Unit Testing
    this.addImportPattern('io.vertx.ext.unit.*', 90, 'Vert.x Unit');

    // Vert.x RxJava
    this.addImportPattern('io.vertx.rxjava.*', 80, 'Vert.x RxJava');
    this.addImportPattern('io.vertx.rxjava2.*', 80, 'Vert.x RxJava');
    this.addImportPattern('io.vertx.rxjava3.*', 85, 'Vert.x RxJava');

    // Vert.x Reactive Streams
    this.addImportPattern('io.vertx.reactivex.*', 80, 'Vert.x Reactive');

    // Vert.x Kotlin
    this.addImportPattern('io.vertx.kotlin.*', 75, 'Vert.x Kotlin');
  }
}


================================================
FILE: src/scanner/parsers/framework-detection/java/frameworks/WicketFramework.ts
================================================
import { FrameworkModule } from '../../FrameworkModule.js';

/**
 * Apache Wicket framework detection module
 * Handles component-oriented web framework
 */
export class WicketFramework extends FrameworkModule {
  constructor() {
    super();
    this.initializeMappings();
  }

  getFrameworkName(): string {
    return 'Apache Wicket';
  }

  protected initializeMappings(): void {
    this.initializeAnnotationMappings();
    this.initializeImportPatterns();
  }

  private initializeAnnotationMappings(): void {
    // Wicket Spring Integration
    this.frameworkMap.set('SpringBean', 'Wicket Spring');
    
    // Wicket CDI Integration  
    this.frameworkMap.set('Inject', 'Wicket CDI');

    // Categories
    this.categoryMap.set('SpringBean', 'injection');
    this.categoryMap.set('Inject', 'injection');
  }

  private initializeImportPatterns(): void {
    // Wicket Core - High confidence
    this.addImportPattern('org.apache.wicket.*', 95, 'Wicket');
    this.addImportPattern('org.apache.wicket.markup.*', 90, 'Wicket');
    this.addImportPattern('org.apache.wicket.model.*', 90, 'Wicket');
    this.addImportPattern('org.apache.wicket.request.*', 85, 'Wicket');
    this.addImportPattern('org.apache.wicket.protocol.http.*', 85, 'Wicket');

    // Wicket Extensions
    this.addImportPattern('org.apache.wicket.extensions.*', 85, 'Wicket Extensions');

    // Wicket Spring
    this.addImportPattern('org.apache.wicket.spring.*', 85, 'Wicket Spring');

    // Wicket CDI
    this.addImportPattern('org.apache.wicket.cdi.*', 85, 'Wicket CDI');

    // Wicket DateTime
    this.addImportPattern('org.apache.wicket.datetime.*', 80, 'Wicket DateTime');

    // Wicket Auth Roles
    this.addImportPattern('org.apache.wicket.authroles.*', 80, 'Wicket Auth');

    // Wicket Util
    this.addImportPattern('org.apache.wicket.util.*', 75, 'Wicket');

    // Wicket Validation
    this.addImportPattern('org.apache.wicket.validation.*', 80, 'Wicket');
  }
}


================================================
FILE: src/scanner/parsers/framework-detection/typescript/TypeScriptFrameworkDetector.ts
================================================
import { BaseFrameworkDetector } from '../FrameworkDetector.js';
import { FrameworkModule } from '../FrameworkModule.js';
import { 
  FrameworkDetectionResult, 
  FrameworkDetectionContext 
} from '../FrameworkDetectionTypes.js';
import { ParsedImport } from '../../extractors/base/ContentExtractor.js';
import { AngularFramework } from './frameworks/AngularFramework.js';
import { NestJSFramework } from './frameworks/NestJSFramework.js';
import { TypeORMFramework } from './frameworks/TypeORMFramework.js';
import { ReactFramework } from './frameworks/ReactFramework.js';
import { TypeScriptCoreFramework } from './frameworks/TypeScriptCoreFramework.js';

/**
 * TypeScript framework detector that aggregates multiple framework modules
 */
export class TypeScriptFrameworkDetector extends BaseFrameworkDetector {
  private frameworkModules: FrameworkModule[];
  protected frameworkMap: Record<string, string> = {};
  protected categoryMap: Record<string, string> = {};

  constructor() {
    super();
    this.frameworkModules = [
      new AngularFramework(),
      new NestJSFramework(),
      new TypeORMFramework(),
      new ReactFramework(),
      new TypeScriptCoreFramework()
    ];
    this.initializeMaps();
  }

  /**
   * Initialize the aggregated framework and category maps from all modules
   */
  private initializeMaps(): void {
    for (const module of this.frameworkModules) {
      // Merge framework maps
      const moduleFrameworkMap = module.getFrameworkMap();
      for (const [annotation, framework] of moduleFrameworkMap) {
        this.frameworkMap[annotation] = framework;
      }

      // Merge category maps
      const moduleCategoryMap = module.getCategoryMap();
      for (const [annotation, category] of moduleCategoryMap) {
        this.categoryMap[annotation] = category;
      }
    }
  }

  /**
   * Get all framework modules
   */
  getFrameworkModules(): FrameworkModule[] {
    return [...this.frameworkModules];
  }

  /**
   * Get a specific framework module by name
   */
  getFrameworkModule(frameworkName: string): FrameworkModule | undefined {
    return this.frameworkModules.find(module => 
      module.getFrameworkName() === frameworkName
    );
  }

  /**
   * Add a new framework module
   */
  addFrameworkModule(module: FrameworkModule): void {
    this.frameworkModules.push(module);
    
    // Update maps with new module data
    const moduleFrameworkMap = module.getFrameworkMap();
    for (const [annotation, framework] of moduleFrameworkMap) {
      this.frameworkMap[annotation] = framework;
    }

    const moduleCategoryMap = module.getCategoryMap();
    for (const [annotation, category] of moduleCategoryMap) {
      this.categoryMap[annotation] = category;
    }
  }

  /**
   * Remove a framework module by name
   */
  removeFrameworkModule(frameworkName: string): boolean {
    const index = this.frameworkModules.findIndex(module => 
      module.getFrameworkName() === frameworkName
    );
    
    if (index === -1) {
      return false;
    }

    this.frameworkModules.splice(index, 1);
    this.reinitializeMaps();
    return true;
  }

  /**
   * Reinitialize maps after module removal
   */
  private reinitializeMaps(): void {
    this.frameworkMap = {};
    this.categoryMap = {};
    this.initializeMaps();
  }

  /**
   * Enhanced framework detection using both annotations and imports
   */
  detectFrameworkWithContext(context: FrameworkDetectionContext): FrameworkDetectionResult {
    const results: FrameworkDetectionResult[] = [];
    
    // Get detection results from all framework modules
    for (const module of this.frameworkModules) {
      const result = module.detectFrameworkWithContext(context);
      if (result.framework && result.confidence > 0) {
        results.push(result);
      }
    }

    if (results.length === 0) {
      return {
        framework: null,
        confidence: 0,
        detectionMethod: 'combined'
      };
    }

    // Return the result with highest confidence
    return results.reduce((best, current) => 
      current.confidence > best.confidence ? current : best
    );
  }

  /**
   * Detect framework from imports across all modules
   */
  detectFrameworkFromImports(imports: ParsedImport[]): FrameworkDetectionResult {
    const results: FrameworkDetectionResult[] = [];
    
    for (const module of this.frameworkModules) {
      const result = module.detectFrameworkFromImports(imports);
      if (result.framework && result.confidence > 0) {
        results.push(result);
      }
    }

    if (results.length === 0) {
      return {
        framework: null,
        confidence: 0,
        detectionMethod: 'import'
      };
    }

    // Return the result with highest confidence
    return results.reduce((best, current) => 
      current.confidence > best.confidence ? current : best
    );
  }

  /**
   * Get statistics about loaded framework modules
   */
  getFrameworkStatistics(): {
    totalModules: number;
    totalAnnotations: number;
    totalImportPatterns: number;
    moduleBreakdown: Array<{
      name: string;
      annotationCount: number;
      categoryCount: number;
      importPatternCount: number;
    }>;
  } {
    const moduleBreakdown = this.frameworkModules.map(module => ({
      name: module.getFrameworkName(),
      annotationCount: module.getSupportedAnnotations().length,
      categoryCount: module.getSupportedCategories().length,
      importPatternCount: module.getImportPatterns().length
    }));

    const totalImportPatterns = this.frameworkModules.reduce(
      (total, module) => total + module.getImportPatterns().length, 
      0
    );

    return {
      totalModules: this.frameworkModules.length,
      totalAnnotations: Object.keys(this.frameworkMap).length,
      totalImportPatterns,
      moduleBreakdown
    };
  }
}


================================================
FILE: src/scanner/parsers/framework-detection/typescript/frameworks/AngularFramework.ts
================================================
import { FrameworkModule } from '../../FrameworkModule.js';

/**
 * Angular framework detection module
 * Handles Angular components, services, directives, and other decorators
 */
export class AngularFramework extends FrameworkModule {
  constructor() {
    super();
    this.initializeMappings();
  }

  getFrameworkName(): string {
    return 'Angular';
  }

  protected initializeMappings(): void {
    this.initializeAnnotationMappings();
    this.initializeImportPatterns();
  }

  private initializeAnnotationMappings(): void {
    // Angular Core Decorators
    this.frameworkMap.set('Component', 'Angular');
    this.frameworkMap.set('Injectable', 'Angular');
    this.frameworkMap.set('NgModule', 'Angular');
    this.frameworkMap.set('Directive', 'Angular');
    this.frameworkMap.set('Pipe', 'Angular');

    // Angular Property Decorators
    this.frameworkMap.set('Input', 'Angular');
    this.frameworkMap.set('Output', 'Angular');
    this.frameworkMap.set('ViewChild', 'Angular');
    this.frameworkMap.set('ViewChildren', 'Angular');
    this.frameworkMap.set('ContentChild', 'Angular');
    this.frameworkMap.set('ContentChildren', 'Angular');
    this.frameworkMap.set('HostBinding', 'Angular');
    this.frameworkMap.set('HostListener', 'Angular');

    // Angular Dependency Injection
    this.frameworkMap.set('Inject', 'Angular');
    this.frameworkMap.set('Optional', 'Angular');
    this.frameworkMap.set('Self', 'Angular');
    this.frameworkMap.set('SkipSelf', 'Angular');
    this.frameworkMap.set('Host', 'Angular');

    // Categories
    this.categoryMap.set('Component', 'ui');
    this.categoryMap.set('Injectable', 'injection');
    this.categoryMap.set('NgModule', 'injection');
    this.categoryMap.set('Directive', 'ui');
    this.categoryMap.set('Pipe', 'ui');

    this.categoryMap.set('Input', 'ui');
    this.categoryMap.set('Output', 'events');
    this.categoryMap.set('ViewChild', 'ui');
    this.categoryMap.set('ViewChildren', 'ui');
    this.categoryMap.set('ContentChild', 'ui');
    this.categoryMap.set('ContentChildren', 'ui');
    this.categoryMap.set('HostBinding', 'ui');
    this.categoryMap.set('HostListener', 'events');

    this.categoryMap.set('Inject', 'injection');
    this.categoryMap.set('Optional', 'injection');
    this.categoryMap.set('Self', 'injection');
    this.categoryMap.set('SkipSelf', 'injection');
    this.categoryMap.set('Host', 'injection');
  }

  private initializeImportPatterns(): void {
    // Angular Core - Very high confidence
    this.addImportPattern('@angular/core', 95);
    this.addImportPattern('@angular/common', 90);
    this.addImportPattern('@angular/platform-browser', 90);
    this.addImportPattern('@angular/platform-browser-dynamic', 90);
    
    // Angular Router
    this.addImportPattern('@angular/router', 90);
    
    // Angular Forms
    this.addImportPattern('@angular/forms', 85);
    
    // Angular HTTP
    this.addImportPattern('@angular/common/http', 85);
    
    // Angular Material
    this.addImportPattern('@angular/material/*', 80);
    this.addImportPattern('@angular/cdk/*', 75);
    
    // Angular Animations
    this.addImportPattern('@angular/animations', 85);
    
    // Angular PWA
    this.addImportPattern('@angular/service-worker', 80);
    
    // Angular Testing
    this.addImportPattern('@angular/core/testing', 90);
    this.addImportPattern('@angular/common/testing', 85);
    this.addImportPattern('@angular/router/testing', 85);
    this.addImportPattern('@angular/platform-browser/testing', 85);
    
    // Angular CLI
    this.addImportPattern('@angular-devkit/*', 70);
    
    // RxJS (commonly used with Angular)
    this.addImportPattern('rxjs', 60);
    this.addImportPattern('rxjs/operators', 60);
  }
}


================================================
FILE: src/scanner/parsers/framework-detection/typescript/frameworks/NestJSFramework.ts
================================================
import { FrameworkModule } from '../../FrameworkModule.js';

/**
 * NestJS framework detection module
 * Handles NestJS controllers, services, modules, and other decorators
 */
export class NestJSFramework extends FrameworkModule {
  constructor() {
    super();
    this.initializeMappings();
  }

  getFrameworkName(): string {
    return 'NestJS';
  }

  protected initializeMappings(): void {
    this.initializeAnnotationMappings();
    this.initializeImportPatterns();
  }

  private initializeAnnotationMappings(): void {
    // NestJS Core Decorators
    this.frameworkMap.set('Module', 'NestJS');
    this.frameworkMap.set('Controller', 'NestJS');
    this.frameworkMap.set('Injectable', 'NestJS');
    this.frameworkMap.set('Inject', 'NestJS');
    this.frameworkMap.set('Optional', 'NestJS');

    // HTTP Method Decorators
    this.frameworkMap.set('Get', 'NestJS');
    this.frameworkMap.set('Post', 'NestJS');
    this.frameworkMap.set('Put', 'NestJS');
    this.frameworkMap.set('Delete', 'NestJS');
    this.frameworkMap.set('Patch', 'NestJS');
    this.frameworkMap.set('Options', 'NestJS');
    this.frameworkMap.set('Head', 'NestJS');
    this.frameworkMap.set('All', 'NestJS');

    // Parameter Decorators
    this.frameworkMap.set('Param', 'NestJS');
    this.frameworkMap.set('Body', 'NestJS');
    this.frameworkMap.set('Query', 'NestJS');
    this.frameworkMap.set('Headers', 'NestJS');
    this.frameworkMap.set('Session', 'NestJS');
    this.frameworkMap.set('Req', 'NestJS');
    this.frameworkMap.set('Res', 'NestJS');
    this.frameworkMap.set('Next', 'NestJS');
    this.frameworkMap.set('Ip', 'NestJS');
    this.frameworkMap.set('HostParam', 'NestJS');

    // Guards and Interceptors
    this.frameworkMap.set('UseGuards', 'NestJS');
    this.frameworkMap.set('UseInterceptors', 'NestJS');
    this.frameworkMap.set('UsePipes', 'NestJS');
    this.frameworkMap.set('UseFilters', 'NestJS');
    this.frameworkMap.set('SetMetadata', 'NestJS');

    // Lifecycle Hooks
    this.frameworkMap.set('OnModuleInit', 'NestJS');
    this.frameworkMap.set('OnApplicationBootstrap', 'NestJS');
    this.frameworkMap.set('OnModuleDestroy', 'NestJS');
    this.frameworkMap.set('BeforeApplicationShutdown', 'NestJS');
    this.frameworkMap.set('OnApplicationShutdown', 'NestJS');

    // WebSocket Decorators
    this.frameworkMap.set('WebSocketGateway', 'NestJS');
    this.frameworkMap.set('SubscribeMessage', 'NestJS');
    this.frameworkMap.set('MessageBody', 'NestJS');
    this.frameworkMap.set('ConnectedSocket', 'NestJS');
    this.frameworkMap.set('WebSocketServer', 'NestJS');

    // Microservices
    this.frameworkMap.set('MessagePattern', 'NestJS');
    this.frameworkMap.set('EventPattern', 'NestJS');
    this.frameworkMap.set('Client', 'NestJS');

    // GraphQL
    this.frameworkMap.set('Resolver', 'NestJS GraphQL');
    this.frameworkMap.set('Query', 'NestJS GraphQL');
    this.frameworkMap.set('Mutation', 'NestJS GraphQL');
    this.frameworkMap.set('Subscription', 'NestJS GraphQL');
    this.frameworkMap.set('Args', 'NestJS GraphQL');
    this.frameworkMap.set('Context', 'NestJS GraphQL');
    this.frameworkMap.set('Info', 'NestJS GraphQL');
    this.frameworkMap.set('Parent', 'NestJS GraphQL');
    this.frameworkMap.set('ResolveField', 'NestJS GraphQL');

    // Validation and Transformation
    this.frameworkMap.set('IsString', 'NestJS Validation');
    this.frameworkMap.set('IsNumber', 'NestJS Validation');
    this.frameworkMap.set('IsEmail', 'NestJS Validation');
    this.frameworkMap.set('IsOptional', 'NestJS Validation');
    this.frameworkMap.set('ValidateNested', 'NestJS Validation');
    this.frameworkMap.set('Transform', 'NestJS Validation');
    this.frameworkMap.set('Type', 'NestJS Validation');

    // Testing
    this.frameworkMap.set('Test', 'NestJS Testing');

    // Categories
    this.categoryMap.set('Module', 'injection');
    this.categoryMap.set('Controller', 'web');
    this.categoryMap.set('Injectable', 'injection');
    this.categoryMap.set('Inject', 'injection');
    this.categoryMap.set('Optional', 'injection');

    // HTTP methods
    this.categoryMap.set('Get', 'web');
    this.categoryMap.set('Post', 'web');
    this.categoryMap.set('Put', 'web');
    this.categoryMap.set('Delete', 'web');
    this.categoryMap.set('Patch', 'web');
    this.categoryMap.set('Options', 'web');
    this.categoryMap.set('Head', 'web');
    this.categoryMap.set('All', 'web');

    // Parameters
    this.categoryMap.set('Param', 'web');
    this.categoryMap.set('Body', 'web');
    this.categoryMap.set('Query', 'web');
    this.categoryMap.set('Headers', 'web');
    this.categoryMap.set('Session', 'web');
    this.categoryMap.set('Req', 'web');
    this.categoryMap.set('Res', 'web');
    this.categoryMap.set('Next', 'web');
    this.categoryMap.set('Ip', 'web');
    this.categoryMap.set('HostParam', 'web');

    // Security and middleware
    this.categoryMap.set('UseGuards', 'security');
    this.categoryMap.set('UseInterceptors', 'web');
    this.categoryMap.set('UsePipes', 'validation');
    this.categoryMap.set('UseFilters', 'web');
    this.categoryMap.set('SetMetadata', 'web');

    // Lifecycle
    this.categoryMap.set('OnModuleInit', 'lifecycle');
    this.categoryMap.set('OnApplicationBootstrap', 'lifecycle');
    this.categoryMap.set('OnModuleDestroy', 'lifecycle');
    this.categoryMap.set('BeforeApplicationShutdown', 'lifecycle');
    this.categoryMap.set('OnApplicationShutdown', 'lifecycle');

    // WebSocket
    this.categoryMap.set('WebSocketGateway', 'events');
    this.categoryMap.set('SubscribeMessage', 'events');
    this.categoryMap.set('MessageBody', 'events');
    this.categoryMap.set('ConnectedSocket', 'events');
    this.categoryMap.set('WebSocketServer', 'events');

    // Microservices
    this.categoryMap.set('MessagePattern', 'events');
    this.categoryMap.set('EventPattern', 'events');
    this.categoryMap.set('Client', 'events');

    // GraphQL
    this.categoryMap.set('Resolver', 'web');
    this.categoryMap.set('Query', 'web');
    this.categoryMap.set('Mutation', 'web');
    this.categoryMap.set('Subscription', 'events');
    this.categoryMap.set('Args', 'web');
    this.categoryMap.set('Context', 'web');
    this.categoryMap.set('Info', 'web');
    this.categoryMap.set('Parent', 'web');
    this.categoryMap.set('ResolveField', 'web');

    // Validation
    this.categoryMap.set('IsString', 'validation');
    this.categoryMap.set('IsNumber', 'validation');
    this.categoryMap.set('IsEmail', 'validation');
    this.categoryMap.set('IsOptional', 'validation');
    this.categoryMap.set('ValidateNested', 'validation');
    this.categoryMap.set('Transform', 'validation');
    this.categoryMap.set('Type', 'validation');

    // Testing
    this.categoryMap.set('Test', 'testing');
  }

  private initializeImportPatterns(): void {
    // NestJS Core - Very high confidence
    this.addImportPattern('@nestjs/common', 95);
    this.addImportPattern('@nestjs/core', 95);
    this.addImportPattern('@nestjs/platform-express', 90);
    this.addImportPattern('@nestjs/platform-fastify', 90);
    
    // NestJS Testing
    this.addImportPattern('@nestjs/testing', 95);
    
    // NestJS GraphQL
    this.addImportPattern('@nestjs/graphql', 90, 'NestJS GraphQL');
    this.addImportPattern('@nestjs/apollo', 85, 'NestJS GraphQL');
    this.addImportPattern('@nestjs/mercurius', 85, 'NestJS GraphQL');
    
    // NestJS Microservices
    this.addImportPattern('@nestjs/microservices', 95);
    
    // NestJS WebSocket
    this.addImportPattern('@nestjs/websockets', 95);
    this.addImportPattern('@nestjs/platform-socket.io', 90);
    this.addImportPattern('@nestjs/platform-ws', 90);
    
    // NestJS Database/ORM
    this.addImportPattern('@nestjs/typeorm', 85);
    this.addImportPattern('@nestjs/mongoose', 85);
    this.addImportPattern('@nestjs/sequelize', 85);
    this.addImportPattern('@nestjs/prisma', 85);
    
    // NestJS Validation
    this.addImportPattern('class-validator', 70, 'NestJS Validation');
    this.addImportPattern('class-transformer', 70, 'NestJS Validation');
    
    // NestJS Security & Auth
    this.addImportPattern('@nestjs/passport', 85);
    this.addImportPattern('@nestjs/jwt', 85);
    this.addImportPattern('@nestjs/throttler', 80);
    
    // NestJS Configuration
    this.addImportPattern('@nestjs/config', 85);
    this.addImportPattern('@nestjs/cache-manager', 80);
    this.addImportPattern('@nestjs/schedule', 80);
    this.addImportPattern('@nestjs/event-emitter', 80);
  }
}


================================================
FILE: src/scanner/parsers/framework-detection/typescript/frameworks/ReactFramework.ts
================================================
import { FrameworkModule } from '../../FrameworkModule.js';

/**
 * React framework detection module
 * Handles React hooks and component decorators
 */
export class ReactFramework extends FrameworkModule {
  constructor() {
    super();
    this.initializeMappings();
  }

  getFrameworkName(): string {
    return 'React';
  }

  protected initializeMappings(): void {
    // React Hooks (detected as function calls, but listed for completeness)
    this.frameworkMap.set('useState', 'React');
    this.frameworkMap.set('useEffect', 'React');
    this.frameworkMap.set('useContext', 'React');
    this.frameworkMap.set('useReducer', 'React');
    this.frameworkMap.set('useCallback', 'React');
    this.frameworkMap.set('useMemo', 'React');
    this.frameworkMap.set('useRef', 'React');
    this.frameworkMap.set('useImperativeHandle', 'React');
    this.frameworkMap.set('useLayoutEffect', 'React');
    this.frameworkMap.set('useDebugValue', 'React');

    // React Testing Library
    this.frameworkMap.set('render', 'React Testing');
    this.frameworkMap.set('screen', 'React Testing');

    // Categories
    this.categoryMap.set('useState', 'state');
    this.categoryMap.set('useEffect', 'lifecycle');
    this.categoryMap.set('useContext', 'state');
    this.categoryMap.set('useReducer', 'state');
    this.categoryMap.set('useCallback', 'performance');
    this.categoryMap.set('useMemo', 'performance');
    this.categoryMap.set('useRef', 'ui');
    this.categoryMap.set('useImperativeHandle', 'ui');
    this.categoryMap.set('useLayoutEffect', 'lifecycle');
    this.categoryMap.set('useDebugValue', 'utility');

    this.categoryMap.set('render', 'testing');
    this.categoryMap.set('screen', 'testing');
  }
}


================================================
FILE: src/scanner/parsers/framework-detection/typescript/frameworks/TypeORMFramework.ts
================================================
import { FrameworkModule } from '../../FrameworkModule.js';

/**
 * TypeORM framework detection module
 * Handles TypeORM entity and relationship decorators
 */
export class TypeORMFramework extends FrameworkModule {
  constructor() {
    super();
    this.initializeMappings();
  }

  getFrameworkName(): string {
    return 'TypeORM';
  }

  protected initializeMappings(): void {
    // TypeORM Entity Decorators
    this.frameworkMap.set('Entity', 'TypeORM');
    this.frameworkMap.set('Column', 'TypeORM');
    this.frameworkMap.set('PrimaryGeneratedColumn', 'TypeORM');
    this.frameworkMap.set('PrimaryColumn', 'TypeORM');
    this.frameworkMap.set('CreateDateColumn', 'TypeORM');
    this.frameworkMap.set('UpdateDateColumn', 'TypeORM');
    this.frameworkMap.set('DeleteDateColumn', 'TypeORM');
    this.frameworkMap.set('VersionColumn', 'TypeORM');

    // TypeORM Relationship Decorators
    this.frameworkMap.set('OneToMany', 'TypeORM');
    this.frameworkMap.set('ManyToOne', 'TypeORM');
    this.frameworkMap.set('ManyToMany', 'TypeORM');
    this.frameworkMap.set('OneToOne', 'TypeORM');
    this.frameworkMap.set('JoinColumn', 'TypeORM');
    this.frameworkMap.set('JoinTable', 'TypeORM');
    this.frameworkMap.set('RelationId', 'TypeORM');

    // TypeORM Index and Constraints
    this.frameworkMap.set('Index', 'TypeORM');
    this.frameworkMap.set('Unique', 'TypeORM');
    this.frameworkMap.set('Check', 'TypeORM');
    this.frameworkMap.set('Exclusion', 'TypeORM');

    // TypeORM Lifecycle Hooks
    this.frameworkMap.set('BeforeInsert', 'TypeORM');
    this.frameworkMap.set('AfterInsert', 'TypeORM');
    this.frameworkMap.set('BeforeUpdate', 'TypeORM');
    this.frameworkMap.set('AfterUpdate', 'TypeORM');
    this.frameworkMap.set('BeforeRemove', 'TypeORM');
    this.frameworkMap.set('AfterRemove', 'TypeORM');
    this.frameworkMap.set('BeforeRecover', 'TypeORM');
    this.frameworkMap.set('AfterRecover', 'TypeORM');
    this.frameworkMap.set('BeforeSoftRemove', 'TypeORM');
    this.frameworkMap.set('AfterSoftRemove', 'TypeORM');

    // Categories - all TypeORM decorators are persistence-related
    this.categoryMap.set('Entity', 'persistence');
    this.categoryMap.set('Column', 'persistence');
    this.categoryMap.set('PrimaryGeneratedColumn', 'persistence');
    this.categoryMap.set('PrimaryColumn', 'persistence');
    this.categoryMap.set('CreateDateColumn', 'persistence');
    this.categoryMap.set('UpdateDateColumn', 'persistence');
    this.categoryMap.set('DeleteDateColumn', 'persistence');
    this.categoryMap.set('VersionColumn', 'persistence');

    this.categoryMap.set('OneToMany', 'persistence');
    this.categoryMap.set('ManyToOne', 'persistence');
    this.categoryMap.set('ManyToMany', 'persistence');
    this.categoryMap.set('OneToOne', 'persistence');
    this.categoryMap.set('JoinColumn', 'persistence');
    this.categoryMap.set('JoinTable', 'persistence');
    this.categoryMap.set('RelationId', 'persistence');

    this.categoryMap.set('Index', 'persistence');
    this.categoryMap.set('Unique', 'persistence');
    this.categoryMap.set('Check', 'persistence');
    this.categoryMap.set('Exclusion', 'persistence');

    this.categoryMap.set('BeforeInsert', 'lifecycle');
    this.categoryMap.set('AfterInsert', 'lifecycle');
    this.categoryMap.set('BeforeUpdate', 'lifecycle');
    this.categoryMap.set('AfterUpdate', 'lifecycle');
    this.categoryMap.set('BeforeRemove', 'lifecycle');
    this.categoryMap.set('AfterRemove', 'lifecycle');
    this.categoryMap.set('BeforeRecover', 'lifecycle');
    this.categoryMap.set('AfterRecover', 'lifecycle');
    this.categoryMap.set('BeforeSoftRemove', 'lifecycle');
    this.categoryMap.set('AfterSoftRemove', 'lifecycle');
  }
}


================================================
FILE: src/scanner/parsers/framework-detection/typescript/frameworks/TypeScriptCoreFramework.ts
================================================
import { FrameworkModule } from '../../FrameworkModule.js';

/**
 * TypeScript Core framework detection module
 * Handles built-in TypeScript decorators and language features
 */
export class TypeScriptCoreFramework extends FrameworkModule {
  constructor() {
    super();
    this.initializeMappings();
  }

  getFrameworkName(): string {
    return 'TypeScript';
  }

  protected initializeMappings(): void {
    // TypeScript Experimental Decorators
    this.frameworkMap.set('sealed', 'TypeScript');
    this.frameworkMap.set('enumerable', 'TypeScript');
    this.frameworkMap.set('configurable', 'TypeScript');

    // Categories - all are language features
    this.categoryMap.set('sealed', 'language');
    this.categoryMap.set('enumerable', 'language');
    this.categoryMap.set('configurable', 'language');
  }
}


================================================
FILE: src/services/embedding-service.ts
================================================
import OpenAI from 'openai';
import { SemanticSearchConfig, SemanticEmbedding } from '../types.js';
import { getSemanticSearchConfig } from '../config.js';

export interface EmbeddingProvider {
  generateEmbedding(text: string): Promise<number[]>;
  generateEmbeddings(texts: string[]): Promise<number[][]>;
  getDimensions(): number;
  getModel(): string;
}

export class OpenAIEmbeddingProvider implements EmbeddingProvider {
  private client: OpenAI;
  private config: SemanticSearchConfig;

  constructor(config: SemanticSearchConfig) {
    if (!config.api_key) {
      throw new Error('OpenAI API key is required for OpenAI embedding provider');
    }
    
    this.config = config;
    
    // Support custom base URLs for OpenAI-compatible APIs (e.g., LLM Studio)
    const clientConfig: any = {
      apiKey: config.api_key,
    };
    
    if (config.base_url) {
      clientConfig.baseURL = config.base_url;
    }
    
    this.client = new OpenAI(clientConfig);
  }

  async generateEmbedding(text: string): Promise<number[]> {
    try {
      // Truncate text if it exceeds max tokens
      const truncatedText = this.truncateText(text, this.config.max_tokens);
      
      const response = await this.client.embeddings.create({
        model: this.config.model,
        input: truncatedText,
      });

      return response.data[0].embedding;
    } catch (error) {
      throw new Error(`Failed to generate embedding: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  async generateEmbeddings(texts: string[]): Promise<number[][]> {
    try {
      // Process in batches to avoid API limits
      const results: number[][] = [];
      const batchSize = Math.min(this.config.batch_size, texts.length);
      
      for (let i = 0; i < texts.length; i += batchSize) {
        const batch = texts.slice(i, i + batchSize);
        const truncatedBatch = batch.map(text => this.truncateText(text, this.config.max_tokens));
        
        const response = await this.client.embeddings.create({
          model: this.config.model,
          input: truncatedBatch,
        });

        const batchEmbeddings = response.data.map(item => item.embedding);
        results.push(...batchEmbeddings);
      }

      return results;
    } catch (error) {
      throw new Error(`Failed to generate batch embeddings: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  getDimensions(): number {
    return this.config.dimensions;
  }

  getModel(): string {
    return this.config.model;
  }

  private truncateText(text: string, maxTokens: number): string {
    // Simple token estimation: ~4 characters per token
    const estimatedTokens = text.length / 4;
    if (estimatedTokens <= maxTokens) {
      return text;
    }
    
    const maxChars = maxTokens * 4;
    return text.substring(0, maxChars) + '...';
  }
}

export class OllamaEmbeddingProvider implements EmbeddingProvider {
  private config: SemanticSearchConfig;
  private baseUrl: string;

  constructor(config: SemanticSearchConfig) {
    this.config = config;
    this.baseUrl = config.base_url || 'http://localhost:11434';
  }

  async generateEmbedding(text: string): Promise<number[]> {
    try {
      const truncatedText = this.truncateText(text, this.config.max_tokens);
      
      const response = await fetch(`${this.baseUrl}/api/embeddings`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          model: this.config.model,
          prompt: truncatedText,
        }),
      });

      if (!response.ok) {
        throw new Error(`Ollama API error: ${response.status} ${response.statusText}`);
      }

      const data = await response.json();
      return data.embedding;
    } catch (error) {
      throw new Error(`Failed to generate Ollama embedding: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  async generateEmbeddings(texts: string[]): Promise<number[][]> {
    try {
      const results: number[][] = [];
      const batchSize = Math.min(this.config.batch_size, texts.length);
      
      // Ollama doesn't support batch embeddings, so we process individually
      // but in controlled batches to avoid overwhelming the server
      for (let i = 0; i < texts.length; i += batchSize) {
        const batch = texts.slice(i, i + batchSize);
        const batchPromises = batch.map(text => this.generateEmbedding(text));
        const batchResults = await Promise.all(batchPromises);
        results.push(...batchResults);
      }

      return results;
    } catch (error) {
      throw new Error(`Failed to generate Ollama batch embeddings: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  getDimensions(): number {
    return this.config.dimensions;
  }

  getModel(): string {
    return this.config.model;
  }

  private truncateText(text: string, maxTokens: number): string {
    // Simple token estimation: ~4 characters per token
    const estimatedTokens = text.length / 4;
    if (estimatedTokens <= maxTokens) {
      return text;
    }
    
    const maxChars = maxTokens * 4;
    return text.substring(0, maxChars) + '...';
  }
}


export class EmbeddingService {
  private provider: EmbeddingProvider | null = null;
  private config: SemanticSearchConfig;

  constructor(config?: SemanticSearchConfig) {
    this.config = config || getSemanticSearchConfig();
    this.initializeProvider();
  }

  private initializeProvider(): void {
    if (this.config.provider === 'disabled') {
      this.provider = null;
      return;
    }

    try {
      switch (this.config.provider) {
        case 'openai':
          this.provider = new OpenAIEmbeddingProvider(this.config);
          break;
        case 'ollama':
          this.provider = new OllamaEmbeddingProvider(this.config);
          break;
        default:
          throw new Error(`Unknown embedding provider: ${this.config.provider}`);
      }
    } catch (error) {
      console.warn(`Failed to initialize embedding provider: ${error instanceof Error ? error.message : 'Unknown error'}`);
      this.provider = null;
    }
  }

  isEnabled(): boolean {
    return this.provider !== null;
  }

  async generateEmbedding(text: string): Promise<SemanticEmbedding | null> {
    if (!this.provider) {
      return null;
    }

    try {
      const vector = await this.provider.generateEmbedding(text);
      return {
        vector,
        model: this.provider.getModel(),
        version: '1.0',
        created_at: new Date()
      };
    } catch (error) {
      console.error(`Failed to generate embedding: ${error instanceof Error ? error.message : 'Unknown error'}`);
      return null;
    }
  }

  async generateEmbeddings(texts: string[]): Promise<(SemanticEmbedding | null)[]> {
    if (!this.provider) {
      return texts.map(() => null);
    }

    try {
      const vectors = await this.provider.generateEmbeddings(texts);
      return vectors.map(vector => ({
        vector,
        model: this.provider!.getModel(),
        version: '1.0',
        created_at: new Date()
      }));
    } catch (error) {
      console.error(`Failed to generate batch embeddings: ${error instanceof Error ? error.message : 'Unknown error'}`);
      return texts.map(() => null);
    }
  }

  // Extract semantic content from code nodes
  extractSemanticContent(node: any): string {
    const parts = [];

    // Add name and qualified name
    if (node.name) parts.push(node.name);
    if (node.qualified_name && node.qualified_name !== node.name) {
      parts.push(node.qualified_name);
    }

    // Add description
    if (node.description) parts.push(node.description);

    // Add parameter information
    if (node.attributes?.parameters) {
      const paramInfo = node.attributes.parameters
        .map((p: any) => `${p.name}: ${p.type}${p.description ? ` - ${p.description}` : ''}`)
        .join(', ');
      if (paramInfo) parts.push(`Parameters: ${paramInfo}`);
    }

    // Add return type
    if (node.attributes?.return_type) {
      parts.push(`Returns: ${node.attributes.return_type}`);
    }

    // Add annotations/decorators
    if (node.attributes?.annotations) {
      const annotations = node.attributes.annotations
        .map((a: any) => a.name)
        .join(', ');
      if (annotations) parts.push(`Annotations: ${annotations}`);
    }

    // Add modifiers
    if (node.modifiers && node.modifiers.length > 0) {
      parts.push(`Modifiers: ${node.modifiers.join(', ')}`);
    }

    return parts.join(' | ');
  }
}


================================================
FILE: src/services/semantic-search-manager.ts
================================================
import { Neo4jClient } from '../graph/neo4j-client.js';
import { EmbeddingService } from './embedding-service.js';
import { CodeNode, SemanticSearchParams, SemanticSearchResult, SemanticEmbedding } from '../types.js';
import { getSemanticSearchConfig } from '../config.js';

export class SemanticSearchManager {
  private neo4jClient: Neo4jClient;
  private embeddingService: EmbeddingService;
  private config: ReturnType<typeof getSemanticSearchConfig>;

  constructor(neo4jClient: Neo4jClient, embeddingService?: EmbeddingService) {
    this.neo4jClient = neo4jClient;
    this.embeddingService = embeddingService || new EmbeddingService();
    this.config = getSemanticSearchConfig();
  }

  async initializeVectorIndexes(): Promise<void> {
    if (!this.embeddingService.isEnabled()) {
      console.log('Semantic search disabled, skipping vector index initialization');
      return;
    }

    try {
      // Create vector index for semantic embeddings
      const indexQuery = `
        CREATE VECTOR INDEX semantic_embeddings IF NOT EXISTS
        FOR (n:CodeEntity)
        ON (n.semantic_embedding)
        OPTIONS {
          indexConfig: {
            \`vector.dimensions\`: $dimensions,
            \`vector.similarity_function\`: 'cosine'
          }
        }
      `;

      await this.neo4jClient.runQuery(indexQuery, { 
        dimensions: this.config.dimensions 
      });

      console.log('Vector indexes initialized successfully');
    } catch (error) {
      console.error('Failed to initialize vector indexes:', error);
      throw error;
    }
  }

  async addEmbeddingToNode(nodeId: string, projectId: string, embedding: SemanticEmbedding): Promise<void> {
    const query = `
      MATCH (n:CodeEntity {id: $nodeId, project_id: $projectId})
      SET n.semantic_embedding = $vector,
          n.embedding_model = $model,
          n.embedding_version = $version,
          n.embedding_created_at = $createdAt
      RETURN n
    `;

    const result = await this.neo4jClient.runQuery(query, {
      nodeId,
      projectId,
      vector: embedding.vector,
      model: embedding.model,
      version: embedding.version,
      createdAt: embedding.created_at.toISOString()
    });

    if (result.records.length === 0) {
      throw new Error(`Node not found: ${nodeId} in project ${projectId}`);
    }
  }

  async semanticSearch(params: SemanticSearchParams): Promise<SemanticSearchResult[]> {
    if (!this.embeddingService.isEnabled()) {
      throw new Error('Semantic search is disabled');
    }

    // Generate embedding for the query
    const queryEmbedding = await this.embeddingService.generateEmbedding(params.query);
    if (!queryEmbedding) {
      throw new Error('Failed to generate embedding for query');
    }

    // Build the search query
    const limit = params.limit || 10;
    const threshold = params.similarity_threshold || this.config.similarity_threshold;
    
    let whereClause = 'n.semantic_embedding IS NOT NULL';
    const queryParams: Record<string, any> = {
      queryVector: queryEmbedding.vector,
      limit: limit,
      threshold: threshold
    };

    // Add project filter
    if (params.project_id) {
      whereClause += ' AND n.project_id = $projectId';
      queryParams.projectId = params.project_id;
    }

    // Add node type filter
    if (params.node_types && params.node_types.length > 0) {
      whereClause += ' AND n.type IN $nodeTypes';
      queryParams.nodeTypes = params.node_types;
    }

    const searchQuery = `
      MATCH (n:CodeEntity)
      WHERE ${whereClause}
      WITH n, vector.similarity.cosine(n.semantic_embedding, $queryVector) AS similarity
      WHERE similarity >= $threshold
      RETURN n, similarity
      ORDER BY similarity DESC
      LIMIT $limit
    `;

    try {
      const result = await this.neo4jClient.runQuery(searchQuery, queryParams);
      
      return result.records.map(record => {
        const node = this.neo4jRecordToCodeNode(record.get('n'));
        const similarity = record.get('similarity');
        
        return {
          node,
          similarity_score: similarity,
          matched_content: this.embeddingService.extractSemanticContent(node)
        };
      });
    } catch (error) {
      console.error('Semantic search query failed:', error);
      throw new Error(`Semantic search failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  async hybridSearch(params: SemanticSearchParams, graphContext?: {
    includeRelationships?: boolean;
    maxHops?: number;
  }): Promise<SemanticSearchResult[]> {
    // First perform semantic search
    const semanticResults = await this.semanticSearch(params);
    
    if (!graphContext?.includeRelationships) {
      return semanticResults;
    }

    // Enhance results with graph context
    const enhancedResults: SemanticSearchResult[] = [];
    const maxHops = graphContext.maxHops || 2;

    for (const result of semanticResults) {
      // Get related nodes within maxHops
      const contextQuery = `
        MATCH (n:CodeEntity {id: $nodeId, project_id: $projectId})
        MATCH (n)-[*1..${maxHops}]-(related:CodeEntity)
        WHERE related.project_id = $projectId
        RETURN DISTINCT related
        LIMIT 5
      `;

      try {
        const contextResult = await this.neo4jClient.runQuery(contextQuery, {
          nodeId: result.node.id,
          projectId: result.node.project_id
        });

        const relatedNodes = contextResult.records.map(record => 
          this.neo4jRecordToCodeNode(record.get('related'))
        );

        // Enhance the matched content with related context
        const contextualContent = [
          result.matched_content,
          ...relatedNodes.map(node => `Related: ${node.name} (${node.type})`)
        ].join(' | ');

        enhancedResults.push({
          ...result,
          matched_content: contextualContent
        });
      } catch (error) {
        console.warn(`Failed to get graph context for node ${result.node.id}:`, error);
        enhancedResults.push(result);
      }
    }

    return enhancedResults;
  }

  async getSimilarNodes(nodeId: string, projectId: string, limit: number = 5): Promise<SemanticSearchResult[]> {
    // Get the embedding of the target node
    const nodeQuery = `
      MATCH (n:CodeEntity {id: $nodeId, project_id: $projectId})
      WHERE n.semantic_embedding IS NOT NULL
      RETURN n.semantic_embedding AS embedding, n
    `;

    const nodeResult = await this.neo4jClient.runQuery(nodeQuery, { nodeId, projectId });
    
    if (nodeResult.records.length === 0) {
      throw new Error(`Node not found or has no embedding: ${nodeId}`);
    }

    const targetEmbedding = nodeResult.records[0].get('embedding');
    const targetNode = this.neo4jRecordToCodeNode(nodeResult.records[0].get('n'));

    // Find similar nodes
    const similarQuery = `
      MATCH (n:CodeEntity)
      WHERE n.semantic_embedding IS NOT NULL 
        AND n.project_id = $projectId 
        AND n.id <> $nodeId
      WITH n, vector.similarity.cosine(n.semantic_embedding, $targetEmbedding) AS similarity
      WHERE similarity >= $threshold
      RETURN n, similarity
      ORDER BY similarity DESC
      LIMIT $limit
    `;

    const result = await this.neo4jClient.runQuery(similarQuery, {
      projectId,
      nodeId,
      targetEmbedding,
      threshold: this.config.similarity_threshold,
      limit
    });

    return result.records.map(record => {
      const node = this.neo4jRecordToCodeNode(record.get('n'));
      const similarity = record.get('similarity');
      
      return {
        node,
        similarity_score: similarity,
        matched_content: this.embeddingService.extractSemanticContent(node)
      };
    });
  }

  async updateEmbeddings(projectId?: string, nodeTypes?: string[]): Promise<{ updated: number; failed: number }> {
    if (!this.embeddingService.isEnabled()) {
      throw new Error('Semantic search is disabled');
    }

    let whereClause = '1=1';
    const queryParams: Record<string, any> = {};

    if (projectId) {
      whereClause += ' AND n.project_id = $projectId';
      queryParams.projectId = projectId;
    }

    if (nodeTypes && nodeTypes.length > 0) {
      whereClause += ' AND n.type IN $nodeTypes';
      queryParams.nodeTypes = nodeTypes;
    }

    // Get nodes that need embedding updates
    const query = `
      MATCH (n:CodeEntity)
      WHERE ${whereClause}
      RETURN n
      ORDER BY n.id
    `;

    const result = await this.neo4jClient.runQuery(query, queryParams);
    const nodes = result.records.map(record => this.neo4jRecordToCodeNode(record.get('n')));

    let updated = 0;
    let failed = 0;

    // Process nodes in batches
    const batchSize = this.config.batch_size;
    for (let i = 0; i < nodes.length; i += batchSize) {
      const batch = nodes.slice(i, i + batchSize);
      
      try {
        // Extract semantic content for the batch
        const texts = batch.map(node => this.embeddingService.extractSemanticContent(node));
        
        // Generate embeddings
        const embeddings = await this.embeddingService.generateEmbeddings(texts);
        
        // Update nodes with embeddings
        for (let j = 0; j < batch.length; j++) {
          const node = batch[j];
          const embedding = embeddings[j];
          
          if (embedding) {
            try {
              await this.addEmbeddingToNode(node.id, node.project_id, embedding);
              updated++;
            } catch (error) {
              console.error(`Failed to update embedding for node ${node.id}:`, error);
              failed++;
            }
          } else {
            failed++;
          }
        }
      } catch (error) {
        console.error(`Failed to process batch starting at index ${i}:`, error);
        failed += batch.length;
      }
    }

    return { updated, failed };
  }

  private neo4jRecordToCodeNode(record: any): CodeNode {
    const properties = record.properties;
    
    return {
      id: properties.id,
      project_id: properties.project_id,
      type: properties.type,
      name: properties.name,
      qualified_name: properties.qualified_name,
      description: properties.description,
      source_file: properties.source_file,
      start_line: properties.start_line ? parseInt(properties.start_line) : undefined,
      end_line: properties.end_line ? parseInt(properties.end_line) : undefined,
      modifiers: properties.modifiers,
      attributes: properties.attributes ? JSON.parse(properties.attributes) : undefined
    };
  }
}


================================================
FILE: src/utils/token-limiter.ts
================================================
/**
 * Token limiting utilities for MCP responses
 * Estimates token count and applies limits to prevent excessive token usage
 */

export interface TokenLimitConfig {
  maxTokens: number;
  includeMetadata: boolean;
}

export interface TokenLimitResult<T> {
  data: T[];
  truncated: boolean;
  originalCount: number;
  returnedCount: number;
  estimatedTokens: number;
  metadata?: {
    message: string;
    suggestedActions?: string[];
  };
}

/**
 * Rough token estimation for JSON objects
 * Uses a conservative estimate of ~4 characters per token
 */
export function estimateTokens(obj: any): number {
  const jsonString = JSON.stringify(obj);
  return Math.ceil(jsonString.length / 4);
}

/**
 * Get MCP token limit from environment or use default
 */
export function getMcpTokenLimit(): number {
  const envLimit = process.env.MCP_TOKEN_LIMIT;
  if (envLimit) {
    const parsed = parseInt(envLimit, 10);
    if (!isNaN(parsed) && parsed > 0) {
      return parsed;
    }
  }
  return 10000; // Default 10K tokens
}

/**
 * Apply token limit to an array of objects
 * Returns as many objects as possible within the token limit
 */
export function applyTokenLimit<T>(
  data: T[],
  config?: Partial<TokenLimitConfig>
): TokenLimitResult<T> {
  const maxTokens = config?.maxTokens ?? getMcpTokenLimit();
  const includeMetadata = config?.includeMetadata ?? true;
  
  const result: TokenLimitResult<T> = {
    data: [],
    truncated: false,
    originalCount: data.length,
    returnedCount: 0,
    estimatedTokens: 0
  };

  // Reserve tokens for metadata if needed
  const metadataTokenReserve = includeMetadata ? 100 : 0;
  const availableTokens = maxTokens - metadataTokenReserve;

  let currentTokens = 0;
  let index = 0;

  // Add items until we hit the token limit
  while (index < data.length) {
    const itemTokens = estimateTokens(data[index]);
    
    if (currentTokens + itemTokens > availableTokens) {
      result.truncated = true;
      break;
    }

    result.data.push(data[index]);
    currentTokens += itemTokens;
    index++;
  }

  result.returnedCount = result.data.length;
  result.estimatedTokens = currentTokens;

  // Add helpful metadata if truncated
  if (result.truncated && includeMetadata) {
    const remaining = result.originalCount - result.returnedCount;
    result.metadata = {
      message: `Results truncated: showing ${result.returnedCount} of ${result.originalCount} items (${remaining} more available)`,
      suggestedActions: [
        "Use pagination with offset/limit parameters",
        "Apply more specific filters to reduce result set",
        "Use compact field selection to reduce token usage",
        `Increase MCP_TOKEN_LIMIT (currently ${maxTokens}) in environment`
      ]
    };
  }

  return result;
}

/**
 * Create a paginated response with token limiting
 */
export function createPaginatedResponse<T>(
  data: T[],
  offset: number = 0,
  limit?: number,
  tokenLimit?: number
): TokenLimitResult<T> & { hasMore: boolean; nextOffset?: number } {
  // Apply basic pagination first if limit is specified
  let paginatedData = data;
  if (limit !== undefined) {
    paginatedData = data.slice(offset, offset + limit);
  } else {
    paginatedData = data.slice(offset);
  }

  // Apply token limiting
  const result = applyTokenLimit(paginatedData, { 
    maxTokens: tokenLimit,
    includeMetadata: true 
  });

  // Calculate if there are more results
  const totalProcessed = offset + result.returnedCount;
  const hasMore = totalProcessed < data.length;
  const nextOffset = hasMore ? totalProcessed : undefined;

  return {
    ...result,
    hasMore,
    nextOffset,
    originalCount: data.length // Override to show total count, not just page count
  };
}


================================================
FILE: tests/config.test.ts
================================================
import { getConfig } from '../src/config.js';

describe('Configuration', () => {
  const originalEnv = process.env;

  beforeEach(() => {
    jest.resetModules();
    process.env = { ...originalEnv };
  });

  afterAll(() => {
    process.env = originalEnv;
  });

  test('should return valid config when all environment variables are set', () => {
    process.env.NEO4J_URI = 'bolt://localhost:7687';
    process.env.NEO4J_USER = 'neo4j';
    process.env.NEO4J_PASSWORD = 'password';

    const config = getConfig();

    expect(config).toEqual({
      uri: 'bolt://localhost:7687',
      user: 'neo4j',
      password: 'password'
    });
  });

  test('should throw error when NEO4J_URI is missing', () => {
    process.env.NEO4J_USER = 'neo4j';
    process.env.NEO4J_PASSWORD = 'password';
    delete process.env.NEO4J_URI;

    expect(() => getConfig()).toThrow('Missing required Neo4J configuration');
  });

  test('should throw error when NEO4J_USER is missing', () => {
    process.env.NEO4J_URI = 'bolt://localhost:7687';
    process.env.NEO4J_PASSWORD = 'password';
    delete process.env.NEO4J_USER;

    expect(() => getConfig()).toThrow('Missing required Neo4J configuration');
  });

  test('should throw error when NEO4J_PASSWORD is missing', () => {
    process.env.NEO4J_URI = 'bolt://localhost:7687';
    process.env.NEO4J_USER = 'neo4j';
    delete process.env.NEO4J_PASSWORD;

    expect(() => getConfig()).toThrow('Missing required Neo4J configuration');
  });
});


================================================
FILE: tests/git-auth-manager.test.ts
================================================
import { GitAuthManager } from '../src/scanner/git/git-auth-manager.js';
import { GitUrlParser } from '../src/scanner/git/git-url-parser.js';

describe('GitAuthManager', () => {
  let authManager: GitAuthManager;

  beforeEach(() => {
    authManager = new GitAuthManager();
  });

  describe('loadAuthFromEnvironment', () => {
    const originalEnv = process.env;

    beforeEach(() => {
      process.env = { ...originalEnv };
    });

    afterEach(() => {
      process.env = originalEnv;
    });

    it('should load GitHub token from environment', async () => {
      process.env.GITHUB_TOKEN = 'ghp_test_token';
      
      await authManager.loadAuthFromEnvironment();
      const config = authManager.getAuthConfig();
      
      expect(config.github?.token).toBe('ghp_test_token');
    });

    it('should load GitLab token and host from environment', async () => {
      process.env.GITLAB_TOKEN = 'glpat-test_token';
      process.env.GITLAB_HOST = 'gitlab.company.com';
      
      await authManager.loadAuthFromEnvironment();
      const config = authManager.getAuthConfig();
      
      expect(config.gitlab?.token).toBe('glpat-test_token');
      expect(config.gitlab?.host).toBe('gitlab.company.com');
    });

    it('should load Bitbucket credentials from environment', async () => {
      process.env.BITBUCKET_USERNAME = 'testuser';
      process.env.BITBUCKET_APP_PASSWORD = 'testpass';
      
      await authManager.loadAuthFromEnvironment();
      const config = authManager.getAuthConfig();
      
      expect(config.bitbucket?.username).toBe('testuser');
      expect(config.bitbucket?.appPassword).toBe('testpass');
    });
  });

  describe('getAuthForRepository', () => {
    it('should return SSH clone URL for SSH protocol', () => {
      const parsedUrl = GitUrlParser.parse('git@github.com:owner/repo.git');
      const authDetails = authManager.getAuthForRepository(parsedUrl);
      
      expect(authDetails.cloneUrl).toBe('git@github.com:owner/repo.git');
    });

    it('should return authenticated GitHub URL with token', () => {
      authManager.updateAuthConfig({
        github: { token: 'ghp_test_token' }
      });
      
      const parsedUrl = GitUrlParser.parse('https://github.com/owner/repo.git');
      const authDetails = authManager.getAuthForRepository(parsedUrl);
      
      expect(authDetails.cloneUrl).toBe('https://ghp_test_token@github.com/owner/repo.git');
    });

    it('should return authenticated GitLab URL with token', () => {
      authManager.updateAuthConfig({
        gitlab: { token: 'glpat-test_token' }
      });
      
      const parsedUrl = GitUrlParser.parse('https://gitlab.com/owner/repo.git');
      const authDetails = authManager.getAuthForRepository(parsedUrl);
      
      expect(authDetails.cloneUrl).toBe('https://oauth2:glpat-test_token@gitlab.com/owner/repo.git');
    });

    it('should return public URL when no authentication available', () => {
      const parsedUrl = GitUrlParser.parse('https://github.com/owner/repo.git');
      const authDetails = authManager.getAuthForRepository(parsedUrl);
      
      expect(authDetails.cloneUrl).toBe('https://github.com/owner/repo.git');
    });
  });

  describe('validateAuthentication', () => {
    it('should validate SSH authentication', () => {
      authManager.updateAuthConfig({
        ssh: { privateKey: '/path/to/key' }
      });
      
      const parsedUrl = GitUrlParser.parse('git@github.com:owner/repo.git');
      const validation = authManager.validateAuthentication(parsedUrl);
      
      expect(validation.method).toBe('ssh');
      expect(validation.isValid).toBe(true);
    });

    it('should validate token authentication', () => {
      authManager.updateAuthConfig({
        github: { token: 'ghp_valid_token_123456789012345678901234567890' }
      });
      
      const parsedUrl = GitUrlParser.parse('https://github.com/owner/repo.git');
      const validation = authManager.validateAuthentication(parsedUrl);
      
      expect(validation.method).toBe('token');
      expect(validation.isValid).toBe(true);
    });

    it('should warn about invalid token format', () => {
      authManager.updateAuthConfig({
        github: { token: 'short' } // Very short token
      });
      
      const parsedUrl = GitUrlParser.parse('https://github.com/owner/repo.git');
      const validation = authManager.validateAuthentication(parsedUrl);
      
      expect(validation.method).toBe('token');
      expect(validation.isValid).toBe(false);
      expect(validation.warnings).toContain('Token appears to be invalid format');
    });

    it('should default to public access', () => {
      const parsedUrl = GitUrlParser.parse('https://github.com/owner/repo.git');
      const validation = authManager.validateAuthentication(parsedUrl);
      
      expect(validation.method).toBe('public');
      expect(validation.isValid).toBe(true);
      expect(validation.warnings).toContain('Using public access - private repositories will fail');
    });
  });

  describe('updateAuthConfig', () => {
    it('should merge auth configurations', () => {
      authManager.updateAuthConfig({
        github: { token: 'token1' }
      });
      
      authManager.updateAuthConfig({
        gitlab: { token: 'token2' }
      });
      
      const config = authManager.getAuthConfig();
      expect(config.github?.token).toBe('token1');
      expect(config.gitlab?.token).toBe('token2');
    });

    it('should override existing configurations', () => {
      authManager.updateAuthConfig({
        github: { token: 'old_token' }
      });
      
      authManager.updateAuthConfig({
        github: { token: 'new_token' }
      });
      
      const config = authManager.getAuthConfig();
      expect(config.github?.token).toBe('new_token');
    });
  });

  describe('clearAuthConfig', () => {
    it('should clear all authentication data', () => {
      authManager.updateAuthConfig({
        github: { token: 'token1' },
        gitlab: { token: 'token2' }
      });
      
      authManager.clearAuthConfig();
      
      const config = authManager.getAuthConfig();
      expect(config).toEqual({});
    });
  });
});


================================================
FILE: tests/git-cache-manager.test.ts
================================================
import { GitCacheManager } from '../src/scanner/git/git-cache-manager.js';
import { GitUrlParser } from '../src/scanner/git/git-url-parser.js';
import * as fs from 'fs/promises';
import * as path from 'path';
import * as os from 'os';

describe('GitCacheManager', () => {
  let cacheManager: GitCacheManager;
  let tempCacheDir: string;

  beforeEach(async () => {
    // Create temporary cache directory
    tempCacheDir = path.join(os.tmpdir(), 'coderag-test-cache-' + Date.now());
    cacheManager = new GitCacheManager({
      cacheDir: tempCacheDir,
      maxAge: 1000, // 1 second for testing
      maxSize: 1024 * 1024 // 1MB
    });
    
    await cacheManager.initialize();
  });

  afterEach(async () => {
    // Clean up
    try {
      await fs.rm(tempCacheDir, { recursive: true, force: true });
    } catch {
      // Ignore cleanup errors
    }
  });

  describe('getCachedRepository', () => {
    it('should return null for non-existent cache entry', async () => {
      const parsedUrl = GitUrlParser.parse('https://github.com/owner/repo.git');
      const result = await cacheManager.getCachedRepository(parsedUrl, 'main');
      
      expect(result).toBeNull();
    });

    it('should return null for expired cache entry', async () => {
      const parsedUrl = GitUrlParser.parse('https://github.com/owner/repo.git');
      
      // Create a temporary source directory
      const sourceDir = path.join(tempCacheDir, 'source');
      await fs.mkdir(sourceDir, { recursive: true });
      await fs.writeFile(path.join(sourceDir, 'test.txt'), 'test content');
      
      // Add to cache
      await cacheManager.addToCache(parsedUrl, 'main', sourceDir);
      
      // Wait for expiration (1 second)
      await new Promise(resolve => setTimeout(resolve, 1100));
      
      // Should return null for expired entry
      const result = await cacheManager.getCachedRepository(parsedUrl, 'main');
      expect(result).toBeNull();
    });
  });

  describe('addToCache', () => {
    it('should add repository to cache', async () => {
      const parsedUrl = GitUrlParser.parse('https://github.com/owner/repo.git');
      
      // Create a temporary source directory
      const sourceDir = path.join(tempCacheDir, 'source');
      await fs.mkdir(sourceDir, { recursive: true });
      await fs.writeFile(path.join(sourceDir, 'test.txt'), 'test content');
      
      // Add to cache
      const cachedPath = await cacheManager.addToCache(parsedUrl, 'main', sourceDir);
      
      // Verify cache entry exists
      expect(cachedPath).toBeTruthy();
      const stats = await fs.stat(cachedPath);
      expect(stats.isDirectory()).toBe(true);
      
      // Verify file was copied
      const testFile = path.join(cachedPath, 'test.txt');
      const content = await fs.readFile(testFile, 'utf-8');
      expect(content).toBe('test content');
    });

    it('should retrieve cached repository', async () => {
      const parsedUrl = GitUrlParser.parse('https://github.com/owner/repo.git');
      
      // Create source directory with content
      const sourceDir = path.join(tempCacheDir, 'source');
      await fs.mkdir(sourceDir, { recursive: true });
      await fs.writeFile(path.join(sourceDir, 'test.txt'), 'test content');
      
      // Add to cache
      await cacheManager.addToCache(parsedUrl, 'main', sourceDir);
      
      // Retrieve from cache
      const cachedPath = await cacheManager.getCachedRepository(parsedUrl, 'main');
      
      expect(cachedPath).toBeTruthy();
      if (cachedPath) {
        const testFile = path.join(cachedPath, 'test.txt');
        const content = await fs.readFile(testFile, 'utf-8');
        expect(content).toBe('test content');
      }
    });
  });

  describe('getCacheStats', () => {
    it('should return cache statistics', async () => {
      const stats = await cacheManager.getCacheStats();
      
      expect(stats).toHaveProperty('entries');
      expect(stats).toHaveProperty('totalSize');
      expect(stats.entries).toBe(0); // Initially empty
    });

    it('should update statistics after adding entries', async () => {
      const parsedUrl = GitUrlParser.parse('https://github.com/owner/repo.git');
      
      // Create source directory
      const sourceDir = path.join(tempCacheDir, 'source');
      await fs.mkdir(sourceDir, { recursive: true });
      await fs.writeFile(path.join(sourceDir, 'test.txt'), 'test content');
      
      // Add to cache
      await cacheManager.addToCache(parsedUrl, 'main', sourceDir);
      
      const stats = await cacheManager.getCacheStats();
      expect(stats.entries).toBe(1);
      expect(stats.totalSize).toBeGreaterThan(0);
    });
  });

  describe('clearCache', () => {
    it('should clear all cache entries', async () => {
      const parsedUrl = GitUrlParser.parse('https://github.com/owner/repo.git');
      
      // Create and cache repository
      const sourceDir = path.join(tempCacheDir, 'source');
      await fs.mkdir(sourceDir, { recursive: true });
      await fs.writeFile(path.join(sourceDir, 'test.txt'), 'test content');
      await cacheManager.addToCache(parsedUrl, 'main', sourceDir);
      
      // Verify cache has entries
      let stats = await cacheManager.getCacheStats();
      expect(stats.entries).toBe(1);
      
      // Clear cache
      await cacheManager.clearCache();
      
      // Verify cache is empty
      stats = await cacheManager.getCacheStats();
      expect(stats.entries).toBe(0);
      
      // Verify cached repository is no longer accessible
      const cachedPath = await cacheManager.getCachedRepository(parsedUrl, 'main');
      expect(cachedPath).toBeNull();
    });
  });
});


================================================
FILE: tests/git-url-parser.test.ts
================================================
import { GitUrlParser } from '../src/scanner/git/git-url-parser.js';
import { GitError } from '../src/scanner/git/types.js';

describe('GitUrlParser', () => {
  describe('parse', () => {
    it('should parse HTTPS GitHub URLs correctly', () => {
      const url = 'https://github.com/owner/repo.git';
      const result = GitUrlParser.parse(url);
      
      expect(result.protocol).toBe('https');
      expect(result.provider).toBe('github');
      expect(result.host).toBe('github.com');
      expect(result.owner).toBe('owner');
      expect(result.repo).toBe('repo');
      expect(result.originalUrl).toBe(url);
    });

    it('should parse HTTPS URLs without .git suffix', () => {
      const url = 'https://github.com/owner/repo';
      const result = GitUrlParser.parse(url);
      
      expect(result.protocol).toBe('https');
      expect(result.provider).toBe('github');
      expect(result.host).toBe('github.com');
      expect(result.owner).toBe('owner');
      expect(result.repo).toBe('repo');
    });

    it('should parse SSH GitHub URLs correctly', () => {
      const url = 'git@github.com:owner/repo.git';
      const result = GitUrlParser.parse(url);
      
      expect(result.protocol).toBe('ssh');
      expect(result.provider).toBe('github');
      expect(result.host).toBe('github.com');
      expect(result.owner).toBe('owner');
      expect(result.repo).toBe('repo');
    });

    it('should parse GitLab URLs correctly', () => {
      const url = 'https://gitlab.com/owner/repo.git';
      const result = GitUrlParser.parse(url);
      
      expect(result.protocol).toBe('https');
      expect(result.provider).toBe('gitlab');
      expect(result.host).toBe('gitlab.com');
      expect(result.owner).toBe('owner');
      expect(result.repo).toBe('repo');
    });

    it('should parse Bitbucket URLs correctly', () => {
      const url = 'https://bitbucket.org/owner/repo.git';
      const result = GitUrlParser.parse(url);
      
      expect(result.protocol).toBe('https');
      expect(result.provider).toBe('bitbucket');
      expect(result.host).toBe('bitbucket.org');
      expect(result.owner).toBe('owner');
      expect(result.repo).toBe('repo');
    });

    it('should parse custom Git server URLs correctly', () => {
      const url = 'https://git.company.com/owner/repo.git';
      const result = GitUrlParser.parse(url);
      
      expect(result.protocol).toBe('https');
      expect(result.provider).toBe('custom');
      expect(result.host).toBe('git.company.com');
      expect(result.owner).toBe('owner');
      expect(result.repo).toBe('repo');
    });

    it('should parse git protocol URLs correctly', () => {
      const url = 'git://github.com/owner/repo.git';
      const result = GitUrlParser.parse(url);
      
      expect(result.protocol).toBe('git');
      expect(result.provider).toBe('github');
      expect(result.host).toBe('github.com');
      expect(result.owner).toBe('owner');
      expect(result.repo).toBe('repo');
    });

    it('should throw error for invalid URLs', () => {
      expect(() => GitUrlParser.parse('')).toThrow(GitError);
      expect(() => GitUrlParser.parse('not-a-url')).toThrow(GitError);
      expect(() => GitUrlParser.parse('https://github.com')).toThrow(GitError);
    });

    it('should throw error for null/undefined URLs', () => {
      expect(() => GitUrlParser.parse(null as any)).toThrow(GitError);
      expect(() => GitUrlParser.parse(undefined as any)).toThrow(GitError);
    });
  });

  describe('isGitUrl', () => {
    it('should return true for valid git URLs', () => {
      expect(GitUrlParser.isGitUrl('https://github.com/owner/repo.git')).toBe(true);
      expect(GitUrlParser.isGitUrl('git@github.com:owner/repo.git')).toBe(true);
      expect(GitUrlParser.isGitUrl('git://github.com/owner/repo.git')).toBe(true);
    });

    it('should return false for invalid URLs', () => {
      expect(GitUrlParser.isGitUrl('')).toBe(false);
      expect(GitUrlParser.isGitUrl('not-a-url')).toBe(false);
      expect(GitUrlParser.isGitUrl('https://github.com')).toBe(false);
    });
  });

  describe('validateUrl', () => {
    it('should return valid=true for valid URLs', () => {
      const result = GitUrlParser.validateUrl('https://github.com/owner/repo.git');
      expect(result.valid).toBe(true);
      expect(result.error).toBeUndefined();
    });

    it('should return valid=false with error for invalid URLs', () => {
      const result = GitUrlParser.validateUrl('invalid-url');
      expect(result.valid).toBe(false);
      expect(result.error).toBeDefined();
    });
  });

  describe('normalizeUrl', () => {
    it('should normalize SSH URLs to HTTPS', () => {
      const parsedUrl = GitUrlParser.parse('git@github.com:owner/repo.git');
      const normalized = GitUrlParser.normalizeUrl(parsedUrl);
      expect(normalized).toBe('https://github.com/owner/repo.git');
    });

    it('should keep HTTPS URLs as-is', () => {
      const parsedUrl = GitUrlParser.parse('https://github.com/owner/repo.git');
      const normalized = GitUrlParser.normalizeUrl(parsedUrl);
      expect(normalized).toBe('https://github.com/owner/repo.git');
    });
  });

  describe('buildCloneUrl', () => {
    it('should build HTTPS clone URL', () => {
      const parsedUrl = GitUrlParser.parse('https://github.com/owner/repo.git');
      const cloneUrl = GitUrlParser.buildCloneUrl(parsedUrl);
      expect(cloneUrl).toBe('https://github.com/owner/repo.git');
    });

    it('should build SSH clone URL', () => {
      const parsedUrl = GitUrlParser.parse('git@github.com:owner/repo.git');
      const cloneUrl = GitUrlParser.buildCloneUrl(parsedUrl);
      expect(cloneUrl).toBe('git@github.com:owner/repo.git');
    });

    it('should build GitHub clone URL with token', () => {
      const parsedUrl = GitUrlParser.parse('https://github.com/owner/repo.git');
      const cloneUrl = GitUrlParser.buildCloneUrl(parsedUrl, 'token123');
      expect(cloneUrl).toBe('https://token123@github.com/owner/repo.git');
    });

    it('should build GitLab clone URL with token', () => {
      const parsedUrl = GitUrlParser.parse('https://gitlab.com/owner/repo.git');
      const cloneUrl = GitUrlParser.buildCloneUrl(parsedUrl, 'token123');
      expect(cloneUrl).toBe('https://oauth2:token123@gitlab.com/owner/repo.git');
    });
  });
});


================================================
FILE: tests/remote-scanner-tools.test.ts
================================================
import { createRemoteScannerTools, handleRemoteScannerTool } from '../src/mcp/tools/remote-scanner-tools.js';
import { Neo4jClient } from '../src/graph/neo4j-client.js';
import { CodebaseScanner } from '../src/scanner/codebase-scanner.js';

// Mock the dependencies
jest.mock('../src/graph/neo4j-client.js');
jest.mock('../src/scanner/codebase-scanner.js');

describe('Remote Scanner Tools', () => {
  let mockClient: jest.Mocked<Neo4jClient>;
  let mockScanner: jest.Mocked<CodebaseScanner>;

  beforeEach(() => {
    mockClient = new Neo4jClient({
      uri: 'bolt://localhost:7687',
      user: 'neo4j',
      password: 'test'
    }) as jest.Mocked<Neo4jClient>;

    mockScanner = new CodebaseScanner(mockClient) as jest.Mocked<CodebaseScanner>;
    
    // Mock scanner methods
    mockScanner.scanRemoteRepository = jest.fn();
    mockScanner.validateRemoteRepository = jest.fn();
    mockScanner.parseGitUrl = jest.fn();
    mockScanner.clearGraph = jest.fn();
    mockScanner.clearCache = jest.fn();
    mockScanner.getCacheStats = jest.fn();

    // Mock CodebaseScanner constructor
    (CodebaseScanner as jest.MockedClass<typeof CodebaseScanner>).mockImplementation(() => mockScanner);
  });

  describe('createRemoteScannerTools', () => {
    it('should return array of remote scanner tools', () => {
      const tools = createRemoteScannerTools(mockClient);
      
      expect(tools).toHaveLength(4);
      
      const toolNames = tools.map(tool => tool.name);
      expect(toolNames).toContain('scan_remote_repo');
      expect(toolNames).toContain('validate_remote_repo');
      expect(toolNames).toContain('git_cache_stats');
      expect(toolNames).toContain('clear_git_cache');
    });

    it('should have proper schema for scan_remote_repo tool', () => {
      const tools = createRemoteScannerTools(mockClient);
      const scanTool = tools.find(tool => tool.name === 'scan_remote_repo');
      
      expect(scanTool).toBeDefined();
      expect(scanTool?.description).toContain('remote Git repository');
      expect(scanTool?.inputSchema.required).toContain('gitUrl');
    });
  });

  describe('handleRemoteScannerTool', () => {
    describe('scan_remote_repo', () => {
      it('should handle successful repository scanning', async () => {
        const mockScanResult = {
          stats: {
            filesProcessed: 10,
            entitiesFound: 50,
            relationshipsFound: 25,
            processingTimeMs: 1000
          },
          errors: []
        };

        mockScanner.parseGitUrl.mockReturnValue({
          protocol: 'https',
          provider: 'github',
          host: 'github.com',
          owner: 'test-owner',
          repo: 'test-repo',
          originalUrl: 'https://github.com/test-owner/test-repo.git'
        });

        mockScanner.scanRemoteRepository.mockResolvedValue(mockScanResult as any);

        const result = await handleRemoteScannerTool('scan_remote_repo', {
          gitUrl: 'https://github.com/test-owner/test-repo.git'
        }, mockClient);

        expect(result.success).toBe(true);
        expect(result.projectId).toBe('test-owner-test-repo');
        expect(result.scanResults.filesProcessed).toBe(10);
        expect(result.scanResults.entitiesFound).toBe(50);
        expect(mockScanner.scanRemoteRepository).toHaveBeenCalledWith(
          'https://github.com/test-owner/test-repo.git',
          expect.objectContaining({
            projectId: 'test-owner-test-repo',
            languages: ['typescript', 'javascript', 'java', 'python'],
            includeTests: false,
            outputProgress: true
          })
        );
      });

      it('should handle custom project ID', async () => {
        const mockScanResult = {
          stats: { filesProcessed: 5, entitiesFound: 20, relationshipsFound: 10, processingTimeMs: 500 },
          errors: []
        };

        mockScanner.parseGitUrl.mockReturnValue({
          protocol: 'https',
          provider: 'github',
          host: 'github.com',
          owner: 'test-owner',
          repo: 'test-repo',
          originalUrl: 'https://github.com/test-owner/test-repo.git'
        });

        mockScanner.scanRemoteRepository.mockResolvedValue(mockScanResult as any);

        const result = await handleRemoteScannerTool('scan_remote_repo', {
          gitUrl: 'https://github.com/test-owner/test-repo.git',
          projectId: 'custom-project-id'
        }, mockClient);

        expect(result.projectId).toBe('custom-project-id');
        expect(mockScanner.scanRemoteRepository).toHaveBeenCalledWith(
          'https://github.com/test-owner/test-repo.git',
          expect.objectContaining({
            projectId: 'custom-project-id'
          })
        );
      });

      it('should clear graph when requested', async () => {
        const mockScanResult = {
          stats: { filesProcessed: 1, entitiesFound: 5, relationshipsFound: 2, processingTimeMs: 100 },
          errors: []
        };

        mockScanner.parseGitUrl.mockReturnValue({
          protocol: 'https',
          provider: 'github',
          host: 'github.com',
          owner: 'test-owner',
          repo: 'test-repo',
          originalUrl: 'https://github.com/test-owner/test-repo.git'
        });

        mockScanner.scanRemoteRepository.mockResolvedValue(mockScanResult as any);

        await handleRemoteScannerTool('scan_remote_repo', {
          gitUrl: 'https://github.com/test-owner/test-repo.git',
          clearGraph: true
        }, mockClient);

        expect(mockScanner.clearGraph).toHaveBeenCalledWith('test-owner-test-repo');
      });
    });

    describe('validate_remote_repo', () => {
      it('should validate accessible repository', async () => {
        const mockRepoInfo = {
          name: 'test-repo',
          fullName: 'test-owner/test-repo',
          url: 'https://github.com/test-owner/test-repo.git',
          branch: 'main'
        };

        mockScanner.validateRemoteRepository.mockResolvedValue(true);
        
        // Mock the git manager through scanner
        const mockGitManager = {
          validateRepository: jest.fn().mockResolvedValue(mockRepoInfo)
        };
        (mockScanner as any).gitManager = mockGitManager;

        const result = await handleRemoteScannerTool('validate_remote_repo', {
          gitUrl: 'https://github.com/test-owner/test-repo.git'
        }, mockClient);

        expect(result.valid).toBe(true);
        expect(result.repository).toEqual(mockRepoInfo);
        expect(mockScanner.validateRemoteRepository).toHaveBeenCalledWith(
          'https://github.com/test-owner/test-repo.git'
        );
      });

      it('should handle inaccessible repository', async () => {
        mockScanner.validateRemoteRepository.mockResolvedValue(false);

        const result = await handleRemoteScannerTool('validate_remote_repo', {
          gitUrl: 'https://github.com/invalid/repo.git'
        }, mockClient);

        expect(result.valid).toBe(false);
        expect(result.error).toBe('Repository validation failed');
      });

      it('should handle validation errors', async () => {
        mockScanner.validateRemoteRepository.mockRejectedValue(new Error('Network error'));

        const result = await handleRemoteScannerTool('validate_remote_repo', {
          gitUrl: 'https://github.com/test-owner/test-repo.git'
        }, mockClient);

        expect(result.valid).toBe(false);
        expect(result.error).toBe('Network error');
      });
    });

    describe('git_cache_stats', () => {
      it('should return cache statistics', async () => {
        const mockStats = {
          entries: 3,
          totalSize: 1024 * 1024, // 1MB
          oldestEntry: new Date('2024-01-01'),
          newestEntry: new Date('2024-01-02')
        };

        mockScanner.getCacheStats.mockResolvedValue(mockStats);

        const result = await handleRemoteScannerTool('git_cache_stats', {}, mockClient);

        expect(result.cache.entries).toBe(3);
        expect(result.cache.totalSizeBytes).toBe(1024 * 1024);
        expect(result.cache.totalSizeMB).toBe(1);
        expect(result.cache.oldestEntry).toBe('2024-01-01T00:00:00.000Z');
        expect(result.cache.newestEntry).toBe('2024-01-02T00:00:00.000Z');
      });
    });

    describe('clear_git_cache', () => {
      it('should clear cache and return statistics', async () => {
        const mockStatsBefore = {
          entries: 5,
          totalSize: 2 * 1024 * 1024 // 2MB
        };

        mockScanner.getCacheStats.mockResolvedValue(mockStatsBefore);
        mockScanner.clearCache.mockResolvedValue();

        const result = await handleRemoteScannerTool('clear_git_cache', {}, mockClient);

        expect(result.success).toBe(true);
        expect(result.clearedEntries).toBe(5);
        expect(result.freedSpaceBytes).toBe(2 * 1024 * 1024);
        expect(result.freedSpaceMB).toBe(2);
        expect(mockScanner.clearCache).toHaveBeenCalled();
      });
    });

    describe('error handling', () => {
      it('should throw error for unknown tool', async () => {
        await expect(
          handleRemoteScannerTool('unknown_tool', {}, mockClient)
        ).rejects.toThrow('Unknown remote scanner tool: unknown_tool');
      });
    });
  });
});


================================================
FILE: tests/simple-components.test.ts
================================================
// Simple tests for core components to boost coverage
import { Neo4jClient } from '../src/graph/neo4j-client.js';
import { NodeManager } from '../src/graph/node-manager.js';
import { EdgeManager } from '../src/graph/edge-manager.js';

// Mock the dependencies
jest.mock('neo4j-driver');

describe('Simple Component Tests', () => {
  let mockClient: jest.Mocked<Neo4jClient>;

  beforeEach(() => {
    mockClient = {
      runQuery: jest.fn().mockResolvedValue({ records: [] }),
      getProjectLabel: jest.fn().mockReturnValue('Project_test_Class')
    } as any;
  });

  describe('NodeManager Simple Tests', () => {
    test('should handle empty search results', async () => {
      const nodeManager = new NodeManager(mockClient);
      
      const result = await nodeManager.findNodesByName('NonExistent', 'test-project');
      expect(result).toEqual([]);
      expect(mockClient.runQuery).toHaveBeenCalled();
    });

    test('should get node label for different types', () => {
      const nodeManager = new NodeManager(mockClient);
      
      // Test private method via reflection
      const getNodeLabel = (nodeManager as any).getNodeLabel;
      
      expect(getNodeLabel('class')).toBe('Class');
      expect(getNodeLabel('interface')).toBe('Interface');
      expect(getNodeLabel('enum')).toBe('Enum');
      expect(getNodeLabel('method')).toBe('Method');
      expect(getNodeLabel('function')).toBe('Function');
      expect(getNodeLabel('field')).toBe('Field');
      expect(getNodeLabel('module')).toBe('Module');
      expect(getNodeLabel('package')).toBe('Package');
      expect(getNodeLabel('unknown' as any)).toBe('CodeNode');
    });

    test('should ensure plain object conversion', () => {
      const nodeManager = new NodeManager(mockClient);
      const ensurePlainObject = (nodeManager as any).ensurePlainObject;
      
      expect(ensurePlainObject(null)).toBeNull();
      expect(ensurePlainObject(undefined)).toBeUndefined();
      expect(ensurePlainObject(['a', 'b'])).toEqual(['a', 'b']);
      expect(ensurePlainObject({ a: 1, b: 2 })).toEqual({ a: 1, b: 2 });
    });
  });

  describe('EdgeManager Simple Tests', () => {
    test('should handle empty edge queries', async () => {
      const edgeManager = new EdgeManager(mockClient);
      
      const result = await edgeManager.findEdgesByType('calls', 'test-project');
      expect(result).toEqual([]);
      expect(mockClient.runQuery).toHaveBeenCalled();
    });

    test('should handle inheritance hierarchy with no results', async () => {
      const edgeManager = new EdgeManager(mockClient);
      
      const result = await edgeManager.findInheritanceHierarchy('OrphanClass', 'test-project');
      expect(result).toEqual([]);
    });

    test('should ensure plain object conversion for edges', () => {
      const edgeManager = new EdgeManager(mockClient);
      const ensurePlainObject = (edgeManager as any).ensurePlainObject.bind(edgeManager);
      
      // Test Map conversion
      const map = new Map([['key1', 'value1'], ['key2', 'value2']]);
      const result = ensurePlainObject(map);
      expect(result).toEqual({ key1: 'value1', key2: 'value2' });
    });
  });

  describe('Neo4jClient Simple Tests', () => {
    test('should generate project labels correctly', () => {
      const client = new Neo4jClient({ uri: 'bolt://localhost:7687', user: 'test', password: 'test' });
      
      expect(client.getProjectLabel('my-project', 'class')).toBe('Project_my-project_Class');
      expect(client.getProjectLabel('test_proj', 'method')).toBe('Project_test_proj_Method');
    });

    test('should generate and parse scoped IDs', () => {
      const client = new Neo4jClient({ uri: 'bolt://localhost:7687', user: 'test', password: 'test' });
      
      const scopedId = client.generateProjectScopedId('project1', 'entity123');
      expect(scopedId).toBe('project1:entity123');
      
      const parsed = client.parseProjectScopedId('project1:namespace:class:method');
      expect(parsed.projectId).toBe('project1');
      expect(parsed.entityId).toBe('namespace:class:method');
    });
  });
});


================================================
FILE: tests/types.test.ts
================================================
import { CodeNode, CodeEdge } from '../src/types.js';

describe('Types', () => {
  test('should create a valid CodeNode', () => {
    const node: CodeNode = {
      id: 'test-id',
      project_id: 'test-project',
      type: 'class',
      name: 'TestClass',
      qualified_name: 'com.example.TestClass',
      description: 'A test class',
      source_file: 'TestClass.java',
      start_line: 10,
      end_line: 50,
      modifiers: ['public'],
      attributes: {
        parameters: [
          {
            name: 'param1',
            type: 'String',
            description: 'First parameter'
          }
        ],
        return_type: 'void'
      }
    };

    expect(node.id).toBe('test-id');
    expect(node.type).toBe('class');
    expect(node.name).toBe('TestClass');
    expect(node.qualified_name).toBe('com.example.TestClass');
    expect(node.attributes?.parameters?.[0].name).toBe('param1');
  });

  test('should create a valid CodeEdge', () => {
    const edge: CodeEdge = {
      id: 'edge-id',
      project_id: 'test-project',
      type: 'implements',
      source: 'source-node-id',
      target: 'target-node-id',
      attributes: {
        weight: 1.0
      }
    };

    expect(edge.id).toBe('edge-id');
    expect(edge.type).toBe('implements');
    expect(edge.source).toBe('source-node-id');
    expect(edge.target).toBe('target-node-id');
    expect(edge.attributes?.weight).toBe(1.0);
  });

  test('should allow minimal CodeNode', () => {
    const node: CodeNode = {
      id: 'minimal-id',
      project_id: 'test-project',
      type: 'function',
      name: 'testFunction',
      qualified_name: 'testFunction'
    };

    expect(node.id).toBe('minimal-id');
    expect(node.type).toBe('function');
    expect(node.description).toBeUndefined();
    expect(node.attributes).toBeUndefined();
  });

  test('should allow minimal CodeEdge', () => {
    const edge: CodeEdge = {
      id: 'minimal-edge-id',
      project_id: 'test-project',
      type: 'calls',
      source: 'source-id',
      target: 'target-id'
    };

    expect(edge.id).toBe('minimal-edge-id');
    expect(edge.type).toBe('calls');
    expect(edge.attributes).toBeUndefined();
  });
});


================================================
FILE: tests/analysis/metrics-manager.test.ts
================================================
import { MetricsManager } from '../../src/analysis/metrics-manager.js';
import { Neo4jClient } from '../../src/graph/neo4j-client.js';

// Mock the Neo4jClient
jest.mock('../../src/graph/neo4j-client.js');

describe('MetricsManager', () => {
  let metricsManager: MetricsManager;
  let mockClient: jest.Mocked<Neo4jClient>;

  beforeEach(() => {
    mockClient = {
      runQuery: jest.fn()
    } as any;

    metricsManager = new MetricsManager(mockClient);
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('calculateCKMetrics', () => {
    test('should calculate all CK metrics for a class', async () => {
      // Mock class name query
      const mockRunQuery = mockClient.runQuery as jest.Mock;
      mockRunQuery
        .mockResolvedValueOnce({ records: [{ get: () => 'TestClass' }] }) // getClassName
        .mockResolvedValueOnce({ records: [{ get: () => ({ toNumber: () => 10 }) }] }) // WMC
        .mockResolvedValueOnce({ records: [{ get: () => ({ toNumber: () => 2 }) }] }) // DIT
        .mockResolvedValueOnce({ records: [{ get: () => ({ toNumber: () => 3 }) }] }) // NOC
        .mockResolvedValueOnce({ records: [{ get: () => ({ toNumber: () => 5 }) }] }) // CBO
        .mockResolvedValueOnce({ records: [{ get: () => ({ toNumber: () => 15 }) }] }) // RFC
        .mockResolvedValueOnce({ records: [{ get: (key: string) => ({ toNumber: () => key === 'methods' ? 10 : 8 }) }] }); // LCOM

      const result = await metricsManager.calculateCKMetrics('test-class-id');

      expect(result).toEqual({
        classId: 'test-class-id',
        className: 'TestClass',
        wmc: 10,
        dit: 2,
        noc: 3,
        cbo: 5,
        rfc: 15,
        lcom: 2 // max(0, 10 - 8)
      });

      expect(mockClient.runQuery).toHaveBeenCalledTimes(7); // getClassName + 6 metrics
    });

    test('should handle zero values gracefully', async () => {
      // Mock all queries to return zero/null values
      const mockRunQuery = mockClient.runQuery as jest.Mock;
      mockRunQuery
        .mockResolvedValueOnce({ records: [{ get: () => 'EmptyClass' }] }) // getClassName
        .mockResolvedValueOnce({ records: [{ get: () => ({ toNumber: () => 0 }) }] }) // WMC
        .mockResolvedValueOnce({ records: [{ get: () => null }] }) // DIT (no inheritance)
        .mockResolvedValueOnce({ records: [{ get: () => ({ toNumber: () => 0 }) }] }) // NOC
        .mockResolvedValueOnce({ records: [{ get: () => ({ toNumber: () => 0 }) }] }) // CBO
        .mockResolvedValueOnce({ records: [{ get: () => ({ toNumber: () => 0 }) }] }) // RFC
        .mockResolvedValueOnce({ records: [{ get: (key: string) => ({ toNumber: () => 0 }) }] }); // LCOM

      const result = await metricsManager.calculateCKMetrics('empty-class-id');

      expect(result.wmc).toBe(0);
      expect(result.dit).toBe(0);
      expect(result.noc).toBe(0);
      expect(result.cbo).toBe(0);
      expect(result.rfc).toBe(0);
      expect(result.lcom).toBe(0);
    });
  });

  describe('calculatePackageMetrics', () => {
    test('should calculate package metrics correctly', async () => {
      // Mock CA, CE, and abstractness queries
      const mockRunQuery = mockClient.runQuery as jest.Mock;
      mockRunQuery
        .mockResolvedValueOnce({ records: [{ get: () => ({ toNumber: () => 3 }) }] }) // CA
        .mockResolvedValueOnce({ records: [{ get: () => ({ toNumber: () => 2 }) }] }) // CE
        .mockResolvedValueOnce({ 
          records: [{ 
            get: (key: string) => ({ toNumber: () => key === 'abstractClasses' ? 2 : 5 }) 
          }] 
        }); // Abstractness

      const result = await metricsManager.calculatePackageMetrics('com.example');

      expect(result.packageName).toBe('com.example');
      expect(result.ca).toBe(3);
      expect(result.ce).toBe(2);
      expect(result.instability).toBe(0.4);
      expect(result.abstractness).toBe(0.4);
      expect(result.distance).toBeCloseTo(0.2, 10);
    });

    test('should handle package with no coupling', async () => {
      const mockRunQuery = mockClient.runQuery as jest.Mock;
      mockRunQuery
        .mockResolvedValueOnce({ records: [{ get: () => ({ toNumber: () => 0 }) }] }) // CA
        .mockResolvedValueOnce({ records: [{ get: () => ({ toNumber: () => 0 }) }] }) // CE
        .mockResolvedValueOnce({ 
          records: [{ 
            get: (key: string) => ({ toNumber: () => 0 }) 
          }] 
        }); // Abstractness

      const result = await metricsManager.calculatePackageMetrics('isolated.package');

      expect(result.instability).toBe(0);
      expect(result.distance).toBe(1); // |0 + 0 - 1|
    });
  });

  describe('findArchitecturalIssues', () => {
    test('should find multiple types of architectural issues', async () => {
      // Mock circular dependencies
      const mockRunQuery = mockClient.runQuery as jest.Mock;
      mockRunQuery
        .mockResolvedValueOnce({ records: [{ get: () => 'com.example.circular' }] }) // Circular deps
        .mockResolvedValueOnce({ // God classes
          records: [{
            get: (key: string) => {
              switch(key) {
                case 'classId': return 'god-class-id';
                case 'className': return 'GodClass';
                case 'methodCount': return { toNumber: () => 25 };
                case 'coupling': return { toNumber: () => 15 };
                default: return null;
              }
            }
          }]
        })
        .mockResolvedValueOnce({ // High coupling
          records: [{
            get: (key: string) => {
              switch(key) {
                case 'classId': return 'coupled-class-id';
                case 'className': return 'CoupledClass';
                case 'coupling': return { toNumber: () => 30 };
                default: return null;
              }
            }
          }]
        });

      const issues = await metricsManager.findArchitecturalIssues();

      expect(issues).toHaveLength(3);
      
      const circularIssue = issues.find(i => i.type === 'circular_dependency');
      expect(circularIssue?.severity).toBe('high');
      expect(circularIssue?.entities).toContain('com.example.circular');

      const godClassIssue = issues.find(i => i.type === 'god_class');
      expect(godClassIssue?.severity).toBe('high');
      expect(godClassIssue?.metrics?.methodCount).toBe(25);

      const couplingIssue = issues.find(i => i.type === 'high_coupling');
      expect(couplingIssue?.severity).toBe('critical'); // > 25
      expect(couplingIssue?.metrics?.coupling).toBe(30);
    });

    test('should return empty array when no issues found', async () => {
      const mockRunQuery = mockClient.runQuery as jest.Mock;
      mockRunQuery
        .mockResolvedValueOnce({ records: [] }) // No circular deps
        .mockResolvedValueOnce({ records: [] }) // No god classes
        .mockResolvedValueOnce({ records: [] }); // No high coupling

      const issues = await metricsManager.findArchitecturalIssues();
      expect(issues).toHaveLength(0);
    });
  });

  describe('calculateProjectSummary', () => {
    test('should calculate comprehensive project summary', async () => {
      const mockRunQuery = mockClient.runQuery as jest.Mock;
      mockRunQuery
        .mockResolvedValueOnce({ records: [{ get: () => ({ toNumber: () => 50 }) }] }) // Total classes
        .mockResolvedValueOnce({ records: [{ get: () => ({ toNumber: () => 200 }) }] }) // Total methods
        .mockResolvedValueOnce({ records: [{ get: () => ({ toNumber: () => 10 }) }] }) // Total packages
        .mockResolvedValueOnce({ // Average metrics
          records: [{
            get: (key: string) => {
              switch(key) {
                case 'avgCBO': return 5.5;
                case 'avgRFC': return 12.3;
                case 'avgDIT': return 1.8;
                default: return 0;
              }
            }
          }]
        })
        .mockResolvedValueOnce({ records: [] }) // No circular deps
        .mockResolvedValueOnce({ records: [] }) // No god classes
        .mockResolvedValueOnce({ records: [] }); // No high coupling

      const summary = await metricsManager.calculateProjectSummary();

      expect(summary).toEqual({
        totalClasses: 50,
        totalMethods: 200,
        totalPackages: 10,
        averageMetrics: {
          avgCBO: 5.5,
          avgRFC: 12.3,
          avgDIT: 1.8
        },
        issueCount: 0
      });
    });
  });

  describe('helper methods', () => {
    test('should get class name', async () => {
      const mockRunQuery = mockClient.runQuery as jest.Mock;
      mockRunQuery.mockResolvedValueOnce({
        records: [{ get: () => 'TestClass' }]
      });

      const name = await (metricsManager as any).getClassName('test-id');
      expect(name).toBe('TestClass');
    });

    test('should return Unknown for missing class name', async () => {
      const mockRunQuery = mockClient.runQuery as jest.Mock;
      mockRunQuery.mockResolvedValueOnce({
        records: []
      });

      const name = await (metricsManager as any).getClassName('missing-id');
      expect(name).toBe('Unknown');
    });
  });
});


================================================
FILE: tests/graph/edge-manager.test.ts
================================================
import { EdgeManager } from '../../src/graph/edge-manager.js';
import { Neo4jClient } from '../../src/graph/neo4j-client.js';
import { CodeEdge } from '../../src/types.js';

// Mock the Neo4jClient
jest.mock('../../src/graph/neo4j-client.js');

describe('EdgeManager', () => {
  let edgeManager: EdgeManager;
  let mockClient: jest.Mocked<Neo4jClient>;
  let mockResult: any;

  beforeEach(() => {
    mockResult = {
      records: []
    };

    mockClient = {
      runQuery: jest.fn().mockResolvedValue(mockResult)
    } as any;

    edgeManager = new EdgeManager(mockClient);
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('addEdge', () => {
    test('should add edge successfully', async () => {
      const edge: CodeEdge = {
        id: 'test-edge',
        project_id: 'test-project',
        type: 'implements',
        source: 'source-node',
        target: 'target-node'
      };

      const mockRecord = {
        get: jest.fn().mockImplementation((key: string) => {
          if (key === 'r') {
            return {
              properties: {
                id: 'test-edge',
                project_id: 'test-project',
                type: 'implements',
                attributes_json: '{}'
              }
            };
          }
          if (key === 'sourceId') return 'source-node';
          if (key === 'targetId') return 'target-node';
        })
      };

      mockResult.records = [mockRecord];

      const result = await edgeManager.addEdge(edge);
      expect(result.id).toBe('test-edge');
      expect(result.type).toBe('implements');
      expect(result.source).toBe('source-node');
      expect(result.target).toBe('target-node');
      expect(mockClient.runQuery).toHaveBeenCalled();
    });

    test('should retry with interface name for implements relationship', async () => {
      const edge: CodeEdge = {
        id: 'test-edge',
        project_id: 'test-project',
        type: 'implements',
        source: 'source-node',
        target: 'com.example.TargetInterface'
      };

      // First call returns empty, second call returns result
      mockClient.runQuery
        .mockResolvedValueOnce({ records: [] })
        .mockResolvedValueOnce({
          records: [{
            get: jest.fn().mockImplementation((key: string) => {
              if (key === 'r') {
                return {
                  properties: {
                    id: 'test-edge',
                    project_id: 'test-project',
                    type: 'implements',
                    attributes_json: '{}'
                  }
                };
              }
              if (key === 'sourceId') return 'source-node';
              if (key === 'targetId') return 'target-node';
            })
          }]
        });

      const result = await edgeManager.addEdge(edge);
      expect(result.id).toBe('test-edge');
      expect(mockClient.runQuery).toHaveBeenCalledTimes(2);
    });

    test('should throw error when edge creation fails', async () => {
      const edge: CodeEdge = {
        id: 'test-edge',
        project_id: 'test-project',
        type: 'calls',
        source: 'source-node',
        target: 'target-node'
      };

      mockResult.records = [];

      await expect(edgeManager.addEdge(edge)).rejects.toThrow('Failed to create edge - source or target node not found');
    });

    test('should handle edge with attributes', async () => {
      const edge: CodeEdge = {
        id: 'test-edge',
        project_id: 'test-project',
        type: 'calls',
        source: 'source-node',
        target: 'target-node',
        attributes: {
          line_number: 42,
          confidence: 0.95
        }
      };

      const mockRecord = {
        get: jest.fn().mockImplementation((key: string) => {
          if (key === 'r') {
            return {
              properties: {
                id: 'test-edge',
                project_id: 'test-project',
                type: 'calls',
                attributes_json: JSON.stringify(edge.attributes)
              }
            };
          }
          if (key === 'sourceId') return 'source-node';
          if (key === 'targetId') return 'target-node';
        })
      };

      mockResult.records = [mockRecord];

      const result = await edgeManager.addEdge(edge);
      expect(result.attributes?.line_number).toBe(42);
      expect(result.attributes?.confidence).toBe(0.95);
    });
  });

  describe('updateEdge', () => {
    test('should update edge successfully', async () => {
      const updates = {
        attributes: { weight: 2.0 }
      };

      const mockRecord = {
        get: jest.fn().mockImplementation((key: string) => {
          if (key === 'r') {
            return {
              properties: {
                id: 'test-edge',
                project_id: 'test-project',
                type: 'calls',
                attributes_json: JSON.stringify(updates.attributes)
              }
            };
          }
          if (key === 'sourceId') return 'source-node';
          if (key === 'targetId') return 'target-node';
        })
      };

      mockResult.records = [mockRecord];

      const result = await edgeManager.updateEdge('test-edge', 'test-project', updates);
      expect(result.attributes?.weight).toBe(2.0);
      expect(mockClient.runQuery).toHaveBeenCalled();
    });

    test('should throw error when no valid updates provided', async () => {
      await expect(edgeManager.updateEdge('test-edge', 'test-project', {}))
        .rejects.toThrow('No valid updates provided');
    });

    test('should not allow updating source or target', async () => {
      const updates = {
        source: 'new-source',
        target: 'new-target'
      };

      await expect(edgeManager.updateEdge('test-edge', 'test-project', updates))
        .rejects.toThrow('No valid updates provided');
    });

    test('should throw error when edge not found', async () => {
      mockResult.records = [];
      
      await expect(edgeManager.updateEdge('test-edge', 'test-project', { type: 'calls' }))
        .rejects.toThrow('Edge with id test-edge not found');
    });
  });

  describe('getEdge', () => {
    test('should get edge successfully', async () => {
      const mockRecord = {
        get: jest.fn().mockImplementation((key: string) => {
          if (key === 'r') {
            return {
              properties: {
                id: 'test-edge',
                project_id: 'test-project',
                type: 'implements',
                attributes_json: '{}'
              }
            };
          }
          if (key === 'sourceId') return 'source-node';
          if (key === 'targetId') return 'target-node';
        })
      };

      mockResult.records = [mockRecord];

      const result = await edgeManager.getEdge('test-edge', 'test-project');
      expect(result).not.toBeNull();
      expect(result?.id).toBe('test-edge');
    });

    test('should return null when edge not found', async () => {
      mockResult.records = [];

      const result = await edgeManager.getEdge('non-existent', 'test-project');
      expect(result).toBeNull();
    });
  });

  describe('deleteEdge', () => {
    test('should delete edge successfully', async () => {
      mockResult.records = [{ get: jest.fn().mockReturnValue({ toNumber: () => 1 }) }];

      const result = await edgeManager.deleteEdge('test-edge', 'test-project');
      expect(result).toBe(true);
    });

    test('should return false when edge not found', async () => {
      mockResult.records = [{ get: jest.fn().mockReturnValue({ toNumber: () => 0 }) }];

      const result = await edgeManager.deleteEdge('non-existent', 'test-project');
      expect(result).toBe(false);
    });
  });

  describe('findEdgesByType', () => {
    test('should find edges by type', async () => {
      const mockRecord = {
        get: jest.fn().mockImplementation((key: string) => {
          if (key === 'r') {
            return {
              properties: {
                id: 'test-edge',
                project_id: 'test-project',
                type: 'implements',
                attributes_json: '{}'
              }
            };
          }
          if (key === 'sourceId') return 'source-node';
          if (key === 'targetId') return 'target-node';
        })
      };

      mockResult.records = [mockRecord];

      const result = await edgeManager.findEdgesByType('implements', 'test-project');
      expect(result).toHaveLength(1);
      expect(result[0].type).toBe('implements');
    });
  });

  describe('findEdgesBySource', () => {
    test('should find edges by source', async () => {
      const mockRecord = {
        get: jest.fn().mockImplementation((key: string) => {
          if (key === 'r') {
            return {
              properties: {
                id: 'test-edge',
                project_id: 'test-project',
                type: 'calls',
                attributes_json: '{}'
              }
            };
          }
          if (key === 'sourceId') return 'source-node';
          if (key === 'targetId') return 'target-node';
        })
      };

      mockResult.records = [mockRecord];

      const result = await edgeManager.findEdgesBySource('source-node', 'test-project');
      expect(result).toHaveLength(1);
      expect(result[0].source).toBe('source-node');
    });
  });

  describe('complex queries', () => {
    test('should find classes that call method', async () => {
      mockResult.records = [
        { get: jest.fn().mockReturnValue('TestClass') },
        { get: jest.fn().mockReturnValue('AnotherClass') }
      ];

      const result = await edgeManager.findClassesThatCallMethod('testMethod', 'test-project');
      expect(result).toHaveLength(2);
      expect(result).toContain('TestClass');
      expect(result).toContain('AnotherClass');
    });

    test('should find classes that implement interface', async () => {
      mockResult.records = [
        { get: jest.fn().mockReturnValue('TestClass') }
      ];

      const result = await edgeManager.findClassesThatImplementInterface('TestInterface', 'test-project');
      expect(result).toHaveLength(1);
      expect(result[0]).toBe('TestClass');
    });

    test('should find inheritance hierarchy', async () => {
      mockResult.records = [
        { get: jest.fn().mockReturnValue(['Child', 'Parent', 'GrandParent']) }
      ];

      const result = await edgeManager.findInheritanceHierarchy('Child', 'test-project');
      expect(result).toEqual(['Child', 'Parent', 'GrandParent']);
    });

    test('should return empty array for no inheritance hierarchy', async () => {
      mockResult.records = [];

      const result = await edgeManager.findInheritanceHierarchy('SingleClass', 'test-project');
      expect(result).toEqual([]);
    });
  });

  describe('cross-project methods', () => {
    test('should find edges by type across projects', async () => {
      const mockRecord = {
        get: jest.fn().mockImplementation((key: string) => {
          if (key === 'r') {
            return {
              properties: {
                id: 'test-edge',
                project_id: 'test-project',
                type: 'implements',
                attributes_json: '{}'
              }
            };
          }
          if (key === 'sourceId') return 'source-node';
          if (key === 'targetId') return 'target-node';
        })
      };

      mockResult.records = [mockRecord];

      const result = await edgeManager.findEdgesByTypeAcrossProjects('implements');
      expect(result).toHaveLength(1);
      expect(result[0].type).toBe('implements');
    });

    test('should find cross-project dependencies', async () => {
      const mockRecord = {
        get: jest.fn().mockImplementation((key: string) => {
          if (key === 'r') {
            return {
              properties: {
                id: 'cross-edge',
                project_id: 'project-1',
                type: 'calls',
                attributes_json: '{}'
              }
            };
          }
          if (key === 'sourceId') return 'source-node';
          if (key === 'targetId') return 'target-node';
        })
      };

      mockResult.records = [mockRecord];

      const result = await edgeManager.findCrossProjectDependencies();
      expect(result).toHaveLength(1);
      expect(result[0].id).toBe('cross-edge');
    });
  });

  describe('recordToEdge', () => {
    test('should handle edge with empty attributes', async () => {
      const mockRecord = {
        get: jest.fn().mockImplementation((key: string) => {
          if (key === 'r') {
            return {
              properties: {
                id: 'test-edge',
                project_id: 'test-project',
                type: 'calls',
                attributes_json: null
              }
            };
          }
          if (key === 'sourceId') return 'source-node';
          if (key === 'targetId') return 'target-node';
        })
      };

      mockResult.records = [mockRecord];

      const result = await edgeManager.getEdge('test-edge', 'test-project');
      expect(result?.attributes).toEqual({});
    });
  });
});


================================================
FILE: tests/graph/neo4j-client.test.ts
================================================
// Mock the entire neo4j-driver module
const mockDriver = {
  verifyConnectivity: jest.fn().mockResolvedValue(undefined),
  close: jest.fn().mockResolvedValue(undefined),
  session: jest.fn()
};

const mockSession = {
  run: jest.fn(),
  close: jest.fn().mockResolvedValue(undefined),
  executeWrite: jest.fn().mockImplementation((work) => work({}))
};

const mockResult = {
  records: []
};

const mockNeo4j = {
  driver: jest.fn().mockReturnValue(mockDriver),
  auth: {
    basic: jest.fn().mockReturnValue({})
  }
};

jest.mock('neo4j-driver', () => ({
  __esModule: true,
  default: mockNeo4j
}));

import { Neo4jClient } from '../../src/graph/neo4j-client.js';
import { ProjectContext } from '../../src/types.js';

describe('Neo4jClient', () => {
  let client: Neo4jClient;

  beforeEach(() => {
    // Reset all mocks
    jest.clearAllMocks();
    
    // Set up default mock behaviors
    mockDriver.session.mockReturnValue(mockSession);
    mockSession.run.mockResolvedValue(mockResult);
    mockResult.records = [
      {
        get: jest.fn().mockReturnValue({ properties: { health: 1 } })
      }
    ];

    // Recreate client
    const config = { uri: 'bolt://localhost:7687', user: 'neo4j', password: 'test' };
    client = new Neo4jClient(config);
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('constructor', () => {
    test('should create client with provided config', () => {
      const config = { uri: 'bolt://localhost:7687', user: 'neo4j', password: 'test' };
      const newClient = new Neo4jClient(config);
      expect(newClient).toBeInstanceOf(Neo4jClient);
    });

    test('should create client with default project config', () => {
      const config = { uri: 'bolt://localhost:7687', user: 'neo4j', password: 'test' };
      const newClient = new Neo4jClient(config);
      expect(newClient).toBeInstanceOf(Neo4jClient);
    });
  });

  describe('connect', () => {
    test('should connect successfully', async () => {
      await client.connect();
      expect(mockNeo4j.driver).toHaveBeenCalledWith('bolt://localhost:7687', {});
      expect(mockDriver.verifyConnectivity).toHaveBeenCalled();
    });

    test('should throw error on connection failure', async () => {
      mockDriver.verifyConnectivity.mockRejectedValueOnce(new Error('Connection failed'));
      await expect(client.connect()).rejects.toThrow('Connection failed');
    });
  });

  describe('disconnect', () => {
    test('should disconnect successfully', async () => {
      await client.connect();
      await client.disconnect();
      expect(mockDriver.close).toHaveBeenCalled();
    });

    test('should handle disconnect when not connected', async () => {
      await client.disconnect();
      expect(mockDriver.close).not.toHaveBeenCalled();
    });
  });

  describe('getSession', () => {
    test('should return session when connected', async () => {
      await client.connect();
      const session = client.getSession();
      expect(session).toBe(mockSession);
      expect(mockDriver.session).toHaveBeenCalled();
    });

    test('should throw error when not connected', () => {
      expect(() => client.getSession()).toThrow('Neo4J driver not connected. Call connect() first.');
    });
  });

  describe('runQuery', () => {
    test('should run query successfully', async () => {
      await client.connect();
      const result = await client.runQuery('RETURN 1', {});
      expect(mockSession.run).toHaveBeenCalledWith('RETURN 1', {});
      expect(mockSession.close).toHaveBeenCalled();
      expect(result).toBe(mockResult);
    });

    test('should close session after query', async () => {
      await client.connect();
      await client.runQuery('RETURN 1', {});
      expect(mockSession.close).toHaveBeenCalled();
    });
  });

  describe('runTransaction', () => {
    test('should run transaction successfully', async () => {
      await client.connect();
      const workFunction = jest.fn().mockResolvedValue('result');
      const result = await client.runTransaction(workFunction);
      
      expect(mockSession.executeWrite).toHaveBeenCalledWith(workFunction);
      expect(mockSession.close).toHaveBeenCalled();
      expect(result).toBe('result');
    });
  });

  describe('healthCheck', () => {
    test('should return true for healthy connection', async () => {
      await client.connect();
      const isHealthy = await client.healthCheck();
      expect(isHealthy).toBe(true);
      expect(mockSession.run).toHaveBeenCalledWith('RETURN 1 as health', {});
    });

    test('should return false for unhealthy connection', async () => {
      await client.connect();
      mockSession.run.mockRejectedValueOnce(new Error('Query failed'));
      const isHealthy = await client.healthCheck();
      expect(isHealthy).toBe(false);
    });
  });

  describe('initializeDatabase', () => {
    test('should create constraints and indexes', async () => {
      await client.connect();
      await client.initializeDatabase();
      expect(mockSession.run).toHaveBeenCalledTimes(13); // Number of constraints + indexes
    });
  });

  describe('project management', () => {
    test('should create project successfully', async () => {
      await client.connect();
      const project: ProjectContext = {
        project_id: 'test-project',
        name: 'Test Project',
        description: 'A test project'
      };

      const mockRecord = {
        get: jest.fn().mockReturnValue({
          properties: {
            project_id: 'test-project',
            name: 'Test Project',
            description: 'A test project',
            created_at: { toStandardDate: () => new Date() },
            updated_at: { toStandardDate: () => new Date() }
          }
        })
      };

      mockResult.records = [mockRecord];
      
      const result = await client.createProject(project);
      expect(result.project_id).toBe('test-project');
      expect(result.name).toBe('Test Project');
    });

    test('should get project successfully', async () => {
      await client.connect();
      const mockRecord = {
        get: jest.fn().mockReturnValue({
          properties: {
            project_id: 'test-project',
            name: 'Test Project',
            description: 'A test project',
            created_at: { toStandardDate: () => new Date() },
            updated_at: { toStandardDate: () => new Date() }
          }
        })
      };

      mockResult.records = [mockRecord];
      
      const result = await client.getProject('test-project');
      expect(result).not.toBeNull();
      expect(result?.project_id).toBe('test-project');
    });

    test('should return null for non-existent project', async () => {
      await client.connect();
      mockResult.records = [];
      
      const result = await client.getProject('non-existent');
      expect(result).toBeNull();
    });

    test('should list projects successfully', async () => {
      await client.connect();
      const mockRecord = {
        get: jest.fn().mockReturnValue({
          properties: {
            project_id: 'test-project',
            name: 'Test Project',
            description: 'A test project',
            created_at: { toStandardDate: () => new Date() },
            updated_at: { toStandardDate: () => new Date() }
          }
        })
      };

      mockResult.records = [mockRecord];
      
      const projects = await client.listProjects();
      expect(projects).toHaveLength(1);
      expect(projects[0].project_id).toBe('test-project');
    });

    test('should delete project successfully', async () => {
      await client.connect();
      mockResult.records = [{ get: jest.fn().mockReturnValue(1) }];
      
      const deleted = await client.deleteProject('test-project');
      expect(deleted).toBe(true);
    });
  });

  describe('utility methods', () => {
    test('should generate project label', () => {
      const label = client.getProjectLabel('test-project', 'class');
      expect(label).toBe('Project_test-project_Class');
    });

    test('should generate project scoped ID', () => {
      const scopedId = client.generateProjectScopedId('test-project', 'entity-123');
      expect(scopedId).toBe('test-project:entity-123');
    });

    test('should parse project scoped ID', () => {
      const parsed = client.parseProjectScopedId('test-project:entity-123');
      expect(parsed.projectId).toBe('test-project');
      expect(parsed.entityId).toBe('entity-123');
    });

    test('should parse project scoped ID with colons in entity ID', () => {
      const parsed = client.parseProjectScopedId('test-project:namespace:class:method');
      expect(parsed.projectId).toBe('test-project');
      expect(parsed.entityId).toBe('namespace:class:method');
    });
  });
});


================================================
FILE: tests/graph/node-manager.test.ts
================================================
import { NodeManager } from '../../src/graph/node-manager.js';
import { Neo4jClient } from '../../src/graph/neo4j-client.js';
import { CodeNode } from '../../src/types.js';

// Mock the Neo4jClient
jest.mock('../../src/graph/neo4j-client.js');

describe('NodeManager', () => {
  let nodeManager: NodeManager;
  let mockClient: jest.Mocked<Neo4jClient>;
  let mockResult: any;

  beforeEach(() => {
    mockResult = {
      records: []
    };

    mockClient = {
      runQuery: jest.fn().mockResolvedValue(mockResult),
      getProjectLabel: jest.fn().mockReturnValue('Project_test_Class')
    } as any;

    nodeManager = new NodeManager(mockClient);
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('addNode', () => {
    test('should add node successfully', async () => {
      const node: CodeNode = {
        id: 'test-node',
        project_id: 'test-project',
        type: 'class',
        name: 'TestClass',
        qualified_name: 'com.example.TestClass'
      };

      const mockRecord = {
        get: jest.fn().mockReturnValue({
          properties: {
            id: 'test-node',
            project_id: 'test-project',
            type: 'class',
            name: 'TestClass',
            qualified_name: 'com.example.TestClass',
            description: null,
            source_file: null,
            start_line: null,
            end_line: null,
            modifiers: [],
            attributes_json: '{}'
          }
        })
      };

      mockResult.records = [mockRecord];

      const result = await nodeManager.addNode(node);
      expect(result.id).toBe('test-node');
      expect(result.type).toBe('class');
      expect(mockClient.runQuery).toHaveBeenCalled();
    });

    test('should throw error when node creation fails', async () => {
      const node: CodeNode = {
        id: 'test-node',
        project_id: 'test-project',
        type: 'class',
        name: 'TestClass',
        qualified_name: 'com.example.TestClass'
      };

      mockResult.records = [];

      await expect(nodeManager.addNode(node)).rejects.toThrow('Failed to create node');
    });

    test('should handle node with all optional fields', async () => {
      const node: CodeNode = {
        id: 'test-node',
        project_id: 'test-project',
        type: 'method',
        name: 'testMethod',
        qualified_name: 'com.example.TestClass.testMethod',
        description: 'A test method',
        source_file: 'TestClass.java',
        start_line: 10,
        end_line: 20,
        modifiers: ['public', 'static'],
        attributes: {
          return_type: 'void',
          parameters: []
        }
      };

      const mockRecord = {
        get: jest.fn().mockReturnValue({
          properties: {
            ...node,
            attributes_json: JSON.stringify(node.attributes)
          }
        })
      };

      mockResult.records = [mockRecord];

      const result = await nodeManager.addNode(node);
      expect(result.id).toBe('test-node');
      expect(result.description).toBe('A test method');
      expect(result.modifiers).toEqual(['public', 'static']);
    });
  });

  describe('updateNode', () => {
    test('should update node successfully', async () => {
      const updates = {
        description: 'Updated description',
        modifiers: ['public']
      };

      const mockRecord = {
        get: jest.fn().mockReturnValue({
          properties: {
            id: 'test-node',
            project_id: 'test-project',
            type: 'class',
            name: 'TestClass',
            qualified_name: 'com.example.TestClass',
            description: 'Updated description',
            modifiers: ['public'],
            attributes_json: '{}'
          }
        })
      };

      mockResult.records = [mockRecord];

      const result = await nodeManager.updateNode('test-node', 'test-project', updates);
      expect(result.description).toBe('Updated description');
      expect(mockClient.runQuery).toHaveBeenCalled();
    });

    test('should throw error when no valid updates provided', async () => {
      await expect(nodeManager.updateNode('test-node', 'test-project', {}))
        .rejects.toThrow('No valid updates provided');
    });

    test('should throw error when node not found', async () => {
      mockResult.records = [];
      
      await expect(nodeManager.updateNode('test-node', 'test-project', { description: 'test' }))
        .rejects.toThrow('Node with id test-node not found');
    });
  });

  describe('getNode', () => {
    test('should get node successfully', async () => {
      const mockRecord = {
        get: jest.fn().mockReturnValue({
          properties: {
            id: 'test-node',
            project_id: 'test-project',
            type: 'class',
            name: 'TestClass',
            qualified_name: 'com.example.TestClass',
            attributes_json: '{}'
          }
        })
      };

      mockResult.records = [mockRecord];

      const result = await nodeManager.getNode('test-node', 'test-project');
      expect(result).not.toBeNull();
      expect(result?.id).toBe('test-node');
    });

    test('should return null when node not found', async () => {
      mockResult.records = [];

      const result = await nodeManager.getNode('non-existent', 'test-project');
      expect(result).toBeNull();
    });
  });

  describe('deleteNode', () => {
    test('should delete node successfully', async () => {
      mockResult.records = [{ get: jest.fn().mockReturnValue({ toNumber: () => 1 }) }];

      const result = await nodeManager.deleteNode('test-node', 'test-project');
      expect(result).toBe(true);
    });

    test('should return false when node not found', async () => {
      mockResult.records = [{ get: jest.fn().mockReturnValue({ toNumber: () => 0 }) }];

      const result = await nodeManager.deleteNode('non-existent', 'test-project');
      expect(result).toBe(false);
    });
  });

  describe('findNodesByType', () => {
    test('should find nodes by type', async () => {
      const mockRecord = {
        get: jest.fn().mockReturnValue({
          properties: {
            id: 'test-node',
            project_id: 'test-project',
            type: 'class',
            name: 'TestClass',
            qualified_name: 'com.example.TestClass',
            attributes_json: '{}'
          }
        })
      };

      mockResult.records = [mockRecord];

      const result = await nodeManager.findNodesByType('class', 'test-project');
      expect(result).toHaveLength(1);
      expect(result[0].type).toBe('class');
    });
  });

  describe('findNodesByName', () => {
    test('should find nodes by name', async () => {
      const mockRecord = {
        get: jest.fn().mockReturnValue({
          properties: {
            id: 'test-node',
            project_id: 'test-project',
            type: 'class',
            name: 'TestClass',
            qualified_name: 'com.example.TestClass',
            attributes_json: '{}'
          }
        })
      };

      mockResult.records = [mockRecord];

      const result = await nodeManager.findNodesByName('Test', 'test-project');
      expect(result).toHaveLength(1);
      expect(result[0].name).toBe('TestClass');
    });
  });

  describe('searchNodes', () => {
    test('should search nodes successfully', async () => {
      const mockRecord = {
        get: jest.fn().mockReturnValue({
          properties: {
            id: 'test-node',
            project_id: 'test-project',
            type: 'class',
            name: 'TestClass',
            qualified_name: 'com.example.TestClass',
            attributes_json: '{}'
          }
        })
      };

      mockResult.records = [mockRecord];

      const result = await nodeManager.searchNodes('Test', 'test-project');
      expect(result).toHaveLength(1);
      expect(result[0].name).toBe('TestClass');
    });
  });

  describe('cross-project methods', () => {
    test('should find nodes by type across projects', async () => {
      const mockRecord = {
        get: jest.fn().mockReturnValue({
          properties: {
            id: 'test-node',
            project_id: 'test-project',
            type: 'class',
            name: 'TestClass',
            qualified_name: 'com.example.TestClass',
            attributes_json: '{}'
          }
        })
      };

      mockResult.records = [mockRecord];

      const result = await nodeManager.findNodesByTypeAcrossProjects('class');
      expect(result).toHaveLength(1);
      expect(result[0].type).toBe('class');
    });

    test('should search nodes across projects', async () => {
      const mockRecord = {
        get: jest.fn().mockReturnValue({
          properties: {
            id: 'test-node',
            project_id: 'test-project',
            type: 'class',
            name: 'TestClass',
            qualified_name: 'com.example.TestClass',
            attributes_json: '{}'
          }
        })
      };

      mockResult.records = [mockRecord];

      const result = await nodeManager.searchNodesAcrossProjects('Test');
      expect(result).toHaveLength(1);
      expect(result[0].name).toBe('TestClass');
    });
  });

  describe('recordToNode', () => {
    test('should handle numeric line numbers', async () => {
      const mockRecord = {
        get: jest.fn().mockReturnValue({
          properties: {
            id: 'test-node',
            project_id: 'test-project',
            type: 'class',
            name: 'TestClass',
            qualified_name: 'com.example.TestClass',
            start_line: { toNumber: () => 10 },
            end_line: { toNumber: () => 20 },
            attributes_json: '{}'
          }
        })
      };

      mockResult.records = [mockRecord];

      const result = await nodeManager.getNode('test-node', 'test-project');
      expect(result?.start_line).toBe(10);
      expect(result?.end_line).toBe(20);
    });

    test('should handle plain numeric line numbers', async () => {
      const mockRecord = {
        get: jest.fn().mockReturnValue({
          properties: {
            id: 'test-node',
            project_id: 'test-project',
            type: 'class',
            name: 'TestClass',
            qualified_name: 'com.example.TestClass',
            start_line: 10,
            end_line: 20,
            attributes_json: '{}'
          }
        })
      };

      mockResult.records = [mockRecord];

      const result = await nodeManager.getNode('test-node', 'test-project');
      expect(result?.start_line).toBe(10);
      expect(result?.end_line).toBe(20);
    });
  });
});


================================================
FILE: tests/mcp/base-handler.test.ts
================================================
import { BaseHandler } from '../../src/mcp/base-handler.js';
import { Neo4jClient } from '../../src/graph/neo4j-client.js';
import { Server } from '@modelcontextprotocol/sdk/server/index.js';

// Mock all dependencies
jest.mock('../../src/graph/neo4j-client.js');
jest.mock('@modelcontextprotocol/sdk/server/index.js');

// Create a concrete implementation for testing
class TestHandler extends BaseHandler {
  async start(): Promise<void> {
    // Test implementation
  }
}

describe('BaseHandler', () => {
  let handler: TestHandler;
  let mockClient: jest.Mocked<Neo4jClient>;
  let mockServer: jest.Mocked<Server>;

  beforeEach(() => {
    // Mock the Server class
    mockServer = {
      setRequestHandler: jest.fn(),
      connect: jest.fn(),
      close: jest.fn()
    } as any;

    (Server as jest.MockedClass<typeof Server>).mockImplementation(() => mockServer);

    mockClient = {
      runQuery: jest.fn(),
      getProjectLabel: jest.fn().mockReturnValue('Project_test_Class')
    } as any;

    handler = new TestHandler(mockClient, 'test-server', '1.0.0', 'detailed');
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('constructor', () => {
    test('should create handler with provided parameters', () => {
      expect(Server).toHaveBeenCalledWith(
        {
          name: 'test-server',
          version: '1.0.0'
        },
        {
          capabilities: {
            tools: {},
            prompts: {}
          }
        }
      );
      expect(handler).toBeInstanceOf(BaseHandler);
    });

    test('should create handler with default parameters', () => {
      const defaultHandler = new TestHandler(mockClient);
      expect(Server).toHaveBeenCalledWith(
        {
          name: 'coderag-mcp-server',
          version: '1.0.0'
        },
        {
          capabilities: {
            tools: {},
            prompts: {}
          }
        }
      );
    });
  });

  describe('setupToolHandlers', () => {
    test('should register list tools handler', () => {
      expect(mockServer.setRequestHandler).toHaveBeenCalledWith(
        expect.any(Object), // ListToolsRequestSchema
        expect.any(Function)
      );
    });

    test('should register call tool handler', () => {
      expect(mockServer.setRequestHandler).toHaveBeenCalledWith(
        expect.any(Object), // CallToolRequestSchema
        expect.any(Function)
      );
    });
  });

  describe('setupPromptHandlers', () => {
    test('should register list prompts handler', () => {
      expect(mockServer.setRequestHandler).toHaveBeenCalledWith(
        expect.any(Object), // ListPromptsRequestSchema
        expect.any(Function)
      );
    });

    test('should register get prompt handler', () => {
      expect(mockServer.setRequestHandler).toHaveBeenCalledWith(
        expect.any(Object), // GetPromptRequestSchema
        expect.any(Function)
      );
    });
  });

  describe('getToolSchemas', () => {
    test('should return comprehensive tool schemas', () => {
      const schemas = (handler as any).getToolSchemas();
      
      expect(schemas).toBeInstanceOf(Array);
      expect(schemas.length).toBeGreaterThan(0);
      
      // Check for key tools
      const toolNames = schemas.map((s: any) => s.name);
      expect(toolNames).toContain('add_node');
      expect(toolNames).toContain('add_edge');
      expect(toolNames).toContain('search_nodes');
      expect(toolNames).toContain('calculate_ck_metrics');
      expect(toolNames).toContain('scan_dir');
      expect(toolNames).toContain('list_projects');
    });

    test('should have proper schema structure', () => {
      const schemas = (handler as any).getToolSchemas();
      const addNodeSchema = schemas.find((s: any) => s.name === 'add_node');
      
      expect(addNodeSchema).toBeDefined();
      expect(addNodeSchema.description).toBeDefined();
      expect(addNodeSchema.inputSchema).toBeDefined();
      expect(addNodeSchema.inputSchema.type).toBe('object');
      expect(addNodeSchema.inputSchema.properties).toBeDefined();
      expect(addNodeSchema.inputSchema.required).toBeInstanceOf(Array);
    });
  });

  describe('prompt methods', () => {
    test('should generate analyze codebase prompt', async () => {
      const prompt = await (handler as any).getAnalyzeCodebasePrompt({ project_type: 'java' });
      
      expect(prompt.description).toContain('java');
      expect(prompt.messages).toBeInstanceOf(Array);
      expect(prompt.messages[0].role).toBe('user');
      expect(prompt.messages[0].content.type).toBe('text');
      expect(prompt.messages[0].content.text).toContain('java');
    });

    test('should generate setup code graph prompt', async () => {
      const prompt = await (handler as any).getSetupCodeGraphPrompt({ language: 'typescript' });
      
      expect(prompt.description).toContain('typescript');
      expect(prompt.messages[0].content.text).toContain('typescript');
    });

    test('should generate find dependencies prompt', async () => {
      const prompt = await (handler as any).getFindDependenciesPrompt({ target_class: 'TestClass' });
      
      expect(prompt.description).toContain('TestClass');
      expect(prompt.messages[0].content.text).toContain('TestClass');
    });

    test('should generate analyze inheritance prompt', async () => {
      const prompt = await (handler as any).getAnalyzeInheritancePrompt({ class_or_interface: 'BaseClass' });
      
      expect(prompt.description).toContain('BaseClass');
      expect(prompt.messages[0].content.text).toContain('BaseClass');
    });
  });

  describe('detail level handling', () => {
    test('should generate detailed prompts for detailed level', () => {
      const detailedHandler = new TestHandler(mockClient, 'test', '1.0.0', 'detailed');
      const prompt = (detailedHandler as any).getDetailedAnalysisPrompt('java');
      
      expect(prompt).toContain('## 1. First, explore');
      expect(prompt).toContain('## 2. Understand');
    });

    test('should generate simple prompts for simple level', () => {
      const simpleHandler = new TestHandler(mockClient, 'test', '1.0.0', 'simple');
      const prompt = (simpleHandler as any).getSimpleAnalysisPrompt('java');
      
      expect(prompt).toContain('Quick java analysis');
      expect(prompt.length).toBeLessThan(300); // Should be concise
    });
  });

  describe('tool handler delegation', () => {
    test('should delegate to node management tools', async () => {
      const mockNodeManager = {
        addNode: jest.fn().mockResolvedValue({ id: 'test' }),
        getNode: jest.fn().mockResolvedValue({ id: 'test' })
      };
      
      (handler as any).nodeManager = mockNodeManager;
      
      // Test delegation exists (actual implementation tested in specific tool tests)
      expect((handler as any).handleAddNode).toBeInstanceOf(Function);
      expect((handler as any).handleGetNode).toBeInstanceOf(Function);
    });

    test('should delegate to edge management tools', async () => {
      const mockEdgeManager = {
        addEdge: jest.fn().mockResolvedValue({ id: 'test' }),
        getEdge: jest.fn().mockResolvedValue({ id: 'test' })
      };
      
      (handler as any).edgeManager = mockEdgeManager;
      
      expect((handler as any).handleAddEdge).toBeInstanceOf(Function);
      expect((handler as any).handleGetEdge).toBeInstanceOf(Function);
    });

    test('should delegate to metrics tools', async () => {
      const mockMetricsManager = {
        calculateCKMetrics: jest.fn().mockResolvedValue({ wmc: 5 }),
        findArchitecturalIssues: jest.fn().mockResolvedValue([])
      };
      
      (handler as any).metricsManager = mockMetricsManager;
      
      expect((handler as any).handleCalculateCKMetrics).toBeInstanceOf(Function);
      expect((handler as any).handleFindArchitecturalIssues).toBeInstanceOf(Function);
    });
  });

  describe('error handling', () => {
    test('should handle tool execution errors', async () => {
      // This would need to be tested with actual tool call handlers
      // The error handling is in the CallToolRequestSchema handler
      expect(mockServer.setRequestHandler).toHaveBeenCalled();
    });
  });
});


================================================
FILE: tests/mcp/tools/analyze-testing-annotations.test.ts
================================================
import { Neo4jClient } from '../../../src/graph/neo4j-client.js';
import { analyzeTestingAnnotations, findUntestableCode } from '../../../src/mcp/tools/analyze-testing-annotations.js';

// Mock the Neo4jClient
jest.mock('../../../src/graph/neo4j-client.js');

describe('Analyze Testing Annotations Tools', () => {
  let mockNeo4jClient: jest.Mocked<Neo4jClient>;

  beforeEach(() => {
    mockNeo4jClient = {
      runQuery: jest.fn()
    } as any;
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('analyzeTestingAnnotations', () => {
    test('should analyze testing annotations without framework filter', async () => {
      const mockMainResult = {
        records: [
          {
            get: jest.fn()
              .mockReturnValueOnce('com.example.TestClass.testMethod')
              .mockReturnValueOnce('method')
              .mockReturnValueOnce('TestClass.java')
              .mockReturnValueOnce([
                { name: '@Test', category: 'testing', framework: 'JUnit' },
                { name: '@BeforeEach', category: 'testing', framework: 'JUnit' }
              ])
              .mockReturnValueOnce(2)
          },
          {
            get: jest.fn()
              .mockReturnValueOnce('com.example.AnotherTestClass.anotherTest')
              .mockReturnValueOnce('method')
              .mockReturnValueOnce('AnotherTestClass.java')
              .mockReturnValueOnce([
                { name: '@Test', category: 'testing', framework: 'JUnit' }
              ])
              .mockReturnValueOnce(1)
          }
        ]
      };

      const mockFrameworkResult = {
        records: [
          {
            get: jest.fn()
              .mockReturnValueOnce('JUnit')
              .mockReturnValueOnce([
                { name: '@Test', count: 2 },
                { name: '@BeforeEach', count: 1 }
              ])
              .mockReturnValueOnce(3)
          }
        ]
      };

      mockNeo4jClient.runQuery
        .mockResolvedValueOnce(mockMainResult)
        .mockResolvedValueOnce(mockFrameworkResult);

      const params = {
        project: 'test-project'
      };

      const result = await analyzeTestingAnnotations(mockNeo4jClient, params);

      expect(mockNeo4jClient.runQuery).toHaveBeenCalledTimes(2);
      expect(result.test_entities).toHaveLength(2);
      expect(result.test_entities[0].test_entity).toBe('com.example.TestClass.testMethod');
      expect(result.test_entities[0].annotation_count).toBe(2);
      expect(result.framework_statistics).toHaveLength(1);
      expect(result.framework_statistics[0].framework).toBe('JUnit');
      expect(result.framework_statistics[0].total_usage).toBe(3);
      expect(result.coverage_analysis).toBeNull();
      expect(result.summary.total_test_entities).toBe(2);
      expect(result.summary.frameworks_used).toBe(1);
      expect(result.summary.total_testing_annotations).toBe(3);
    });

    test('should analyze testing annotations with framework filter', async () => {
      const mockMainResult = {
        records: [
          {
            get: jest.fn()
              .mockReturnValueOnce('com.example.TestClass.testMethod')
              .mockReturnValueOnce('method')
              .mockReturnValueOnce('TestClass.java')
              .mockReturnValueOnce([
                { name: '@Test', category: 'testing', framework: 'JUnit' }
              ])
              .mockReturnValueOnce(1)
          }
        ]
      };

      const mockFrameworkResult = {
        records: [
          {
            get: jest.fn()
              .mockReturnValueOnce('JUnit')
              .mockReturnValueOnce([
                { name: '@Test', count: 1 }
              ])
              .mockReturnValueOnce(1)
          }
        ]
      };

      mockNeo4jClient.runQuery
        .mockResolvedValueOnce(mockMainResult)
        .mockResolvedValueOnce(mockFrameworkResult);

      const params = {
        project: 'test-project',
        framework: 'JUnit'
      };

      const result = await analyzeTestingAnnotations(mockNeo4jClient, params);

      expect(mockNeo4jClient.runQuery).toHaveBeenCalledWith(
        expect.stringContaining('AND annotation.framework = $framework'),
        { project: 'test-project', framework: 'JUnit' }
      );
      expect(result.test_entities).toHaveLength(1);
      expect(result.framework_statistics[0].framework).toBe('JUnit');
    });

    test('should include coverage analysis when requested', async () => {
      const mockMainResult = {
        records: [
          {
            get: jest.fn()
              .mockReturnValueOnce('com.example.TestClass.testMethod')
              .mockReturnValueOnce('method')
              .mockReturnValueOnce('TestClass.java')
              .mockReturnValueOnce([
                { name: '@Test', category: 'testing', framework: 'JUnit' }
              ])
              .mockReturnValueOnce(1)
          }
        ]
      };

      const mockFrameworkResult = {
        records: [
          {
            get: jest.fn()
              .mockReturnValueOnce('JUnit')
              .mockReturnValueOnce([
                { name: '@Test', count: 1 }
              ])
              .mockReturnValueOnce(1)
          }
        ]
      };

      const mockCoverageResult = {
        records: [
          {
            get: jest.fn()
              .mockReturnValueOnce(10)
              .mockReturnValueOnce(7)
              .mockReturnValueOnce(3)
              .mockReturnValueOnce(70)
          }
        ]
      };

      mockNeo4jClient.runQuery
        .mockResolvedValueOnce(mockMainResult)
        .mockResolvedValueOnce(mockFrameworkResult)
        .mockResolvedValueOnce(mockCoverageResult);

      const params = {
        project: 'test-project',
        include_coverage_analysis: true
      };

      const result = await analyzeTestingAnnotations(mockNeo4jClient, params);

      expect(mockNeo4jClient.runQuery).toHaveBeenCalledTimes(3);
      expect(result.coverage_analysis).not.toBeNull();
      expect(result.coverage_analysis!.total_methods).toBe(10);
      expect(result.coverage_analysis!.methods_with_tests).toBe(7);
      expect(result.coverage_analysis!.methods_without_tests).toBe(3);
      expect(result.coverage_analysis!.coverage_percentage).toBe(70);
    });

    test('should handle empty results', async () => {
      const mockMainResult = { records: [] };
      const mockFrameworkResult = { records: [] };

      mockNeo4jClient.runQuery
        .mockResolvedValueOnce(mockMainResult)
        .mockResolvedValueOnce(mockFrameworkResult);

      const params = {
        project: 'empty-project'
      };

      const result = await analyzeTestingAnnotations(mockNeo4jClient, params);

      expect(result.test_entities).toHaveLength(0);
      expect(result.framework_statistics).toHaveLength(0);
      expect(result.summary.total_test_entities).toBe(0);
      expect(result.summary.frameworks_used).toBe(0);
      expect(result.summary.total_testing_annotations).toBe(0);
    });

    test('should handle null records', async () => {
      const mockMainResult = { records: null };
      const mockFrameworkResult = { records: null };

      mockNeo4jClient.runQuery
        .mockResolvedValueOnce(mockMainResult)
        .mockResolvedValueOnce(mockFrameworkResult);

      const params = {
        project: 'null-project'
      };

      const result = await analyzeTestingAnnotations(mockNeo4jClient, params);

      expect(result.test_entities).toHaveLength(0);
      expect(result.framework_statistics).toHaveLength(0);
      expect(result.summary.total_test_entities).toBe(0);
      expect(result.summary.frameworks_used).toBe(0);
      expect(result.summary.total_testing_annotations).toBe(0);
    });

    test('should handle coverage analysis with no records', async () => {
      const mockMainResult = { records: [] };
      const mockFrameworkResult = { records: [] };
      const mockCoverageResult = { records: [] };

      mockNeo4jClient.runQuery
        .mockResolvedValueOnce(mockMainResult)
        .mockResolvedValueOnce(mockFrameworkResult)
        .mockResolvedValueOnce(mockCoverageResult);

      const params = {
        project: 'empty-project',
        include_coverage_analysis: true
      };

      const result = await analyzeTestingAnnotations(mockNeo4jClient, params);

      expect(result.coverage_analysis).toBeNull();
    });

    test('should propagate database errors', async () => {
      mockNeo4jClient.runQuery.mockRejectedValue(new Error('Database connection failed'));

      const params = {
        project: 'test-project'
      };

      await expect(analyzeTestingAnnotations(mockNeo4jClient, params)).rejects.toThrow('Database connection failed');
    });
  });

  describe('findUntestableCode', () => {
    test('should find untestable code patterns', async () => {
      const mockRecords = [
        {
          get: jest.fn((field) => {
            switch (field) {
              case 'testability_concern': return 'private';
              case 'methods': return [
                {
                  qualified_name: 'com.example.Class.privateMethod',
                  type: 'method',
                  source_file: 'Class.java',
                  parameter_count: 2
                },
                {
                  qualified_name: 'com.example.Class.anotherPrivateMethod',
                  type: 'method',
                  source_file: 'Class.java',
                  parameter_count: 1
                }
              ];
              case 'count': return 2;
              default: return null;
            }
          })
        },
        {
          get: jest.fn((field) => {
            switch (field) {
              case 'testability_concern': return 'too_many_parameters';
              case 'methods': return [
                {
                  qualified_name: 'com.example.Class.complexMethod',
                  type: 'method',
                  source_file: 'Class.java',
                  parameter_count: 15
                }
              ];
              case 'count': return 1;
              default: return null;
            }
          })
        }
      ];

      // Add reduce method to mock records array
      (mockRecords as any).reduce = jest.fn((callback: any, initial: number) => {
        let sum = initial;
        for (const record of mockRecords) {
          sum = callback(sum, record);
        }
        return sum;
      });

      const mockResult = {
        records: mockRecords
      };

      mockNeo4jClient.runQuery.mockResolvedValue(mockResult);

      const params = {
        project: 'test-project'
      };

      const result = await findUntestableCode(mockNeo4jClient, params);

      expect(mockNeo4jClient.runQuery).toHaveBeenCalledWith(
        expect.stringContaining('WHERE n.project_id = $project'),
        { project: 'test-project' }
      );
      expect(result.testability_issues).toHaveLength(2);
      expect(result.testability_issues[0].concern).toBe('private');
      expect(result.testability_issues[0].methods).toHaveLength(2);
      expect(result.testability_issues[0].count).toBe(2);
      expect(result.testability_issues[1].concern).toBe('too_many_parameters');
      expect(result.testability_issues[1].methods).toHaveLength(1);
      expect(result.testability_issues[1].count).toBe(1);
      expect(result.total_concerning_methods).toBe(3);
    });

    test('should handle no untestable code found', async () => {
      const mockResult = { records: [] };

      mockNeo4jClient.runQuery.mockResolvedValue(mockResult);

      const params = {
        project: 'clean-project'
      };

      const result = await findUntestableCode(mockNeo4jClient, params);

      expect(result.testability_issues).toHaveLength(0);
      expect(result.total_concerning_methods).toBe(0);
    });

    test('should handle null records', async () => {
      const mockResult = { records: null };

      mockNeo4jClient.runQuery.mockResolvedValue(mockResult);

      const params = {
        project: 'null-project'
      };

      const result = await findUntestableCode(mockNeo4jClient, params);

      expect(result.testability_issues).toHaveLength(0);
      expect(result.total_concerning_methods).toBe(0);
    });

    test('should propagate database errors', async () => {
      mockNeo4jClient.runQuery.mockRejectedValue(new Error('Neo4j connection timeout'));

      const params = {
        project: 'test-project'
      };

      await expect(findUntestableCode(mockNeo4jClient, params)).rejects.toThrow('Neo4j connection timeout');
    });
  });
});


================================================
FILE: tests/mcp/tools/find-deprecated-code.test.ts
================================================
import { Neo4jClient } from '../../../src/graph/neo4j-client.js';
import { findDeprecatedCode, findUsageOfDeprecatedCode } from '../../../src/mcp/tools/find-deprecated-code.js';

// Mock the Neo4jClient
jest.mock('../../../src/graph/neo4j-client.js');

describe('Find Deprecated Code Tools', () => {
  let mockNeo4jClient: jest.Mocked<Neo4jClient>;

  beforeEach(() => {
    mockNeo4jClient = {
      runQuery: jest.fn()
    } as any;
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('findDeprecatedCode', () => {
    test('should find deprecated code without dependencies', async () => {
      const mockResult = {
        records: [
          {
            get: jest.fn((field) => {
              if (field === 'n') {
                return {
                  properties: {
                    id: 'deprecated-class',
                    type: 'class',
                    name: 'DeprecatedClass',
                    qualified_name: 'com.example.DeprecatedClass',
                    source_file: 'DeprecatedClass.java'
                  }
                };
              }
              if (field === 'deprecation_annotation') {
                return {
                  name: '@Deprecated',
                  category: 'deprecation',
                  message: 'Use NewClass instead'
                };
              }
              return null;
            })
          },
          {
            get: jest.fn((field) => {
              if (field === 'n') {
                return {
                  properties: {
                    id: 'deprecated-method',
                    type: 'method',
                    name: 'oldMethod',
                    qualified_name: 'com.example.SomeClass.oldMethod',
                    source_file: 'SomeClass.java'
                  }
                };
              }
              if (field === 'deprecation_annotation') {
                return {
                  name: '@deprecated',
                  category: 'deprecation',
                  message: 'Use newMethod instead'
                };
              }
              return null;
            })
          }
        ]
      };

      mockNeo4jClient.runQuery.mockResolvedValue(mockResult);

      const result = await findDeprecatedCode(mockNeo4jClient);

      expect(mockNeo4jClient.runQuery).toHaveBeenCalledWith(
        expect.stringContaining('WHERE n.attributes IS NOT NULL'),
        {}
      );
      expect(result.deprecated_nodes).toHaveLength(2);
      expect(result.deprecated_nodes[0].name).toBe('DeprecatedClass');
      expect(result.deprecated_nodes[0].deprecation_info.message).toBe('Use NewClass instead');
      expect(result.deprecated_nodes[1].name).toBe('oldMethod');
      expect(result.deprecated_nodes[1].deprecation_info.message).toBe('Use newMethod instead');
      expect(result.total_count).toBe(2);
    });

    test('should find deprecated code with node type filter', async () => {
      const mockResult = {
        records: [
          {
            get: jest.fn((field) => {
              if (field === 'n') {
                return {
                  properties: {
                    id: 'deprecated-class',
                    type: 'class',
                    name: 'DeprecatedClass',
                    qualified_name: 'com.example.DeprecatedClass'
                  }
                };
              }
              if (field === 'deprecation_annotation') {
                return {
                  name: '@Deprecated',
                  category: 'deprecation'
                };
              }
              return null;
            })
          }
        ]
      };

      mockNeo4jClient.runQuery.mockResolvedValue(mockResult);

      const params = {
        node_type: 'class' as const
      };

      const result = await findDeprecatedCode(mockNeo4jClient, params);

      expect(mockNeo4jClient.runQuery).toHaveBeenCalledWith(
        expect.stringContaining('AND n.type = $node_type'),
        { node_type: 'class' }
      );
      expect(result.deprecated_nodes).toHaveLength(1);
      expect(result.deprecated_nodes[0].type).toBe('class');
    });

    test('should find deprecated code with dependencies', async () => {
      const mockResult = {
        records: [
          {
            get: jest.fn((field) => {
              if (field === 'n') {
                return {
                  properties: {
                    id: 'deprecated-class',
                    type: 'class',
                    name: 'DeprecatedClass',
                    qualified_name: 'com.example.DeprecatedClass'
                  }
                };
              }
              if (field === 'deprecation_annotation') {
                return {
                  name: '@Deprecated',
                  category: 'deprecation'
                };
              }
              if (field === 'dependencies') {
                return [
                  {
                    node: 'com.example.ClientClass',
                    relationship: 'extends',
                    type: 'class'
                  },
                  {
                    node: 'com.example.AnotherClass.method',
                    relationship: 'calls',
                    type: 'method'
                  }
                ];
              }
              if (field === 'dependency_count') {
                return 2;
              }
              return null;
            })
          }
        ]
      };

      mockNeo4jClient.runQuery.mockResolvedValue(mockResult);

      const params = {
        include_dependencies: true
      };

      const result = await findDeprecatedCode(mockNeo4jClient, params);

      expect(mockNeo4jClient.runQuery).toHaveBeenCalledWith(
        expect.stringContaining('OPTIONAL MATCH (n)<-[r:calls|references|extends|implements]-(dependentNode)'),
        {}
      );
      expect(result.deprecated_nodes).toHaveLength(1);
      expect(result.deprecated_nodes[0].dependencies).toHaveLength(2);
      expect(result.deprecated_nodes[0].dependency_count).toBe(2);
      expect(result.deprecated_nodes[0].dependencies[0].node).toBe('com.example.ClientClass');
      expect(result.deprecated_nodes[0].dependencies[0].relationship).toBe('extends');
    });

    test('should handle empty results', async () => {
      const mockResult = { records: [] };

      mockNeo4jClient.runQuery.mockResolvedValue(mockResult);

      const result = await findDeprecatedCode(mockNeo4jClient);

      expect(result.deprecated_nodes).toHaveLength(0);
      expect(result.total_count).toBe(0);
    });

    test('should handle null records', async () => {
      const mockResult = { records: null };

      mockNeo4jClient.runQuery.mockResolvedValue(mockResult);

      const result = await findDeprecatedCode(mockNeo4jClient);

      expect(result.deprecated_nodes).toHaveLength(0);
      expect(result.total_count).toBe(0);
    });

    test('should propagate database errors', async () => {
      mockNeo4jClient.runQuery.mockRejectedValue(new Error('Database connection failed'));

      await expect(findDeprecatedCode(mockNeo4jClient)).rejects.toThrow('Database connection failed');
    });
  });

  describe('findUsageOfDeprecatedCode', () => {
    test('should find usage of deprecated code without details', async () => {
      const mockResult = {
        records: [
          {
            get: jest.fn((field) => {
              if (field === 'deprecated_node') {
                return 'com.example.DeprecatedClass';
              }
              if (field === 'deprecated_type') {
                return 'class';
              }
              if (field === 'usage_count') {
                return 5;
              }
              return null;
            })
          },
          {
            get: jest.fn((field) => {
              if (field === 'deprecated_node') {
                return 'com.example.oldMethod';
              }
              if (field === 'deprecated_type') {
                return 'method';
              }
              if (field === 'usage_count') {
                return 3;
              }
              return null;
            })
          }
        ]
      };

      mockNeo4jClient.runQuery.mockResolvedValue(mockResult);

      const result = await findUsageOfDeprecatedCode(mockNeo4jClient);

      expect(mockNeo4jClient.runQuery).toHaveBeenCalledWith(
        expect.stringContaining('MATCH (deprecated)<-[r:calls|references|extends|implements]-(using)')
      );
      expect(result.deprecated_usage).toHaveLength(2);
      expect(result.deprecated_usage[0].deprecated_node).toBe('com.example.DeprecatedClass');
      expect(result.deprecated_usage[0].usage_count).toBe(5);
      expect(result.deprecated_usage[1].deprecated_node).toBe('com.example.oldMethod');
      expect(result.deprecated_usage[1].usage_count).toBe(3);
      expect(result.total_deprecated_items).toBe(2);
    });

    test('should find usage of deprecated code with details', async () => {
      const mockResult = {
        records: [
          {
            get: jest.fn((field) => {
              if (field === 'deprecated_node') {
                return 'com.example.DeprecatedClass';
              }
              if (field === 'deprecated_type') {
                return 'class';
              }
              if (field === 'usage_count') {
                return 2;
              }
              if (field === 'deprecation_info') {
                return {
                  name: '@Deprecated',
                  message: 'Use NewClass instead'
                };
              }
              if (field === 'usage_details') {
                return [
                  {
                    using_node: 'com.example.ClientClass',
                    using_type: 'class',
                    relationship: 'extends',
                    source_file: 'ClientClass.java'
                  },
                  {
                    using_node: 'com.example.AnotherClass.method',
                    using_type: 'method',
                    relationship: 'references',
                    source_file: 'AnotherClass.java'
                  }
                ];
              }
              return null;
            })
          }
        ]
      };

      mockNeo4jClient.runQuery.mockResolvedValue(mockResult);

      const params = {
        include_usage_details: true
      };

      const result = await findUsageOfDeprecatedCode(mockNeo4jClient, params);

      expect(mockNeo4jClient.runQuery).toHaveBeenCalledWith(
        expect.stringContaining('deprecation_info')
      );
      expect(result.deprecated_usage).toHaveLength(1);
      expect(result.deprecated_usage[0].deprecated_node).toBe('com.example.DeprecatedClass');
      expect(result.deprecated_usage[0].deprecation_info.message).toBe('Use NewClass instead');
      expect(result.deprecated_usage[0].usage_details).toHaveLength(2);
      expect(result.deprecated_usage[0].usage_details[0].using_node).toBe('com.example.ClientClass');
      expect(result.deprecated_usage[0].usage_details[0].relationship).toBe('extends');
    });

    test('should handle empty results', async () => {
      const mockResult = { records: [] };

      mockNeo4jClient.runQuery.mockResolvedValue(mockResult);

      const result = await findUsageOfDeprecatedCode(mockNeo4jClient);

      expect(result.deprecated_usage).toHaveLength(0);
      expect(result.total_deprecated_items).toBe(0);
    });

    test('should handle null records', async () => {
      const mockResult = { records: null };

      mockNeo4jClient.runQuery.mockResolvedValue(mockResult);

      const result = await findUsageOfDeprecatedCode(mockNeo4jClient);

      expect(result.deprecated_usage).toHaveLength(0);
      expect(result.total_deprecated_items).toBe(0);
    });

    test('should propagate database errors', async () => {
      mockNeo4jClient.runQuery.mockRejectedValue(new Error('Neo4j timeout'));

      await expect(findUsageOfDeprecatedCode(mockNeo4jClient)).rejects.toThrow('Neo4j timeout');
    });
  });
});


================================================
FILE: tests/mcp/tools/find-nodes-by-annotation.test.ts
================================================
import { Neo4jClient } from '../../../src/graph/neo4j-client.js';
import { findNodesByAnnotation } from '../../../src/mcp/tools/find-nodes-by-annotation.js';

// Mock the Neo4jClient
jest.mock('../../../src/graph/neo4j-client.js');

describe('Find Nodes By Annotation Tool', () => {
  let mockNeo4jClient: jest.Mocked<Neo4jClient>;

  beforeEach(() => {
    mockNeo4jClient = {
      runQuery: jest.fn()
    } as any;
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('findNodesByAnnotation', () => {
    test('should find nodes by annotation name only', async () => {
      const mockResult = {
        records: [
          {
            get: jest.fn((field) => {
              if (field === 'n') {
                return {
                  properties: {
                    id: 'test-class',
                    type: 'class',
                    name: 'TestClass',
                    qualified_name: 'com.example.TestClass',
                    source_file: 'TestClass.java'
                  }
                };
              }
              if (field === 'matched_annotation') {
                return {
                  name: '@Component',
                  framework: 'Spring',
                  category: 'injection',
                  parameters: { value: 'testService' }
                };
              }
              return null;
            })
          },
          {
            get: jest.fn((field) => {
              if (field === 'n') {
                return {
                  properties: {
                    id: 'another-class',
                    type: 'class',
                    name: 'AnotherClass',
                    qualified_name: 'com.example.AnotherClass',
                    source_file: 'AnotherClass.java'
                  }
                };
              }
              if (field === 'matched_annotation') {
                return {
                  name: '@Component',
                  framework: 'Spring',
                  category: 'injection'
                };
              }
              return null;
            })
          }
        ]
      };

      mockNeo4jClient.runQuery.mockResolvedValue(mockResult);

      const params = {
        annotation_name: '@Component'
      };

      const result = await findNodesByAnnotation(mockNeo4jClient, params);

      expect(mockNeo4jClient.runQuery).toHaveBeenCalledWith(
        expect.stringContaining('WHERE annotation.name = $annotation_name'),
        { annotation_name: '@Component' }
      );
      expect(result.nodes).toHaveLength(2);
      expect(result.nodes[0].name).toBe('TestClass');
      expect(result.nodes[0].matched_annotation.name).toBe('@Component');
      expect(result.nodes[0].matched_annotation.framework).toBe('Spring');
      expect(result.nodes[1].name).toBe('AnotherClass');
      expect(result.total_count).toBe(2);
    });

    test('should find nodes by annotation with framework filter', async () => {
      const mockResult = {
        records: [
          {
            get: jest.fn((field) => {
              if (field === 'n') {
                return {
                  properties: {
                    id: 'spring-component',
                    type: 'class',
                    name: 'SpringComponent',
                    qualified_name: 'com.example.SpringComponent'
                  }
                };
              }
              if (field === 'matched_annotation') {
                return {
                  name: '@Component',
                  framework: 'Spring',
                  category: 'injection'
                };
              }
              return null;
            })
          }
        ]
      };

      mockNeo4jClient.runQuery.mockResolvedValue(mockResult);

      const params = {
        annotation_name: '@Component',
        framework: 'Spring'
      };

      const result = await findNodesByAnnotation(mockNeo4jClient, params);

      expect(mockNeo4jClient.runQuery).toHaveBeenCalledWith(
        expect.stringContaining('AND annotation.framework = $framework'),
        { annotation_name: '@Component', framework: 'Spring' }
      );
      expect(result.nodes).toHaveLength(1);
      expect(result.nodes[0].matched_annotation.framework).toBe('Spring');
    });

    test('should find nodes by annotation with category filter', async () => {
      const mockResult = {
        records: [
          {
            get: jest.fn((field) => {
              if (field === 'n') {
                return {
                  properties: {
                    id: 'test-method',
                    type: 'method',
                    name: 'testMethod',
                    qualified_name: 'com.example.TestClass.testMethod'
                  }
                };
              }
              if (field === 'matched_annotation') {
                return {
                  name: '@Test',
                  framework: 'JUnit',
                  category: 'testing'
                };
              }
              return null;
            })
          }
        ]
      };

      mockNeo4jClient.runQuery.mockResolvedValue(mockResult);

      const params = {
        annotation_name: '@Test',
        category: 'testing'
      };

      const result = await findNodesByAnnotation(mockNeo4jClient, params);

      expect(mockNeo4jClient.runQuery).toHaveBeenCalledWith(
        expect.stringContaining('AND annotation.category = $category'),
        { annotation_name: '@Test', category: 'testing' }
      );
      expect(result.nodes).toHaveLength(1);
      expect(result.nodes[0].matched_annotation.category).toBe('testing');
    });

    test('should find nodes by annotation with node type filter', async () => {
      const mockResult = {
        records: [
          {
            get: jest.fn((field) => {
              if (field === 'n') {
                return {
                  properties: {
                    id: 'test-class',
                    type: 'class',
                    name: 'TestClass',
                    qualified_name: 'com.example.TestClass'
                  }
                };
              }
              if (field === 'matched_annotation') {
                return {
                  name: '@Entity',
                  framework: 'JPA',
                  category: 'persistence'
                };
              }
              return null;
            })
          }
        ]
      };

      mockNeo4jClient.runQuery.mockResolvedValue(mockResult);

      const params = {
        annotation_name: '@Entity',
        node_type: 'class' as const
      };

      const result = await findNodesByAnnotation(mockNeo4jClient, params);

      expect(mockNeo4jClient.runQuery).toHaveBeenCalledWith(
        expect.stringContaining('AND n.type = $node_type'),
        { annotation_name: '@Entity', node_type: 'class' }
      );
      expect(result.nodes).toHaveLength(1);
      expect(result.nodes[0].type).toBe('class');
    });

    test('should find nodes with all filters applied', async () => {
      const mockResult = {
        records: [
          {
            get: jest.fn((field) => {
              if (field === 'n') {
                return {
                  properties: {
                    id: 'rest-controller',
                    type: 'class',
                    name: 'UserController',
                    qualified_name: 'com.example.controller.UserController'
                  }
                };
              }
              if (field === 'matched_annotation') {
                return {
                  name: '@RestController',
                  framework: 'Spring',
                  category: 'web',
                  parameters: { value: '/api/users' }
                };
              }
              return null;
            })
          }
        ]
      };

      mockNeo4jClient.runQuery.mockResolvedValue(mockResult);

      const params = {
        annotation_name: '@RestController',
        framework: 'Spring',
        category: 'web',
        node_type: 'class' as const
      };

      const result = await findNodesByAnnotation(mockNeo4jClient, params);

      expect(mockNeo4jClient.runQuery).toHaveBeenCalledWith(
        expect.stringContaining('AND annotation.framework = $framework'),
        {
          annotation_name: '@RestController',
          framework: 'Spring',
          category: 'web',
          node_type: 'class'
        }
      );
      expect(result.nodes).toHaveLength(1);
      expect(result.nodes[0].name).toBe('UserController');
      expect(result.nodes[0].matched_annotation.name).toBe('@RestController');
      expect(result.nodes[0].matched_annotation.framework).toBe('Spring');
      expect(result.nodes[0].matched_annotation.category).toBe('web');
    });

    test('should handle empty results', async () => {
      const mockResult = { records: [] };

      mockNeo4jClient.runQuery.mockResolvedValue(mockResult);

      const params = {
        annotation_name: '@NonExistentAnnotation'
      };

      const result = await findNodesByAnnotation(mockNeo4jClient, params);

      expect(result.nodes).toHaveLength(0);
      expect(result.total_count).toBe(0);
    });

    test('should handle null records', async () => {
      const mockResult = { records: null };

      mockNeo4jClient.runQuery.mockResolvedValue(mockResult);

      const params = {
        annotation_name: '@TestAnnotation'
      };

      const result = await findNodesByAnnotation(mockNeo4jClient, params);

      expect(result.nodes).toHaveLength(0);
      expect(result.total_count).toBe(0);
    });

    test('should handle annotations with special characters', async () => {
      const mockResult = {
        records: [
          {
            get: jest.fn((field) => {
              if (field === 'n') {
                return {
                  properties: {
                    id: 'python-method',
                    type: 'method',
                    name: 'static_method',
                    qualified_name: 'example.MyClass.static_method'
                  }
                };
              }
              if (field === 'matched_annotation') {
                return {
                  name: 'staticmethod',
                  framework: 'Python',
                  category: 'builtin'
                };
              }
              return null;
            })
          }
        ]
      };

      mockNeo4jClient.runQuery.mockResolvedValue(mockResult);

      const params = {
        annotation_name: 'staticmethod'
      };

      const result = await findNodesByAnnotation(mockNeo4jClient, params);

      expect(result.nodes).toHaveLength(1);
      expect(result.nodes[0].matched_annotation.name).toBe('staticmethod');
    });

    test('should propagate database errors', async () => {
      mockNeo4jClient.runQuery.mockRejectedValue(new Error('Database connection failed'));

      const params = {
        annotation_name: '@Component'
      };

      await expect(findNodesByAnnotation(mockNeo4jClient, params)).rejects.toThrow('Database connection failed');
    });

    test('should handle nodes with complex annotation parameters', async () => {
      const mockResult = {
        records: [
          {
            get: jest.fn((field) => {
              if (field === 'n') {
                return {
                  properties: {
                    id: 'endpoint-method',
                    type: 'method',
                    name: 'getUserById',
                    qualified_name: 'com.example.UserController.getUserById'
                  }
                };
              }
              if (field === 'matched_annotation') {
                return {
                  name: '@GetMapping',
                  framework: 'Spring',
                  category: 'web',
                  parameters: {
                    value: '/users/{id}',
                    produces: 'application/json',
                    headers: ['Accept=application/json']
                  }
                };
              }
              return null;
            })
          }
        ]
      };

      mockNeo4jClient.runQuery.mockResolvedValue(mockResult);

      const params = {
        annotation_name: '@GetMapping'
      };

      const result = await findNodesByAnnotation(mockNeo4jClient, params);

      expect(result.nodes).toHaveLength(1);
      expect(result.nodes[0].matched_annotation.parameters.value).toBe('/users/{id}');
      expect(result.nodes[0].matched_annotation.parameters.produces).toBe('application/json');
    });
  });
});


================================================
FILE: tests/mcp/tools/get-annotation-usage.test.ts
================================================
import { Neo4jClient } from '../../../src/graph/neo4j-client.js';
import { getAnnotationUsage } from '../../../src/mcp/tools/get-annotation-usage.js';

// Mock the Neo4jClient
jest.mock('../../../src/graph/neo4j-client.js');

describe('Get Annotation Usage Tool', () => {
  let mockNeo4jClient: jest.Mocked<Neo4jClient>;

  beforeEach(() => {
    mockNeo4jClient = {
      runQuery: jest.fn()
    } as any;
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('getAnnotationUsage', () => {
    test('should get annotation usage grouped by annotation (default)', async () => {
      const mockResult = {
        records: [
          {
            get: jest.fn((field) => {
              switch (field) {
                case 'annotation_name': return '@Component';
                case 'framework': return 'Spring';
                case 'category': return 'injection';
                case 'annotation_type': return 'class';
                case 'usage_count': return 15;
                case 'node_types': return ['class', 'interface'];
                case 'sample_nodes': return [
                  'com.example.UserService',
                  'com.example.OrderService',
                  'com.example.ProductService'
                ];
                default: return null;
              }
            })
          },
          {
            get: jest.fn((field) => {
              switch (field) {
                case 'annotation_name': return '@Test';
                case 'framework': return 'JUnit';
                case 'category': return 'testing';
                case 'annotation_type': return 'method';
                case 'usage_count': return 12;
                case 'node_types': return ['method'];
                case 'sample_nodes': return [
                  'com.example.UserServiceTest.testCreateUser',
                  'com.example.UserServiceTest.testDeleteUser'
                ];
                default: return null;
              }
            })
          }
        ]
      };

      mockNeo4jClient.runQuery.mockResolvedValue(mockResult);

      const result = await getAnnotationUsage(mockNeo4jClient);

      expect(mockNeo4jClient.runQuery).toHaveBeenCalledWith(
        expect.stringContaining('ORDER BY usage_count DESC'),
        {}
      );
      expect(result.annotations).toHaveLength(2);
      expect(result.annotations[0].annotation_name).toBe('@Component');
      expect(result.annotations[0].framework).toBe('Spring');
      expect(result.annotations[0].usage_count).toBe(15);
      expect(result.annotations[0].sample_nodes).toHaveLength(3);
      expect(result.annotations[1].annotation_name).toBe('@Test');
      expect(result.total_annotations).toBe(2);
    });

    test('should get annotation usage with category filter', async () => {
      const mockResult = {
        records: [
          {
            get: jest.fn((field) => {
              switch (field) {
                case 'annotation_name': return '@Test';
                case 'framework': return 'JUnit';
                case 'category': return 'testing';
                case 'annotation_type': return 'method';
                case 'usage_count': return 8;
                case 'node_types': return ['method'];
                case 'sample_nodes': return ['com.example.test.MyTest.testMethod'];
                default: return null;
              }
            })
          }
        ]
      };

      mockNeo4jClient.runQuery.mockResolvedValue(mockResult);

      const params = {
        category: 'testing'
      };

      const result = await getAnnotationUsage(mockNeo4jClient, params);

      expect(mockNeo4jClient.runQuery).toHaveBeenCalledWith(
        expect.stringContaining('AND annotation.category = $category'),
        { category: 'testing' }
      );
      expect(result.annotations).toHaveLength(1);
      expect(result.annotations[0].category).toBe('testing');
    });

    test('should get annotation usage with framework filter', async () => {
      const mockResult = {
        records: [
          {
            get: jest.fn((field) => {
              switch (field) {
                case 'annotation_name': return '@Autowired';
                case 'framework': return 'Spring';
                case 'category': return 'injection';
                case 'annotation_type': return 'field';
                case 'usage_count': return 5;
                case 'node_types': return ['field'];
                case 'sample_nodes': return ['com.example.UserController.userService'];
                default: return null;
              }
            })
          }
        ]
      };

      mockNeo4jClient.runQuery.mockResolvedValue(mockResult);

      const params = {
        framework: 'Spring'
      };

      const result = await getAnnotationUsage(mockNeo4jClient, params);

      expect(mockNeo4jClient.runQuery).toHaveBeenCalledWith(
        expect.stringContaining('AND annotation.framework = $framework'),
        { framework: 'Spring' }
      );
      expect(result.annotations).toHaveLength(1);
      expect(result.annotations[0].framework).toBe('Spring');
    });

    test('should exclude deprecated annotations when include_deprecated is false', async () => {
      const mockResult = {
        records: [
          {
            get: jest.fn((field) => {
              switch (field) {
                case 'annotation_name': return '@Component';
                case 'framework': return 'Spring';
                case 'category': return 'injection';
                case 'annotation_type': return 'class';
                case 'usage_count': return 3;
                case 'node_types': return ['class'];
                case 'sample_nodes': return ['com.example.ActiveService'];
                default: return null;
              }
            })
          }
        ]
      };

      mockNeo4jClient.runQuery.mockResolvedValue(mockResult);

      const params = {
        include_deprecated: false
      };

      const result = await getAnnotationUsage(mockNeo4jClient, params);

      expect(mockNeo4jClient.runQuery).toHaveBeenCalledWith(
        expect.stringContaining("AND annotation.name <> '@Deprecated'"),
        {}
      );
      expect(result.annotations).toHaveLength(1);
      expect(result.annotations[0].annotation_name).toBe('@Component');
    });

    test('should group by category', async () => {
      const mockResult = {
        records: [
          {
            get: jest.fn((field) => {
              switch (field) {
                case 'category': return 'testing';
                case 'annotations': return [
                  {
                    name: '@Test',
                    framework: 'JUnit',
                    usage_count: 10,
                    node_types: ['method'],
                    sample_nodes: ['com.example.test.MyTest.testMethod']
                  },
                  {
                    name: '@BeforeEach',
                    framework: 'JUnit',
                    usage_count: 5,
                    node_types: ['method'],
                    sample_nodes: ['com.example.test.MyTest.setUp']
                  }
                ];
                case 'total_usage': return 15;
                default: return null;
              }
            })
          },
          {
            get: jest.fn((field) => {
              switch (field) {
                case 'category': return 'injection';
                case 'annotations': return [
                  {
                    name: '@Component',
                    framework: 'Spring',
                    usage_count: 8,
                    node_types: ['class'],
                    sample_nodes: ['com.example.UserService']
                  }
                ];
                case 'total_usage': return 8;
                default: return null;
              }
            })
          }
        ]
      };

      mockNeo4jClient.runQuery.mockResolvedValue(mockResult);

      const params = {
        group_by: 'category' as const
      };

      const result = await getAnnotationUsage(mockNeo4jClient, params);

      expect(mockNeo4jClient.runQuery).toHaveBeenCalledWith(
        expect.stringContaining('WITH annotation.category as grouping_key'),
        {}
      );
      expect(result.groups).toHaveLength(2);
      expect(result.groups[0].category).toBe('testing');
      expect(result.groups[0].total_usage).toBe(15);
      expect(result.groups[0].annotations).toHaveLength(2);
      expect(result.groups[1].category).toBe('injection');
      expect(result.total_groups).toBe(2);
    });

    test('should group by framework', async () => {
      const mockResult = {
        records: [
          {
            get: jest.fn((field) => {
              switch (field) {
                case 'framework': return 'Spring';
                case 'annotations': return [
                  {
                    name: '@Component',
                    category: 'injection',
                    usage_count: 12,
                    node_types: ['class'],
                    sample_nodes: ['com.example.UserService']
                  },
                  {
                    name: '@Autowired',
                    category: 'injection',
                    usage_count: 8,
                    node_types: ['field'],
                    sample_nodes: ['com.example.UserController.userService']
                  }
                ];
                case 'total_usage': return 20;
                default: return null;
              }
            })
          }
        ]
      };

      mockNeo4jClient.runQuery.mockResolvedValue(mockResult);

      const params = {
        group_by: 'framework' as const
      };

      const result = await getAnnotationUsage(mockNeo4jClient, params);

      expect(mockNeo4jClient.runQuery).toHaveBeenCalledWith(
        expect.stringContaining('WITH annotation.framework as grouping_key'),
        {}
      );
      expect(result.groups).toHaveLength(1);
      expect(result.groups[0].framework).toBe('Spring');
      expect(result.groups[0].total_usage).toBe(20);
      expect(result.groups[0].annotations).toHaveLength(2);
    });

    test('should handle empty results', async () => {
      const mockResult = { records: [] };

      mockNeo4jClient.runQuery.mockResolvedValue(mockResult);

      const result = await getAnnotationUsage(mockNeo4jClient);

      expect(result.annotations).toHaveLength(0);
      expect(result.total_annotations).toBe(0);
    });

    test('should handle null records', async () => {
      const mockResult = { records: null };

      mockNeo4jClient.runQuery.mockResolvedValue(mockResult);

      const result = await getAnnotationUsage(mockNeo4jClient);

      expect(result.annotations).toHaveLength(0);
      expect(result.total_annotations).toBe(0);
    });

    test('should handle empty results when grouping', async () => {
      const mockResult = { records: [] };

      mockNeo4jClient.runQuery.mockResolvedValue(mockResult);

      const params = {
        group_by: 'category' as const
      };

      const result = await getAnnotationUsage(mockNeo4jClient, params);

      expect(result.groups).toHaveLength(0);
      expect(result.total_groups).toBe(0);
    });

    test('should handle complex filtering with all parameters', async () => {
      const mockResult = {
        records: [
          {
            get: jest.fn((field) => {
              switch (field) {
                case 'annotation_name': return '@GetMapping';
                case 'framework': return 'Spring';
                case 'category': return 'web';
                case 'annotation_type': return 'method';
                case 'usage_count': return 3;
                case 'node_types': return ['method'];
                case 'sample_nodes': return ['com.example.UserController.getUser'];
                default: return null;
              }
            })
          }
        ]
      };

      mockNeo4jClient.runQuery.mockResolvedValue(mockResult);

      const params = {
        category: 'web',
        framework: 'Spring',
        include_deprecated: false
      };

      const result = await getAnnotationUsage(mockNeo4jClient, params);

      expect(mockNeo4jClient.runQuery).toHaveBeenCalledWith(
        expect.stringContaining('AND annotation.category = $category'),
        { category: 'web', framework: 'Spring' }
      );
      expect(result.annotations).toHaveLength(1);
      expect(result.annotations[0].annotation_name).toBe('@GetMapping');
      expect(result.annotations[0].category).toBe('web');
      expect(result.annotations[0].framework).toBe('Spring');
    });

    test('should propagate database errors', async () => {
      mockNeo4jClient.runQuery.mockRejectedValue(new Error('Database timeout'));

      await expect(getAnnotationUsage(mockNeo4jClient)).rejects.toThrow('Database timeout');
    });

    test('should handle annotations without framework when grouping by framework', async () => {
      const mockResult = {
        records: [
          {
            get: jest.fn((field) => {
              switch (field) {
                case 'framework': return 'JUnit';
                case 'annotations': return [
                  {
                    name: '@Test',
                    category: 'testing',
                    usage_count: 5,
                    node_types: ['method'],
                    sample_nodes: ['test.method']
                  }
                ];
                case 'total_usage': return 5;
                default: return null;
              }
            })
          }
        ]
      };

      mockNeo4jClient.runQuery.mockResolvedValue(mockResult);

      const params = {
        group_by: 'framework' as const
      };

      const result = await getAnnotationUsage(mockNeo4jClient, params);

      expect(mockNeo4jClient.runQuery).toHaveBeenCalledWith(
        expect.stringContaining('WHERE grouping_key IS NOT NULL'),
        {}
      );
      expect(result.groups).toHaveLength(1);
      expect(result.groups[0].framework).toBe('JUnit');
    });
  });
});


================================================
FILE: tests/mcp/tools/get-framework-usage.test.ts
================================================
import { Neo4jClient } from '../../../src/graph/neo4j-client.js';
import { getFrameworkUsage } from '../../../src/mcp/tools/get-framework-usage.js';

// Mock the Neo4jClient
jest.mock('../../../src/graph/neo4j-client.js');

describe('Get Framework Usage Tool', () => {
  let mockNeo4jClient: jest.Mocked<Neo4jClient>;

  beforeEach(() => {
    mockNeo4jClient = {
      runQuery: jest.fn()
    } as any;
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('getFrameworkUsage', () => {
    test('should get framework usage without parameters (default)', async () => {
      const mockResult = {
        records: [
          {
            get: jest.fn((field) => {
              switch (field) {
                case 'framework': return 'Spring';
                case 'total_framework_usage': return 25;
                case 'annotations': return [
                  {
                    name: '@Component',
                    category: 'injection',
                    usage_count: 10,
                    sample_nodes: [
                      'com.example.UserService',
                      'com.example.OrderService',
                      'com.example.ProductService'
                    ]
                  },
                  {
                    name: '@Autowired',
                    category: 'injection',
                    usage_count: 8,
                    sample_nodes: [
                      'com.example.UserController.userService',
                      'com.example.OrderController.orderService'
                    ]
                  },
                  {
                    name: '@RestController',
                    category: 'web',
                    usage_count: 7,
                    sample_nodes: [
                      'com.example.UserController',
                      'com.example.OrderController'
                    ]
                  }
                ];
                default: return null;
              }
            })
          },
          {
            get: jest.fn((field) => {
              switch (field) {
                case 'framework': return 'JUnit';
                case 'total_framework_usage': return 15;
                case 'annotations': return [
                  {
                    name: '@Test',
                    category: 'testing',
                    usage_count: 12,
                    sample_nodes: [
                      'com.example.UserServiceTest.testCreateUser',
                      'com.example.UserServiceTest.testDeleteUser'
                    ]
                  },
                  {
                    name: '@BeforeEach',
                    category: 'testing',
                    usage_count: 3,
                    sample_nodes: [
                      'com.example.UserServiceTest.setUp'
                    ]
                  }
                ];
                default: return null;
              }
            })
          }
        ]
      };

      mockNeo4jClient.runQuery.mockResolvedValue(mockResult);

      const result = await getFrameworkUsage(mockNeo4jClient);

      expect(mockNeo4jClient.runQuery).toHaveBeenCalledWith(
        expect.stringContaining('WHERE annotation.framework IS NOT NULL'),
        { min_usage_count: 1 }
      );
      expect(result.frameworks).toHaveLength(2);
      expect(result.frameworks[0].framework).toBe('Spring');
      expect(result.frameworks[0].total_usage).toBe(25);
      expect(result.frameworks[0].annotations).toHaveLength(3);
      expect(result.frameworks[0].annotations[0].name).toBe('@Component');
      expect(result.frameworks[1].framework).toBe('JUnit');
      expect(result.frameworks[1].total_usage).toBe(15);
      expect(result.total_frameworks).toBe(2);
    });

    test('should get framework usage with parameters included', async () => {
      const mockResult = {
        records: [
          {
            get: jest.fn((field) => {
              switch (field) {
                case 'framework': return 'Spring';
                case 'total_framework_usage': return 5;
                case 'annotations': return [
                  {
                    name: '@GetMapping',
                    category: 'web',
                    usage_count: 3,
                    parameters: {
                      value: '/users/{id}',
                      produces: 'application/json'
                    },
                    sample_nodes: [
                      'com.example.UserController.getUser'
                    ]
                  },
                  {
                    name: '@PostMapping',
                    category: 'web',
                    usage_count: 2,
                    parameters: {
                      value: '/users',
                      consumes: 'application/json'
                    },
                    sample_nodes: [
                      'com.example.UserController.createUser'
                    ]
                  }
                ];
                default: return null;
              }
            })
          }
        ]
      };

      mockNeo4jClient.runQuery.mockResolvedValue(mockResult);

      const params = {
        include_parameters: true
      };

      const result = await getFrameworkUsage(mockNeo4jClient, params);

      expect(mockNeo4jClient.runQuery).toHaveBeenCalledWith(
        expect.stringContaining('annotation.parameters as parameters'),
        { min_usage_count: 1 }
      );
      expect(result.frameworks).toHaveLength(1);
      expect(result.frameworks[0].annotations[0].parameters).toEqual({
        value: '/users/{id}',
        produces: 'application/json'
      });
      expect(result.frameworks[0].annotations[1].parameters).toEqual({
        value: '/users',
        consumes: 'application/json'
      });
    });

    test('should filter by minimum usage count', async () => {
      const mockResult = {
        records: [
          {
            get: jest.fn((field) => {
              switch (field) {
                case 'framework': return 'Spring';
                case 'total_framework_usage': return 15;
                case 'annotations': return [
                  {
                    name: '@Component',
                    category: 'injection',
                    usage_count: 10,
                    sample_nodes: ['com.example.UserService']
                  },
                  {
                    name: '@RestController',
                    category: 'web',
                    usage_count: 5,
                    sample_nodes: ['com.example.UserController']
                  }
                ];
                default: return null;
              }
            })
          }
        ]
      };

      mockNeo4jClient.runQuery.mockResolvedValue(mockResult);

      const params = {
        min_usage_count: 5
      };

      const result = await getFrameworkUsage(mockNeo4jClient, params);

      expect(mockNeo4jClient.runQuery).toHaveBeenCalledWith(
        expect.stringContaining('WHERE usage_count >= $min_usage_count'),
        { min_usage_count: 5 }
      );
      expect(result.frameworks).toHaveLength(1);
      expect(result.frameworks[0].framework).toBe('Spring');
      expect(result.frameworks[0].annotations).toHaveLength(2);
      // Both annotations should have usage_count >= 5
      expect(result.frameworks[0].annotations[0].usage_count).toBeGreaterThanOrEqual(5);
      expect(result.frameworks[0].annotations[1].usage_count).toBeGreaterThanOrEqual(5);
    });

    test('should handle frameworks with many annotations', async () => {
      const mockResult = {
        records: [
          {
            get: jest.fn((field) => {
              switch (field) {
                case 'framework': return 'Spring';
                case 'total_framework_usage': return 50;
                case 'annotations': return [
                  {
                    name: '@Component',
                    category: 'injection',
                    usage_count: 15,
                    sample_nodes: [
                      'com.example.UserService',
                      'com.example.OrderService',
                      'com.example.ProductService',
                      'com.example.PaymentService',
                      'com.example.NotificationService'
                    ]
                  },
                  {
                    name: '@Service',
                    category: 'injection',
                    usage_count: 12,
                    sample_nodes: [
                      'com.example.BusinessService',
                      'com.example.DataService'
                    ]
                  },
                  {
                    name: '@Repository',
                    category: 'persistence',
                    usage_count: 8,
                    sample_nodes: [
                      'com.example.UserRepository',
                      'com.example.OrderRepository'
                    ]
                  }
                ];
                default: return null;
              }
            })
          }
        ]
      };

      mockNeo4jClient.runQuery.mockResolvedValue(mockResult);

      const result = await getFrameworkUsage(mockNeo4jClient);

      expect(result.frameworks).toHaveLength(1);
      expect(result.frameworks[0].annotations).toHaveLength(3);
      expect(result.frameworks[0].annotations[0].sample_nodes).toHaveLength(5);
      expect(result.frameworks[0].total_usage).toBe(50);
    });

    test('should handle combined parameters', async () => {
      const mockResult = {
        records: [
          {
            get: jest.fn((field) => {
              switch (field) {
                case 'framework': return 'Django';
                case 'total_framework_usage': return 8;
                case 'annotations': return [
                  {
                    name: '@login_required',
                    category: 'security',
                    usage_count: 5,
                    parameters: {
                      login_url: '/login/',
                      redirect_field_name: 'next'
                    },
                    sample_nodes: [
                      'myapp.views.dashboard',
                      'myapp.views.profile'
                    ]
                  },
                  {
                    name: '@permission_required',
                    category: 'security',
                    usage_count: 3,
                    parameters: {
                      perm: 'myapp.can_edit',
                      raise_exception: true
                    },
                    sample_nodes: [
                      'myapp.views.edit_user'
                    ]
                  }
                ];
                default: return null;
              }
            })
          }
        ]
      };

      mockNeo4jClient.runQuery.mockResolvedValue(mockResult);

      const params = {
        include_parameters: true,
        min_usage_count: 3
      };

      const result = await getFrameworkUsage(mockNeo4jClient, params);

      expect(mockNeo4jClient.runQuery).toHaveBeenCalledWith(
        expect.stringContaining('annotation.parameters as parameters'),
        { min_usage_count: 3 }
      );
      expect(result.frameworks).toHaveLength(1);
      expect(result.frameworks[0].framework).toBe('Django');
      expect(result.frameworks[0].annotations).toHaveLength(2);
      expect(result.frameworks[0].annotations[0].parameters).toBeDefined();
      expect(result.frameworks[0].annotations[1].parameters).toBeDefined();
    });

    test('should handle empty results', async () => {
      const mockResult = { records: [] };

      mockNeo4jClient.runQuery.mockResolvedValue(mockResult);

      const result = await getFrameworkUsage(mockNeo4jClient);

      expect(result.frameworks).toHaveLength(0);
      expect(result.total_frameworks).toBe(0);
    });

    test('should handle null records', async () => {
      const mockResult = { records: null };

      mockNeo4jClient.runQuery.mockResolvedValue(mockResult);

      const result = await getFrameworkUsage(mockNeo4jClient);

      expect(result.frameworks).toHaveLength(0);
      expect(result.total_frameworks).toBe(0);
    });

    test('should handle high minimum usage count that filters out all results', async () => {
      const mockResult = { records: [] };

      mockNeo4jClient.runQuery.mockResolvedValue(mockResult);

      const params = {
        min_usage_count: 100
      };

      const result = await getFrameworkUsage(mockNeo4jClient, params);

      expect(mockNeo4jClient.runQuery).toHaveBeenCalledWith(
        expect.anything(),
        { min_usage_count: 100 }
      );
      expect(result.frameworks).toHaveLength(0);
      expect(result.total_frameworks).toBe(0);
    });

    test('should handle frameworks with annotations but no category', async () => {
      const mockResult = {
        records: [
          {
            get: jest.fn((field) => {
              switch (field) {
                case 'framework': return 'CustomFramework';
                case 'total_framework_usage': return 3;
                case 'annotations': return [
                  {
                    name: '@CustomAnnotation',
                    category: null,
                    usage_count: 3,
                    sample_nodes: [
                      'com.example.CustomClass'
                    ]
                  }
                ];
                default: return null;
              }
            })
          }
        ]
      };

      mockNeo4jClient.runQuery.mockResolvedValue(mockResult);

      const result = await getFrameworkUsage(mockNeo4jClient);

      expect(result.frameworks).toHaveLength(1);
      expect(result.frameworks[0].annotations[0].category).toBeNull();
    });

    test('should propagate database errors', async () => {
      mockNeo4jClient.runQuery.mockRejectedValue(new Error('Connection timeout'));

      await expect(getFrameworkUsage(mockNeo4jClient)).rejects.toThrow('Connection timeout');
    });

    test('should validate min_usage_count parameter is passed correctly', async () => {
      const mockResult = { records: [] };
      mockNeo4jClient.runQuery.mockResolvedValue(mockResult);

      const params = {
        min_usage_count: 10
      };

      await getFrameworkUsage(mockNeo4jClient, params);

      expect(mockNeo4jClient.runQuery).toHaveBeenCalledWith(
        expect.anything(),
        { min_usage_count: 10 }
      );
    });
  });
});


================================================
FILE: tests/mcp/tools/list-projects-tool.test.ts
================================================
import { Neo4jClient } from '../../../src/graph/neo4j-client.js';
import { listProjects } from '../../../src/mcp/tools/list-projects.js';
import { ProjectContext } from '../../../src/types.js';

// Mock the Neo4jClient
jest.mock('../../../src/graph/neo4j-client.js');

describe('List Projects Tool', () => {
  let mockClient: jest.Mocked<Neo4jClient>;

  beforeEach(() => {
    mockClient = {
      listProjects: jest.fn(),
      runQuery: jest.fn()
    } as jest.Mocked<Neo4jClient>;
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('listProjects', () => {
    test('should list projects without stats', async () => {
      const mockProjects: ProjectContext[] = [
        {
          project_id: 'project1',
          name: 'Project One',
          description: 'First project',
          created_at: new Date('2023-01-01'),
          updated_at: new Date('2023-01-02')
        },
        {
          project_id: 'project2',
          name: 'Project Two',
          description: 'Second project',
          created_at: new Date('2023-01-03'),
          updated_at: new Date('2023-01-04')
        }
      ];

      mockClient.listProjects.mockResolvedValue(mockProjects);

      const result = await listProjects(mockClient, { include_stats: false });

      expect(result.projects).toHaveLength(2);
      expect(result.total_count).toBe(2);
      expect(result.projects[0].name).toBe('Project One');
      expect(result.projects[1].name).toBe('Project Two');
      expect(result.projects[0]).not.toHaveProperty('stats');
    });

    test('should list projects with stats', async () => {
      const mockProjects: ProjectContext[] = [
        {
          project_id: 'project1',
          name: 'Project One',
          description: 'First project',
          created_at: new Date('2023-01-01'),
          updated_at: new Date('2023-01-02')
        }
      ];

      mockClient.listProjects.mockResolvedValue(mockProjects);
      
      // Mock stats query - returns all stats in one record
      const mockRunQuery = mockClient.runQuery as jest.Mock;
      mockRunQuery.mockResolvedValue({
        records: [{
          get: (key: string) => {
            switch (key) {
              case 'entity_count':
                return { toNumber: () => 10 };
              case 'relationship_count':
                return { toNumber: () => 15 };
              case 'entity_types':
                return ['class', 'method', null];
              case 'relationship_types':
                return ['calls', 'implements', null];
              default:
                return null;
            }
          }
        }]
      });

      const result = await listProjects(mockClient, { include_stats: true });

      expect(result.projects).toHaveLength(1);
      expect(result.projects[0]).toHaveProperty('stats');
      expect(result.projects[0].stats).toEqual({
        entity_count: 10,
        relationship_count: 15,
        entity_types: ['class', 'method'],
        relationship_types: ['calls', 'implements']
      });
      expect(result.summary).toBeDefined();
      expect(result.summary?.total_entities).toBe(10);
      expect(result.summary?.total_relationships).toBe(15);
    });

    test('should sort projects by name (default)', async () => {
      const mockProjects: ProjectContext[] = [
        {
          project_id: 'project2',
          name: 'Z Project',
          description: 'Last project',
          created_at: new Date('2023-01-01')
        },
        {
          project_id: 'project1',
          name: 'A Project',
          description: 'First project',
          created_at: new Date('2023-01-02')
        }
      ];

      mockClient.listProjects.mockResolvedValue(mockProjects);

      const result = await listProjects(mockClient, {});

      expect(result.projects[0].name).toBe('A Project');
      expect(result.projects[1].name).toBe('Z Project');
    });

    test('should sort projects by created_at', async () => {
      const mockProjects: ProjectContext[] = [
        {
          project_id: 'project1',
          name: 'New Project',
          created_at: new Date('2023-01-02')
        },
        {
          project_id: 'project2',
          name: 'Old Project',
          created_at: new Date('2023-01-01')
        }
      ];

      mockClient.listProjects.mockResolvedValue(mockProjects);

      const result = await listProjects(mockClient, { sort_by: 'created_at' });

      expect(result.projects[0].name).toBe('New Project');
      expect(result.projects[1].name).toBe('Old Project');
    });

    test('should limit results', async () => {
      const mockProjects: ProjectContext[] = [
        { project_id: 'project1', name: 'Project 1' },
        { project_id: 'project2', name: 'Project 2' },
        { project_id: 'project3', name: 'Project 3' }
      ];

      mockClient.listProjects.mockResolvedValue(mockProjects);

      const result = await listProjects(mockClient, { limit: 2 });

      expect(result.projects).toHaveLength(2);
      expect(result.total_count).toBe(3); // Total available, not limited
    });

    test('should sort projects with stats by entity_count', async () => {
      const mockProjects: ProjectContext[] = [
        { project_id: 'project1', name: 'Small Project' },
        { project_id: 'project2', name: 'Large Project' }
      ];

      mockClient.listProjects.mockResolvedValue(mockProjects);
      
      // Mock stats - project1 has fewer entities than project2
      const mockRunQuery = mockClient.runQuery as jest.Mock;
      mockRunQuery
        .mockResolvedValueOnce({ 
          records: [{ 
            get: (key: string) => {
              if (key === 'entity_count') return { toNumber: () => 5 };
              if (key === 'relationship_count') return { toNumber: () => 10 };
              if (key === 'entity_types') return ['class', 'method'];
              if (key === 'relationship_types') return ['calls', 'contains'];
              return null;
            }
          }] 
        }) // project1 stats
        .mockResolvedValueOnce({ 
          records: [{ 
            get: (key: string) => {
              if (key === 'entity_count') return { toNumber: () => 20 };
              if (key === 'relationship_count') return { toNumber: () => 30 };
              if (key === 'entity_types') return ['class', 'method', 'interface'];
              if (key === 'relationship_types') return ['calls', 'contains', 'implements'];
              return null;
            }
          }] 
        }); // project2 stats

      const result = await listProjects(mockClient, { include_stats: true, sort_by: 'entity_count' });

      expect(result.projects[0].name).toBe('Large Project'); // More entities first, sorted descending
      expect(result.projects[1].name).toBe('Small Project');
    });

    test('should handle empty project list', async () => {
      mockClient.listProjects.mockResolvedValue([]);

      const result = await listProjects(mockClient, {});

      expect(result.projects).toHaveLength(0);
      expect(result.total_count).toBe(0);
    });

    test('should handle errors gracefully', async () => {
      mockClient.listProjects.mockRejectedValue(new Error('Database connection failed'));

      await expect(listProjects(mockClient, {})).rejects.toThrow('Failed to list projects: Database connection failed');
    });

    test('should handle stats query errors gracefully', async () => {
      const mockProjects: ProjectContext[] = [
        { project_id: 'project1', name: 'Project One' }
      ];

      mockClient.listProjects.mockResolvedValue(mockProjects);
      (mockClient.runQuery as jest.Mock).mockRejectedValue(new Error('Stats query failed'));

      await expect(listProjects(mockClient, { include_stats: true })).rejects.toThrow('Failed to list projects: Stats query failed');
    });

    test('should use default parameters', async () => {
      const mockProjects: ProjectContext[] = [
        { project_id: 'project1', name: 'Project One' }
      ];

      mockClient.listProjects.mockResolvedValue(mockProjects);

      const result = await listProjects(mockClient);

      expect(result.projects).toHaveLength(1);
      expect(result.total_count).toBe(1);
      expect(result.projects[0]).not.toHaveProperty('stats'); // include_stats defaults to false
    });
  });

  describe('project statistics', () => {
    test('should calculate comprehensive project stats', async () => {
      const mockProjects: ProjectContext[] = [
        { project_id: 'project1', name: 'Test Project' }
      ];

      mockClient.listProjects.mockResolvedValue(mockProjects);
      
      // Mock detailed stats queries
      const mockRunQuery = mockClient.runQuery as jest.Mock;
      mockRunQuery.mockResolvedValueOnce({ 
        records: [{ 
          get: (key: string) => {
            if (key === 'entity_count') return { toNumber: () => 25 };
            if (key === 'relationship_count') return { toNumber: () => 40 };
            if (key === 'entity_types') return ['class', 'method', 'field'];
            if (key === 'relationship_types') return ['calls', 'implements', 'extends'];
            return null;
          }
        }] 
      });

      const result = await listProjects(mockClient, { include_stats: true });

      expect(result.projects[0].stats).toEqual({
        entity_count: 25,
        relationship_count: 40,
        entity_types: ['class', 'method', 'field'],
        relationship_types: ['calls', 'implements', 'extends']
      });
    });
  });
});


================================================
FILE: tests/mcp/tools/mcp-tools-simple.test.ts
================================================
// Simple tests for MCP tools to boost coverage
import { addEdge, getEdge, deleteEdge, findEdgesBySource } from '../../../src/mcp/tools/edge-management.js';
import { findMethodCallers, findImplementations, findInheritanceHierarchy } from '../../../src/mcp/tools/relationship-analysis.js';
import { calculateCKMetrics, calculatePackageMetrics, findArchitecturalIssues, getProjectSummary } from '../../../src/mcp/tools/metrics-analysis.js';

// Mock the managers
const mockEdgeManager = {
  addEdge: jest.fn(),
  getEdge: jest.fn(),
  deleteEdge: jest.fn(),
  findEdgesBySource: jest.fn(),
  findClassesThatCallMethod: jest.fn(),
  findClassesThatImplementInterface: jest.fn(),
  findInheritanceHierarchy: jest.fn()
} as any;

const mockMetricsManager = {
  calculateCKMetrics: jest.fn(),
  calculatePackageMetrics: jest.fn(),
  findArchitecturalIssues: jest.fn(),
  calculateProjectSummary: jest.fn()
} as any;

describe('MCP Tools Simple Tests', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe('Edge Management Tools', () => {
    test('addEdge should handle success', async () => {
      const mockEdge = { id: 'edge1', project_id: 'test', type: 'calls', source: 'src', target: 'tgt' };
      mockEdgeManager.addEdge.mockResolvedValue(mockEdge);

      const result = await addEdge(mockEdgeManager, {
        id: 'edge1',
        project: 'test',
        type: 'calls',
        source: 'src',
        target: 'tgt'
      });

      expect(result.content[0].text).toContain('edge1');
    });

    test('getEdge should handle not found', async () => {
      mockEdgeManager.getEdge.mockResolvedValue(null);

      const result = await getEdge(mockEdgeManager, {
        id: 'missing',
        project: 'test'
      });

      expect(result.content[0].text).toContain('not found');
    });

    test('deleteEdge should handle success', async () => {
      mockEdgeManager.deleteEdge.mockResolvedValue(true);

      const result = await deleteEdge(mockEdgeManager, {
        id: 'edge1',
        project: 'test'
      });

      expect(result.content[0].text).toContain('deleted');
    });

    test('findEdgesBySource should handle empty results', async () => {
      mockEdgeManager.findEdgesBySource.mockResolvedValue([]);

      const result = await findEdgesBySource(mockEdgeManager, {
        project: 'test',
        source_id: 'source1'
      });

      expect(result.content[0].text).toContain('No edges found');
    });
  });

  describe('Relationship Analysis Tools', () => {
    test('findMethodCallers should handle results', async () => {
      mockEdgeManager.findClassesThatCallMethod.mockResolvedValue(['Class1', 'Class2']);

      const result = await findMethodCallers(mockEdgeManager, {
        project: 'test',
        method_name: 'testMethod'
      });

      expect(result.content[0].text).toContain('Class1');
    });

    test('findImplementations should handle empty results', async () => {
      mockEdgeManager.findClassesThatImplementInterface.mockResolvedValue([]);

      const result = await findImplementations(mockEdgeManager, {
        project: 'test',
        interface_name: 'TestInterface'
      });

      expect(result.content[0].text).toContain('No classes found');
    });

    test('findInheritanceHierarchy should handle results', async () => {
      mockEdgeManager.findInheritanceHierarchy.mockResolvedValue(['Child', 'Parent', 'GrandParent']);

      const result = await findInheritanceHierarchy(mockEdgeManager, {
        project: 'test',
        class_name: 'Child'
      });

      expect(result.content[0].text).toContain('Child');
    });
  });

  describe('Metrics Analysis Tools', () => {
    test('calculateCKMetrics should handle detailed results', async () => {
      const mockMetrics = {
        classId: 'class1',
        className: 'TestClass',
        wmc: 10,
        dit: 2,
        noc: 3,
        cbo: 5,
        rfc: 15,
        lcom: 2
      };
      mockMetricsManager.calculateCKMetrics.mockResolvedValue(mockMetrics);

      const result = await calculateCKMetrics(mockMetricsManager, {
        project: 'test',
        class_id: 'class1'
      }, 'detailed');

      expect(result.content[0].text).toContain('TestClass');
      expect(result.content[0].text).toContain('10');
    });

    test('calculateCKMetrics should handle simple results', async () => {
      const mockMetrics = {
        classId: 'class1',
        className: 'TestClass',
        wmc: 10,
        dit: 2,
        noc: 3,
        cbo: 5,
        rfc: 15,
        lcom: 2
      };
      mockMetricsManager.calculateCKMetrics.mockResolvedValue(mockMetrics);

      const result = await calculateCKMetrics(mockMetricsManager, {
        project: 'test',
        class_id: 'class1'
      }, 'simple');

      expect(result.content[0].text).toContain('TestClass');
      // Simple format should be more concise
      expect(result.content[0].text.length).toBeLessThan(250);
    });

    test('calculatePackageMetrics should handle results', async () => {
      const mockMetrics = {
        packageName: 'com.example',
        ca: 3,
        ce: 2,
        instability: 0.4,
        abstractness: 0.3,
        distance: 0.3
      };
      mockMetricsManager.calculatePackageMetrics.mockResolvedValue(mockMetrics);

      const result = await calculatePackageMetrics(mockMetricsManager, {
        project: 'test',
        package_name: 'com.example'
      }, 'detailed');

      expect(result.content[0].text).toContain('com.example');
    });

    test('findArchitecturalIssues should handle results', async () => {
      const mockIssues = [
        {
          type: 'god_class' as const,
          severity: 'high' as const,
          description: 'Large class detected',
          entities: ['BigClass']
        }
      ];
      mockMetricsManager.findArchitecturalIssues.mockResolvedValue(mockIssues);

      const result = await findArchitecturalIssues(mockMetricsManager);

      expect(result.content[0].text).toContain('god_class');
    });

    test('getProjectSummary should handle results', async () => {
      const mockSummary = {
        totalClasses: 50,
        totalMethods: 200,
        totalPackages: 10,
        averageMetrics: {
          avgCBO: 5.5,
          avgRFC: 12.3,
          avgDIT: 1.8
        },
        issueCount: 2
      };
      mockMetricsManager.calculateProjectSummary.mockResolvedValue(mockSummary);

      const result = await getProjectSummary(mockMetricsManager, {
        project: 'test'
      }, 'simple');

      expect(result.content[0].text).toContain('50 classes');
    });
  });
});


================================================
FILE: tests/mcp/tools/node-management-tools.test.ts
================================================
import { NodeManager } from '../../../src/graph/node-manager.js';
import { addNode, updateNode, getNode, deleteNode, findNodesByType, searchNodes } from '../../../src/mcp/tools/node-management.js';
import { CodeNode } from '../../../src/types.js';

// Mock the NodeManager
jest.mock('../../../src/graph/node-manager.js');

describe('Node Management Tools', () => {
  let mockNodeManager: jest.Mocked<NodeManager>;

  beforeEach(() => {
    mockNodeManager = {
      addNode: jest.fn(),
      updateNode: jest.fn(),
      getNode: jest.fn(),
      deleteNode: jest.fn(),
      findNodesByType: jest.fn(),
      searchNodes: jest.fn()
    } as any;
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('addNode', () => {
    test('should add node with all required parameters', async () => {
      const params = {
        id: 'test-node',
        project: 'test-project',
        type: 'class' as const,
        name: 'TestClass',
        qualified_name: 'com.example.TestClass',
        description: 'A test class',
        source_file: 'TestClass.java',
        start_line: 10,
        end_line: 50,
        modifiers: ['public'],
        attributes: { version: '1.0' }
      };

      const expectedNode: CodeNode = {
        id: 'test-node',
        project_id: 'test-project',
        type: 'class',
        name: 'TestClass',
        qualified_name: 'com.example.TestClass',
        description: 'A test class',
        source_file: 'TestClass.java',
        start_line: 10,
        end_line: 50,
        modifiers: ['public'],
        attributes: { version: '1.0' }
      };

      mockNodeManager.addNode.mockResolvedValue(expectedNode);

      const result = await addNode(mockNodeManager, params);

      expect(mockNodeManager.addNode).toHaveBeenCalledWith(expectedNode);
      expect(result.content[0].text).toContain('test-node');
      expect(result.content[0].text).toContain('TestClass');
    });

    test('should add node with minimal required parameters', async () => {
      const params = {
        id: 'minimal-node',
        project: 'test-project',
        type: 'function' as const,
        name: 'testFunction',
        qualified_name: 'testFunction'
      };

      const expectedNode: CodeNode = {
        id: 'minimal-node',
        project_id: 'test-project',
        type: 'function',
        name: 'testFunction',
        qualified_name: 'testFunction'
      };

      mockNodeManager.addNode.mockResolvedValue(expectedNode);

      const result = await addNode(mockNodeManager, params);

      expect(mockNodeManager.addNode).toHaveBeenCalledWith(expectedNode);
      expect(result.content[0].text).toContain('minimal-node');
    });

    test('should handle addNode errors', async () => {
      const params = {
        id: 'error-node',
        project: 'test-project',
        type: 'class' as const,
        name: 'ErrorClass',
        qualified_name: 'com.example.ErrorClass'
      };

      mockNodeManager.addNode.mockRejectedValue(new Error('Database error'));

      const result = await addNode(mockNodeManager, params);

      expect(result.isError).toBe(true);
      expect(result.content[0].text).toContain('Failed to add node');
      expect(result.content[0].text).toContain('Database error');
    });
  });

  describe('updateNode', () => {
    test('should update node successfully', async () => {
      const params = {
        id: 'test-node',
        project: 'test-project',
        updates: {
          description: 'Updated description',
          modifiers: ['public', 'final']
        }
      };

      const updatedNode: CodeNode = {
        id: 'test-node',
        project_id: 'test-project',
        type: 'class',
        name: 'TestClass',
        qualified_name: 'com.example.TestClass',
        description: 'Updated description',
        modifiers: ['public', 'final']
      };

      mockNodeManager.updateNode.mockResolvedValue(updatedNode);

      const result = await updateNode(mockNodeManager, params);

      expect(mockNodeManager.updateNode).toHaveBeenCalledWith(
        'test-node',
        'test-project',
        params.updates
      );
      expect(result.content[0].text).toContain('Updated description');
    });

    test('should handle updateNode errors', async () => {
      const params = {
        id: 'nonexistent-node',
        project: 'test-project',
        updates: { description: 'test' }
      };

      mockNodeManager.updateNode.mockRejectedValue(new Error('Node not found'));

      const result = await updateNode(mockNodeManager, params);

      expect(result.isError).toBe(true);
      expect(result.content[0].text).toContain('Failed to update node');
    });
  });

  describe('getNode', () => {
    test('should get node successfully', async () => {
      const params = {
        nodeId: 'test-node',
        projectId: 'test-project'
      };

      const foundNode: CodeNode = {
        id: 'test-node',
        project_id: 'test-project',
        type: 'class',
        name: 'TestClass',
        qualified_name: 'com.example.TestClass'
      };

      mockNodeManager.getNode.mockResolvedValue(foundNode);

      const result = await getNode(mockNodeManager, params);

      expect(mockNodeManager.getNode).toHaveBeenCalledWith('test-node', 'test-project');
      expect(result.content[0].text).toContain('TestClass');
    });

    test('should handle node not found', async () => {
      const params = {
        nodeId: 'nonexistent-node',
        projectId: 'test-project'
      };

      mockNodeManager.getNode.mockResolvedValue(null);

      const result = await getNode(mockNodeManager, params);

      expect(result.content[0].text).toBe('Node not found');
    });

    test('should handle getNode errors', async () => {
      const params = {
        nodeId: 'error-node',
        projectId: 'test-project'
      };

      mockNodeManager.getNode.mockRejectedValue(new Error('Database error'));

      const result = await getNode(mockNodeManager, params);

      expect(result.isError).toBe(true);
      expect(result.content[0].text).toContain('Failed to get node');
    });
  });

  describe('deleteNode', () => {
    test('should delete node successfully', async () => {
      const params = {
        id: 'test-node',
        project: 'test-project'
      };

      mockNodeManager.deleteNode.mockResolvedValue(true);

      const result = await deleteNode(mockNodeManager, params);

      expect(mockNodeManager.deleteNode).toHaveBeenCalledWith('test-node', 'test-project');
      expect(result.content[0].text).toBe('Node deleted successfully');
    });

    test('should handle node not found for deletion', async () => {
      const params = {
        id: 'nonexistent-node',
        project: 'test-project'
      };

      mockNodeManager.deleteNode.mockResolvedValue(false);

      const result = await deleteNode(mockNodeManager, params);

      expect(result.content[0].text).toBe('Node not found');
    });

    test('should handle deleteNode errors', async () => {
      const params = {
        id: 'error-node',
        project: 'test-project'
      };

      mockNodeManager.deleteNode.mockRejectedValue(new Error('Database error'));

      const result = await deleteNode(mockNodeManager, params);

      expect(result.isError).toBe(true);
      expect(result.content[0].text).toContain('Failed to delete node');
    });
  });

  describe('findNodesByType', () => {
    test('should find nodes by type successfully', async () => {
      const params = {
        nodeType: 'class' as const,
        projectId: 'test-project'
      };

      const foundNodes: CodeNode[] = [
        {
          id: 'class1',
          project_id: 'test-project',
          type: 'class',
          name: 'Class1',
          qualified_name: 'com.example.Class1'
        },
        {
          id: 'class2',
          project_id: 'test-project',
          type: 'class',
          name: 'Class2',
          qualified_name: 'com.example.Class2'
        }
      ];

      mockNodeManager.findNodesByType.mockResolvedValue(foundNodes);

      const result = await findNodesByType(mockNodeManager, params);

      expect(mockNodeManager.findNodesByType).toHaveBeenCalledWith('class', 'test-project');
      
      // Parse the JSON response to check structure
      const responseData = JSON.parse(result.content[0].text);
      expect(responseData).toHaveProperty('results');
      expect(responseData).toHaveProperty('pagination');
      expect(responseData).toHaveProperty('truncated');
      expect(responseData).toHaveProperty('estimatedTokens');
      
      // Check pagination metadata
      expect(responseData.pagination.total).toBe(2);
      expect(responseData.pagination.returned).toBe(2);
      expect(responseData.pagination.offset).toBe(0);
      expect(responseData.pagination.hasMore).toBe(false);
      
      // Check that results contain the expected nodes
      expect(responseData.results).toHaveLength(2);
      expect(responseData.results[0].name).toBe('Class1');
      expect(responseData.results[1].name).toBe('Class2');
    });

    test('should handle no nodes found', async () => {
      const params = {
        nodeType: 'interface' as const,
        projectId: 'test-project'
      };

      mockNodeManager.findNodesByType.mockResolvedValue([]);

      const result = await findNodesByType(mockNodeManager, params);

      // Parse the JSON response to check empty results structure
      const responseData = JSON.parse(result.content[0].text);
      expect(responseData).toHaveProperty('results');
      expect(responseData).toHaveProperty('pagination');
      expect(responseData).toHaveProperty('truncated');
      expect(responseData).toHaveProperty('estimatedTokens');
      
      // Check empty results
      expect(responseData.results).toEqual([]);
      expect(responseData.pagination.total).toBe(0);
      expect(responseData.pagination.returned).toBe(0);
      expect(responseData.pagination.hasMore).toBe(false);
    });

    test('should handle findNodesByType errors', async () => {
      const params = {
        nodeType: 'class' as const,
        projectId: 'test-project'
      };

      mockNodeManager.findNodesByType.mockRejectedValue(new Error('Database error'));

      const result = await findNodesByType(mockNodeManager, params);

      expect(result.isError).toBe(true);
      expect(result.content[0].text).toContain('Failed to find nodes');
      expect(result.content[0].text).toContain('Database error');
    });
  });

  describe('searchNodes', () => {
    test('should search nodes successfully', async () => {
      const params = {
        searchTerm: 'Test',
        projectId: 'test-project'
      };

      const foundNodes: CodeNode[] = [
        {
          id: 'test1',
          project_id: 'test-project',
          type: 'class',
          name: 'TestClass',
          qualified_name: 'com.example.TestClass'
        },
        {
          id: 'test2',
          project_id: 'test-project',
          type: 'method',
          name: 'testMethod',
          qualified_name: 'com.example.SomeClass.testMethod'
        }
      ];

      mockNodeManager.searchNodes.mockResolvedValue(foundNodes);

      const result = await searchNodes(mockNodeManager, params);

      expect(mockNodeManager.searchNodes).toHaveBeenCalledWith('Test', 'test-project');
      
      // Parse the JSON response to check structure
      const responseData = JSON.parse(result.content[0].text);
      expect(responseData).toHaveProperty('searchTerm');
      expect(responseData).toHaveProperty('results');
      expect(responseData).toHaveProperty('pagination');
      expect(responseData).toHaveProperty('truncated');
      expect(responseData).toHaveProperty('estimatedTokens');
      
      // Check search term
      expect(responseData.searchTerm).toBe('Test');
      
      // Check pagination metadata
      expect(responseData.pagination.total).toBe(2);
      expect(responseData.pagination.returned).toBe(2);
      expect(responseData.pagination.offset).toBe(0);
      expect(responseData.pagination.hasMore).toBe(false);
      
      // Check that results contain the expected nodes
      expect(responseData.results).toHaveLength(2);
      expect(responseData.results[0].name).toBe('TestClass');
      expect(responseData.results[1].name).toBe('testMethod');
    });

    test('should handle no search results', async () => {
      const params = {
        searchTerm: 'NonExistent',
        projectId: 'test-project'
      };

      mockNodeManager.searchNodes.mockResolvedValue([]);

      const result = await searchNodes(mockNodeManager, params);

      // Parse the JSON response to check empty results structure
      const responseData = JSON.parse(result.content[0].text);
      expect(responseData).toHaveProperty('searchTerm');
      expect(responseData).toHaveProperty('results');
      expect(responseData).toHaveProperty('pagination');
      expect(responseData).toHaveProperty('truncated');
      expect(responseData).toHaveProperty('estimatedTokens');
      
      // Check search term
      expect(responseData.searchTerm).toBe('NonExistent');
      
      // Check empty results
      expect(responseData.results).toEqual([]);
      expect(responseData.pagination.total).toBe(0);
      expect(responseData.pagination.returned).toBe(0);
      expect(responseData.pagination.hasMore).toBe(false);
    });

    test('should handle searchNodes errors', async () => {
      const params = {
        searchTerm: 'Error',
        projectId: 'test-project'
      };

      mockNodeManager.searchNodes.mockRejectedValue(new Error('Database error'));

      const result = await searchNodes(mockNodeManager, params);

      expect(result.isError).toBe(true);
      expect(result.content[0].text).toContain('Failed to search nodes');
      expect(result.content[0].text).toContain('Database error');
    });
  });
});


================================================
FILE: tests/mcp/tools/scanner-tools.test.ts
================================================
import { NodeManager } from '../../../src/graph/node-manager.js';
import { EdgeManager } from '../../../src/graph/edge-manager.js';
import { CodebaseScanner } from '../../../src/scanner/codebase-scanner.js';
import {
  addFile,
  scanDir,
  findParser,
  storeParseResult,
  summarizeEntityTypes
} from '../../../src/mcp/tools/scanner-tools.js';

// Mock the dependencies
jest.mock('../../../src/graph/node-manager.js');
jest.mock('../../../src/graph/edge-manager.js');
jest.mock('../../../src/scanner/codebase-scanner.js');
jest.mock('fs', () => ({
  existsSync: jest.fn(),
  promises: {
    readFile: jest.fn()
  }
}));

describe('Scanner Tools', () => {
  let mockNodeManager: jest.Mocked<NodeManager>;
  let mockEdgeManager: jest.Mocked<EdgeManager>;
  let mockCodebaseScanner: jest.Mocked<CodebaseScanner>;
  let mockNeo4jClient: any;
  let mockFs: any;

  beforeEach(() => {
    mockNodeManager = {
      addNode: jest.fn()
    } as any;

    mockEdgeManager = {
      addEdge: jest.fn()
    } as any;

    mockCodebaseScanner = {
      parsers: new Map(),
      validateProjectStructure: jest.fn(),
      clearGraph: jest.fn(),
      scanProject: jest.fn(),
      generateScanReport: jest.fn()
    } as any;

    mockNeo4jClient = {
      runQuery: jest.fn()
    };

    mockFs = require('fs');

    // Setup default parser mock
    const mockTypescriptParser = {
      canParse: jest.fn(),
      parseFile: jest.fn()
    };
    const mockJavaParser = {
      canParse: jest.fn(),
      parseFile: jest.fn()
    };
    const mockPythonParser = {
      canParse: jest.fn(),
      parseFile: jest.fn()
    };
    
    mockCodebaseScanner.parsers.set('typescript', mockTypescriptParser);
    mockCodebaseScanner.parsers.set('java', mockJavaParser);
    mockCodebaseScanner.parsers.set('python', mockPythonParser);
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('findParser', () => {
    test('should find typescript parser for .ts files', () => {
      const mockTypescriptParser = mockCodebaseScanner.parsers.get('typescript');
      const mockJavaParser = mockCodebaseScanner.parsers.get('java');
      const mockPythonParser = mockCodebaseScanner.parsers.get('python');
      
      mockTypescriptParser!.canParse.mockReturnValue(true);
      mockJavaParser!.canParse.mockReturnValue(false);
      mockPythonParser!.canParse.mockReturnValue(false);

      const result = findParser(mockCodebaseScanner, 'test.ts');

      expect(result).toBe(mockTypescriptParser);
      expect(mockTypescriptParser!.canParse).toHaveBeenCalledWith('test.ts');
    });

    test('should find java parser for .java files', () => {
      const mockTypescriptParser = mockCodebaseScanner.parsers.get('typescript');
      const mockJavaParser = mockCodebaseScanner.parsers.get('java');
      const mockPythonParser = mockCodebaseScanner.parsers.get('python');
      
      mockTypescriptParser!.canParse.mockReturnValue(false);
      mockJavaParser!.canParse.mockReturnValue(true);
      mockPythonParser!.canParse.mockReturnValue(false);

      const result = findParser(mockCodebaseScanner, 'Test.java');

      expect(result).toBe(mockJavaParser);
      expect(mockJavaParser!.canParse).toHaveBeenCalledWith('Test.java');
    });

    test('should return null when no parser can handle the file', () => {
      const mockTypescriptParser = mockCodebaseScanner.parsers.get('typescript');
      const mockJavaParser = mockCodebaseScanner.parsers.get('java');
      const mockPythonParser = mockCodebaseScanner.parsers.get('python');
      
      mockTypescriptParser!.canParse.mockReturnValue(false);
      mockJavaParser!.canParse.mockReturnValue(false);
      mockPythonParser!.canParse.mockReturnValue(false);

      const result = findParser(mockCodebaseScanner, 'test.txt');

      expect(result).toBeNull();
    });
  });

  describe('storeParseResult', () => {
    test('should store entities and relationships successfully', async () => {
      const parseResult = {
        entities: [
          { id: 'entity1', type: 'class', name: 'TestClass' },
          { id: 'entity2', type: 'method', name: 'testMethod' }
        ],
        relationships: [
          { id: 'rel1', type: 'contains', source: 'entity1', target: 'entity2' }
        ]
      };

      mockNodeManager.addNode.mockResolvedValue(undefined);
      mockEdgeManager.addEdge.mockResolvedValue(undefined);

      await storeParseResult(parseResult, 'test-project', mockNodeManager, mockEdgeManager);

      expect(mockNodeManager.addNode).toHaveBeenCalledTimes(2);
      expect(mockNodeManager.addNode).toHaveBeenCalledWith(parseResult.entities[0]);
      expect(mockNodeManager.addNode).toHaveBeenCalledWith(parseResult.entities[1]);
      expect(mockEdgeManager.addEdge).toHaveBeenCalledTimes(1);
      expect(mockEdgeManager.addEdge).toHaveBeenCalledWith(parseResult.relationships[0]);
    });

    test('should handle duplicate entity errors gracefully', async () => {
      const parseResult = {
        entities: [
          { id: 'entity1', type: 'class', name: 'TestClass' }
        ],
        relationships: []
      };

      mockNodeManager.addNode.mockRejectedValue(new Error('Entity already exists'));
      const consoleSpy = jest.spyOn(console, 'warn').mockImplementation();

      await storeParseResult(parseResult, 'test-project', mockNodeManager, mockEdgeManager);

      expect(consoleSpy).not.toHaveBeenCalled();
      consoleSpy.mockRestore();
    });

    test('should log non-duplicate errors', async () => {
      const parseResult = {
        entities: [
          { id: 'entity1', type: 'class', name: 'TestClass' }
        ],
        relationships: []
      };

      mockNodeManager.addNode.mockRejectedValue(new Error('Database connection failed'));
      const consoleSpy = jest.spyOn(console, 'warn').mockImplementation();

      await storeParseResult(parseResult, 'test-project', mockNodeManager, mockEdgeManager);

      expect(consoleSpy).toHaveBeenCalledWith('Failed to store entity entity1: Database connection failed');
      consoleSpy.mockRestore();
    });
  });

  describe('summarizeEntityTypes', () => {
    test('should summarize entity types correctly', () => {
      const entities = [
        { type: 'class' },
        { type: 'method' },
        { type: 'method' },
        { type: 'class' },
        { type: 'field' },
        { type: 'method' }
      ];

      const result = summarizeEntityTypes(entities);

      expect(result).toBe('  • method: 3\n  • class: 2\n  • field: 1');
    });

    test('should handle empty entities array', () => {
      const result = summarizeEntityTypes([]);

      expect(result).toBe('  No entities found');
    });
  });

  describe('addFile', () => {
    test('should parse file successfully', async () => {
      const params = {
        file_path: '/test/file.ts',
        project: 'test-project'
      };

      const parseResult = {
        entities: [
          { id: 'class1', type: 'class', name: 'TestClass' }
        ],
        relationships: [],
        errors: []
      };

      mockFs.existsSync.mockReturnValue(true);
      mockFs.promises.readFile.mockResolvedValue('const test = "hello";');
      
      const mockTypescriptParser = mockCodebaseScanner.parsers.get('typescript');
      const mockJavaParser = mockCodebaseScanner.parsers.get('java');
      const mockPythonParser = mockCodebaseScanner.parsers.get('python');
      
      mockTypescriptParser!.canParse.mockReturnValue(true);
      mockJavaParser!.canParse.mockReturnValue(false);
      mockPythonParser!.canParse.mockReturnValue(false);
      mockTypescriptParser!.parseFile.mockResolvedValue(parseResult);
      mockNodeManager.addNode.mockResolvedValue(undefined);

      const result = await addFile(
        mockCodebaseScanner,
        mockNodeManager,
        mockEdgeManager,
        mockNeo4jClient,
        params
      );

      expect(mockFs.existsSync).toHaveBeenCalledWith('/test/file.ts');
      expect(mockFs.promises.readFile).toHaveBeenCalledWith('/test/file.ts', 'utf-8');
      expect(mockTypescriptParser!.parseFile).toHaveBeenCalledWith('/test/file.ts', 'const test = "hello";', 'test-project');
      expect(result.content[0].text).toContain('✅ File parsed successfully');
      expect(result.content[0].text).toContain('Entities found: 1');
    });

    test('should handle non-existent file', async () => {
      const params = {
        file_path: '/nonexistent/file.ts',
        project: 'test-project'
      };

      mockFs.existsSync.mockReturnValue(false);

      const result = await addFile(
        mockCodebaseScanner,
        mockNodeManager,
        mockEdgeManager,
        mockNeo4jClient,
        params
      );

      expect(result.content[0].text).toBe('❌ File not found: /nonexistent/file.ts');
    });

    test('should handle unsupported file type', async () => {
      const params = {
        file_path: '/test/file.txt',
        project: 'test-project'
      };

      mockFs.existsSync.mockReturnValue(true);
      mockFs.promises.readFile.mockResolvedValue('some content');
      
      // No parser can handle .txt files
      const mockTypescriptParser = mockCodebaseScanner.parsers.get('typescript');
      const mockJavaParser = mockCodebaseScanner.parsers.get('java');
      const mockPythonParser = mockCodebaseScanner.parsers.get('python');
      
      mockTypescriptParser!.canParse.mockReturnValue(false);
      mockJavaParser!.canParse.mockReturnValue(false);
      mockPythonParser!.canParse.mockReturnValue(false);

      const result = await addFile(
        mockCodebaseScanner,
        mockNodeManager,
        mockEdgeManager,
        mockNeo4jClient,
        params
      );

      expect(result.content[0].text).toContain('❌ Unsupported file type');
      expect(result.content[0].text).toContain('Supported extensions');
    });

    test('should clear existing entities when clear_existing is true', async () => {
      const params = {
        file_path: '/test/file.ts',
        project: 'test-project',
        clear_existing: true
      };

      const parseResult = {
        entities: [],
        relationships: [],
        errors: []
      };

      mockFs.existsSync.mockReturnValue(true);
      mockFs.promises.readFile.mockResolvedValue('const test = "hello";');
      mockNeo4jClient.runQuery.mockResolvedValue({});
      
      const mockTypescriptParser = mockCodebaseScanner.parsers.get('typescript');
      const mockJavaParser = mockCodebaseScanner.parsers.get('java');
      const mockPythonParser = mockCodebaseScanner.parsers.get('python');
      
      mockTypescriptParser!.canParse.mockReturnValue(true);
      mockJavaParser!.canParse.mockReturnValue(false);
      mockPythonParser!.canParse.mockReturnValue(false);
      mockTypescriptParser!.parseFile.mockResolvedValue(parseResult);

      await addFile(
        mockCodebaseScanner,
        mockNodeManager,
        mockEdgeManager,
        mockNeo4jClient,
        params
      );

      expect(mockNeo4jClient.runQuery).toHaveBeenCalledWith(
        expect.stringContaining('DETACH DELETE n'),
        { filePath: '/test/file.ts', project: 'test-project' }
      );
    });

    test('should handle parse errors in results', async () => {
      const params = {
        file_path: '/test/file.ts',
        project: 'test-project'
      };

      const parseResult = {
        entities: [],
        relationships: [],
        errors: [
          { line: 5, message: 'Syntax error' },
          { line: 10, message: 'Type error' }
        ]
      };

      mockFs.existsSync.mockReturnValue(true);
      mockFs.promises.readFile.mockResolvedValue('invalid typescript');
      
      const mockTypescriptParser = mockCodebaseScanner.parsers.get('typescript');
      const mockJavaParser = mockCodebaseScanner.parsers.get('java');
      const mockPythonParser = mockCodebaseScanner.parsers.get('python');
      
      mockTypescriptParser!.canParse.mockReturnValue(true);
      mockJavaParser!.canParse.mockReturnValue(false);
      mockPythonParser!.canParse.mockReturnValue(false);
      mockTypescriptParser!.parseFile.mockResolvedValue(parseResult);

      const result = await addFile(
        mockCodebaseScanner,
        mockNodeManager,
        mockEdgeManager,
        mockNeo4jClient,
        params
      );

      expect(result.content[0].text).toContain('⚠️ Parse Errors:');
      expect(result.content[0].text).toContain('Line 5: Syntax error');
      expect(result.content[0].text).toContain('Line 10: Type error');
    });

    test('should handle parsing exceptions', async () => {
      const params = {
        file_path: '/test/file.ts',
        project: 'test-project'
      };

      mockFs.existsSync.mockReturnValue(true);
      mockFs.promises.readFile.mockResolvedValue('const test = "hello";');
      
      const mockTypescriptParser = mockCodebaseScanner.parsers.get('typescript');
      const mockJavaParser = mockCodebaseScanner.parsers.get('java');
      const mockPythonParser = mockCodebaseScanner.parsers.get('python');
      
      mockTypescriptParser!.canParse.mockReturnValue(true);
      mockJavaParser!.canParse.mockReturnValue(false);
      mockPythonParser!.canParse.mockReturnValue(false);
      mockTypescriptParser!.parseFile.mockRejectedValue(new Error('Parser crashed'));

      const result = await addFile(
        mockCodebaseScanner,
        mockNodeManager,
        mockEdgeManager,
        mockNeo4jClient,
        params
      );

      expect(result.content[0].text).toBe('❌ Failed to parse file: Parser crashed');
    });
  });

  describe('scanDir', () => {
    test('should scan directory successfully', async () => {
      const params = {
        project: 'test-project',
        directory_path: '/test/project'
      };

      const mockValidation = {
        isValid: true,
        detectedLanguages: ['typescript', 'java'] as any,
        suggestions: []
      };

      const mockScanResult = {
        totalFiles: 10,
        processedFiles: 8,
        entities: 25,
        relationships: 15
      };

      mockFs.existsSync.mockReturnValue(true);
      mockCodebaseScanner.validateProjectStructure.mockResolvedValue(mockValidation);
      mockCodebaseScanner.scanProject.mockResolvedValue(mockScanResult);
      mockCodebaseScanner.generateScanReport.mockResolvedValue('Scan completed successfully');

      const result = await scanDir(mockCodebaseScanner, params);

      expect(mockCodebaseScanner.validateProjectStructure).toHaveBeenCalledWith('/test/project');
      expect(mockCodebaseScanner.scanProject).toHaveBeenCalledWith({
        projectPath: '/test/project',
        projectId: 'test-project',
        projectName: 'test-project',
        languages: ['typescript', 'java'],
        excludePaths: [],
        includeTests: false,
        maxDepth: 10,
        outputProgress: false
      });
      expect(result.content[0].text).toBe('Scan completed successfully');
    });

    test('should handle non-existent directory', async () => {
      const params = {
        project: 'test-project',
        directory_path: '/nonexistent/project'
      };

      mockFs.existsSync.mockReturnValue(false);

      const result = await scanDir(mockCodebaseScanner, params);

      expect(result.content[0].text).toBe('❌ Directory not found: /nonexistent/project');
    });

    test('should handle invalid project structure', async () => {
      const params = {
        project: 'test-project',
        directory_path: '/test/invalid-project'
      };

      const mockValidation = {
        isValid: false,
        detectedLanguages: [],
        suggestions: ['No supported language files found', 'Try scanning a different directory']
      };

      mockFs.existsSync.mockReturnValue(true);
      mockCodebaseScanner.validateProjectStructure.mockResolvedValue(mockValidation);

      const result = await scanDir(mockCodebaseScanner, params);

      expect(result.content[0].text).toContain('❌ Invalid project structure:');
      expect(result.content[0].text).toContain('No supported language files found');
    });

    test('should use custom scan parameters', async () => {
      const params = {
        project: 'test-project',
        directory_path: '/test/project',
        languages: ['java'] as any,
        exclude_paths: ['node_modules', '*.test.ts'],
        include_tests: true,
        max_depth: 5,
        clear_existing: true
      };

      const mockValidation = {
        isValid: true,
        detectedLanguages: ['typescript', 'java'] as any,
        suggestions: []
      };

      mockFs.existsSync.mockReturnValue(true);
      mockCodebaseScanner.validateProjectStructure.mockResolvedValue(mockValidation);
      mockCodebaseScanner.clearGraph.mockResolvedValue(undefined);
      mockCodebaseScanner.scanProject.mockResolvedValue({});
      mockCodebaseScanner.generateScanReport.mockResolvedValue('Custom scan completed');

      await scanDir(mockCodebaseScanner, params);

      expect(mockCodebaseScanner.clearGraph).toHaveBeenCalledWith('test-project');
      expect(mockCodebaseScanner.scanProject).toHaveBeenCalledWith({
        projectPath: '/test/project',
        projectId: 'test-project',
        projectName: 'test-project',
        languages: ['java'],
        excludePaths: ['node_modules', '*.test.ts'],
        includeTests: true,
        maxDepth: 5,
        outputProgress: false
      });
    });

    test('should handle scanning exceptions', async () => {
      const params = {
        project: 'test-project',
        directory_path: '/test/project'
      };

      mockFs.existsSync.mockReturnValue(true);
      mockCodebaseScanner.validateProjectStructure.mockRejectedValue(new Error('Validation failed'));

      const result = await scanDir(mockCodebaseScanner, params);

      expect(result.content[0].text).toBe('❌ Failed to scan directory: Validation failed');
    });
  });
});


================================================
FILE: tests/mcp/tools/semantic-search-tools.test.ts
================================================
import { SemanticSearchManager } from '../../../src/services/semantic-search-manager.js';
import { 
  semanticSearch, 
  updateEmbeddings, 
  getSimilarCode, 
  initializeSemanticSearch,
  SemanticSearchToolParams,
  UpdateEmbeddingsParams,
  GetSimilarCodeParams
} from '../../../src/mcp/tools/semantic-search.js';
import { SemanticSearchResult } from '../../../src/types.js';

// Mock the SemanticSearchManager
jest.mock('../../../src/services/semantic-search-manager.js');

describe('Semantic Search MCP Tools', () => {
  let mockSemanticSearchManager: jest.Mocked<SemanticSearchManager>;

  const mockSearchResult: SemanticSearchResult = {
    node: {
      id: 'test-node',
      project_id: 'test-project',
      type: 'function',
      name: 'validateEmail',
      qualified_name: 'utils.validateEmail',
      description: 'Validates email addresses'
    },
    similarity_score: 0.85,
    matched_content: 'email validation function'
  };

  beforeEach(() => {
    jest.clearAllMocks();
    
    mockSemanticSearchManager = {
      semanticSearch: jest.fn(),
      hybridSearch: jest.fn(),
      getSimilarNodes: jest.fn(),
      updateEmbeddings: jest.fn(),
      initializeVectorIndexes: jest.fn(),
      addEmbeddingToNode: jest.fn()
    } as any;
  });

  describe('semanticSearch', () => {
    const basicParams: SemanticSearchToolParams = {
      query: 'email validation functions'
    };

    it('should perform basic semantic search', async () => {
      const expectedResults = [mockSearchResult];
      mockSemanticSearchManager.semanticSearch.mockResolvedValue(expectedResults);

      const result = await semanticSearch(mockSemanticSearchManager, basicParams);

      expect(result).toEqual({
        results: expectedResults,
        total_found: 1
      });

      expect(mockSemanticSearchManager.semanticSearch).toHaveBeenCalledWith({
        query: 'email validation functions',
        project_id: undefined,
        node_types: undefined,
        limit: undefined,
        similarity_threshold: undefined
      });
    });

    it('should perform semantic search with all parameters', async () => {
      const fullParams: SemanticSearchToolParams = {
        query: 'user authentication functions',
        project_id: 'my-project',
        node_types: ['function', 'method'],
        limit: 10,
        similarity_threshold: 0.8,
        include_graph_context: false,
        max_hops: 2
      };

      const expectedResults = [mockSearchResult];
      mockSemanticSearchManager.semanticSearch.mockResolvedValue(expectedResults);

      const result = await semanticSearch(mockSemanticSearchManager, fullParams);

      expect(result).toEqual({
        results: expectedResults,
        total_found: 1
      });

      expect(mockSemanticSearchManager.semanticSearch).toHaveBeenCalledWith({
        query: 'user authentication functions',
        project_id: 'my-project',
        node_types: ['function', 'method'],
        limit: 10,
        similarity_threshold: 0.8
      });
    });

    it('should perform hybrid search when graph context enabled', async () => {
      const hybridParams: SemanticSearchToolParams = {
        query: 'database operations',
        include_graph_context: true,
        max_hops: 3
      };

      const expectedResults = [mockSearchResult];
      mockSemanticSearchManager.hybridSearch.mockResolvedValue(expectedResults);

      const result = await semanticSearch(mockSemanticSearchManager, hybridParams);

      expect(result).toEqual({
        results: expectedResults,
        total_found: 1
      });

      expect(mockSemanticSearchManager.hybridSearch).toHaveBeenCalledWith(
        {
          query: 'database operations',
          project_id: undefined,
          node_types: undefined,
          limit: undefined,
          similarity_threshold: undefined
        },
        {
          includeRelationships: true,
          maxHops: 3
        }
      );
    });

    it('should handle search errors', async () => {
      const error = new Error('Search failed');
      mockSemanticSearchManager.semanticSearch.mockRejectedValue(error);

      await expect(
        semanticSearch(mockSemanticSearchManager, basicParams)
      ).rejects.toThrow('Semantic search failed: Search failed');
    });

    it('should handle hybrid search errors', async () => {
      const hybridParams: SemanticSearchToolParams = {
        query: 'test query',
        include_graph_context: true
      };

      const error = new Error('Hybrid search failed');
      mockSemanticSearchManager.hybridSearch.mockRejectedValue(error);

      await expect(
        semanticSearch(mockSemanticSearchManager, hybridParams)
      ).rejects.toThrow('Semantic search failed: Hybrid search failed');
    });

    it('should return empty results gracefully', async () => {
      mockSemanticSearchManager.semanticSearch.mockResolvedValue([]);

      const result = await semanticSearch(mockSemanticSearchManager, basicParams);

      expect(result).toEqual({
        results: [],
        total_found: 0
      });
    });
  });

  describe('updateEmbeddings', () => {
    it('should update embeddings with no parameters', async () => {
      const params: UpdateEmbeddingsParams = {};
      const mockResult = { updated: 15, failed: 2 };

      mockSemanticSearchManager.updateEmbeddings.mockResolvedValue(mockResult);

      const result = await updateEmbeddings(mockSemanticSearchManager, params);

      expect(result).toEqual({
        message: 'Embedding update completed. Updated: 15, Failed: 2',
        updated: 15,
        failed: 2
      });

      expect(mockSemanticSearchManager.updateEmbeddings).toHaveBeenCalledWith(
        undefined,
        undefined
      );
    });

    it('should update embeddings with project filter', async () => {
      const params: UpdateEmbeddingsParams = {
        project_id: 'my-project'
      };
      const mockResult = { updated: 8, failed: 0 };

      mockSemanticSearchManager.updateEmbeddings.mockResolvedValue(mockResult);

      const result = await updateEmbeddings(mockSemanticSearchManager, params);

      expect(result).toEqual({
        message: 'Embedding update completed. Updated: 8, Failed: 0',
        updated: 8,
        failed: 0
      });

      expect(mockSemanticSearchManager.updateEmbeddings).toHaveBeenCalledWith(
        'my-project',
        undefined
      );
    });

    it('should update embeddings with node type filter', async () => {
      const params: UpdateEmbeddingsParams = {
        project_id: 'my-project',
        node_types: ['function', 'method']
      };
      const mockResult = { updated: 5, failed: 1 };

      mockSemanticSearchManager.updateEmbeddings.mockResolvedValue(mockResult);

      const result = await updateEmbeddings(mockSemanticSearchManager, params);

      expect(result).toEqual({
        message: 'Embedding update completed. Updated: 5, Failed: 1',
        updated: 5,
        failed: 1
      });

      expect(mockSemanticSearchManager.updateEmbeddings).toHaveBeenCalledWith(
        'my-project',
        ['function', 'method']
      );
    });

    it('should handle update errors', async () => {
      const params: UpdateEmbeddingsParams = {};
      const error = new Error('Update failed');

      mockSemanticSearchManager.updateEmbeddings.mockRejectedValue(error);

      await expect(
        updateEmbeddings(mockSemanticSearchManager, params)
      ).rejects.toThrow('Failed to update embeddings: Update failed');
    });

    it('should handle unknown errors', async () => {
      const params: UpdateEmbeddingsParams = {};
      mockSemanticSearchManager.updateEmbeddings.mockRejectedValue('String error');

      await expect(
        updateEmbeddings(mockSemanticSearchManager, params)
      ).rejects.toThrow('Failed to update embeddings: Unknown error');
    });
  });

  describe('getSimilarCode', () => {
    const params: GetSimilarCodeParams = {
      node_id: 'test-node',
      project_id: 'test-project'
    };

    it('should get similar code with default limit', async () => {
      const expectedResults = [mockSearchResult];
      mockSemanticSearchManager.getSimilarNodes.mockResolvedValue(expectedResults);

      const result = await getSimilarCode(mockSemanticSearchManager, params);

      expect(result).toEqual({
        results: expectedResults,
        total_found: 1
      });

      expect(mockSemanticSearchManager.getSimilarNodes).toHaveBeenCalledWith(
        'test-node',
        'test-project',
        5
      );
    });

    it('should get similar code with custom limit', async () => {
      const paramsWithLimit: GetSimilarCodeParams = {
        ...params,
        limit: 10
      };

      const expectedResults = [mockSearchResult];
      mockSemanticSearchManager.getSimilarNodes.mockResolvedValue(expectedResults);

      const result = await getSimilarCode(mockSemanticSearchManager, paramsWithLimit);

      expect(result).toEqual({
        results: expectedResults,
        total_found: 1
      });

      expect(mockSemanticSearchManager.getSimilarNodes).toHaveBeenCalledWith(
        'test-node',
        'test-project',
        10
      );
    });

    it('should handle get similar code errors', async () => {
      const error = new Error('Node not found');
      mockSemanticSearchManager.getSimilarNodes.mockRejectedValue(error);

      await expect(
        getSimilarCode(mockSemanticSearchManager, params)
      ).rejects.toThrow('Failed to get similar code: Node not found');
    });

    it('should return empty results when no similar code found', async () => {
      mockSemanticSearchManager.getSimilarNodes.mockResolvedValue([]);

      const result = await getSimilarCode(mockSemanticSearchManager, params);

      expect(result).toEqual({
        results: [],
        total_found: 0
      });
    });

    it('should handle unknown errors in getSimilarCode', async () => {
      mockSemanticSearchManager.getSimilarNodes.mockRejectedValue(42);

      await expect(
        getSimilarCode(mockSemanticSearchManager, params)
      ).rejects.toThrow('Failed to get similar code: Unknown error');
    });
  });

  describe('initializeSemanticSearch', () => {
    it('should initialize semantic search successfully', async () => {
      mockSemanticSearchManager.initializeVectorIndexes.mockResolvedValue();

      const result = await initializeSemanticSearch(mockSemanticSearchManager);

      expect(result).toEqual({
        message: 'Semantic search initialized successfully. Vector indexes created.',
        success: true
      });

      expect(mockSemanticSearchManager.initializeVectorIndexes).toHaveBeenCalledWith();
    });

    it('should handle initialization errors', async () => {
      const error = new Error('Initialization failed');
      mockSemanticSearchManager.initializeVectorIndexes.mockRejectedValue(error);

      const result = await initializeSemanticSearch(mockSemanticSearchManager);

      expect(result).toEqual({
        message: 'Failed to initialize semantic search: Initialization failed',
        success: false
      });
    });

    it('should handle unknown initialization errors', async () => {
      mockSemanticSearchManager.initializeVectorIndexes.mockRejectedValue('Unknown error');

      const result = await initializeSemanticSearch(mockSemanticSearchManager);

      expect(result).toEqual({
        message: 'Failed to initialize semantic search: Unknown error',
        success: false
      });
    });
  });

  describe('Edge Cases and Error Handling', () => {
    it('should handle null/undefined parameters gracefully', async () => {
      // semanticSearch with minimal params
      mockSemanticSearchManager.semanticSearch.mockResolvedValue([]);
      
      const result = await semanticSearch(mockSemanticSearchManager, {
        query: 'test',
        project_id: undefined,
        node_types: undefined
      });

      expect(result.results).toEqual([]);
    });

    it('should handle empty string queries', async () => {
      mockSemanticSearchManager.semanticSearch.mockResolvedValue([]);

      const result = await semanticSearch(mockSemanticSearchManager, {
        query: ''
      });

      expect(result.results).toEqual([]);
      expect(mockSemanticSearchManager.semanticSearch).toHaveBeenCalledWith({
        query: '',
        project_id: undefined,
        node_types: undefined,
        limit: undefined,
        similarity_threshold: undefined
      });
    });

    it('should handle very large result sets', async () => {
      const largeResultSet = Array.from({ length: 1000 }, (_, i) => ({
        ...mockSearchResult,
        node: { ...mockSearchResult.node, id: `node-${i}` }
      }));

      mockSemanticSearchManager.semanticSearch.mockResolvedValue(largeResultSet);

      const result = await semanticSearch(mockSemanticSearchManager, {
        query: 'test',
        limit: 1000
      });

      expect(result.total_found).toBe(1000);
      expect(result.results).toHaveLength(1000);
    });

    it('should handle special characters in queries', async () => {
      const specialQuery = 'functions with @annotations & "special chars" (parentheses)';
      mockSemanticSearchManager.semanticSearch.mockResolvedValue([]);

      await semanticSearch(mockSemanticSearchManager, {
        query: specialQuery
      });

      expect(mockSemanticSearchManager.semanticSearch).toHaveBeenCalledWith({
        query: specialQuery,
        project_id: undefined,
        node_types: undefined,
        limit: undefined,
        similarity_threshold: undefined
      });
    });

    it('should preserve all similarity scores in results', async () => {
      const resultsWithVariousScores = [
        { ...mockSearchResult, similarity_score: 0.95 },
        { ...mockSearchResult, similarity_score: 0.75 },
        { ...mockSearchResult, similarity_score: 0.65 }
      ];

      mockSemanticSearchManager.semanticSearch.mockResolvedValue(resultsWithVariousScores);

      const result = await semanticSearch(mockSemanticSearchManager, {
        query: 'test'
      });

      expect(result.results[0].similarity_score).toBe(0.95);
      expect(result.results[1].similarity_score).toBe(0.75);
      expect(result.results[2].similarity_score).toBe(0.65);
    });
  });
});


================================================
FILE: tests/scanner/codebase-scanner-enhanced.test.ts
================================================
import { CodebaseScanner } from '../../src/scanner/codebase-scanner.js';
import { Neo4jClient } from '../../src/graph/neo4j-client.js';
import { ProjectLanguageDetector } from '../../src/scanner/detection/language-detector.js';
import { ProjectBuildFileDetector } from '../../src/scanner/detection/build-file-detector.js';
import * as fs from 'fs';

// Mock dependencies
jest.mock('../../src/graph/neo4j-client.js');
jest.mock('../../src/scanner/detection/language-detector.js');
jest.mock('../../src/scanner/detection/build-file-detector.js');
jest.mock('fs');
jest.mock('simple-git', () => ({
  simpleGit: jest.fn(() => ({
    clone: jest.fn(),
    listRemote: jest.fn()
  }))
}));

const MockNeo4jClient = Neo4jClient as jest.MockedClass<typeof Neo4jClient>;
const MockLanguageDetector = ProjectLanguageDetector as jest.MockedClass<typeof ProjectLanguageDetector>;
const MockBuildFileDetector = ProjectBuildFileDetector as jest.MockedClass<typeof ProjectBuildFileDetector>;
const mockFs = fs as jest.Mocked<typeof fs>;

describe('CodebaseScanner Enhanced Validation', () => {
  let scanner: CodebaseScanner;
  let mockClient: jest.Mocked<Neo4jClient>;
  let mockLanguageDetector: jest.Mocked<ProjectLanguageDetector>;
  let mockBuildFileDetector: jest.Mocked<ProjectBuildFileDetector>;

  beforeEach(() => {
    mockClient = {
      connect: jest.fn(),
      disconnect: jest.fn(),
      runQuery: jest.fn(),
      initializeDatabase: jest.fn(),
      healthCheck: jest.fn()
    } as any;

    mockLanguageDetector = {
      detectFromBuildFiles: jest.fn(),
      detectFromFileExtensions: jest.fn(),
      detectPrimaryLanguage: jest.fn(),
      detectLanguages: jest.fn(),
      validateLanguages: jest.fn(),
      getRecommendedScanConfig: jest.fn()
    } as any;

    mockBuildFileDetector = {
      detect: jest.fn(),
      canDetect: jest.fn(),
      extractMetadata: jest.fn()
    } as any;

    MockNeo4jClient.mockImplementation(() => mockClient);
    MockLanguageDetector.mockImplementation(() => mockLanguageDetector);
    MockBuildFileDetector.mockImplementation(() => mockBuildFileDetector);

    scanner = new CodebaseScanner(mockClient);
    jest.clearAllMocks();
  });

  describe('validateProjectStructure', () => {
    it('should return error for non-existent path', async () => {
      mockFs.existsSync.mockReturnValue(false);

      const result = await scanner.validateProjectStructure('/nonexistent/path');

      expect(result.isValid).toBe(false);
      expect(result.suggestions).toContain('Project path does not exist: /nonexistent/path');
      expect(result.detectedLanguages).toEqual([]);
    });

    it('should use build file detection when successful', async () => {
      mockFs.existsSync.mockReturnValue(true);
      mockBuildFileDetector.detect.mockResolvedValue({
        isValid: true,
        suggestions: ['✅ TypeScript project detected'],
        detectedLanguages: ['typescript'],
        primaryLanguage: 'typescript',
        projectMetadata: [{
          name: 'test-project',
          language: 'typescript',
          buildFilePath: '/test/package.json'
        }],
        subProjects: [],
        isMonoRepo: false
      });

      mockLanguageDetector.validateLanguages.mockReturnValue({
        supported: ['typescript'],
        unsupported: [],
        warnings: []
      });

      const result = await scanner.validateProjectStructure('/test/project');

      expect(result.isValid).toBe(true);
      expect(result.detectedLanguages).toEqual(['typescript']);
      expect(result.suggestions).toContain('✅ TypeScript project detected');
      expect(mockBuildFileDetector.detect).toHaveBeenCalledWith('/test/project');
    });

    it('should fallback to file extension detection when no build files', async () => {
      mockFs.existsSync.mockReturnValue(true);
      mockBuildFileDetector.detect.mockResolvedValue({
        isValid: false,
        suggestions: [],
        detectedLanguages: [],
        projectMetadata: [],
        subProjects: [],
        isMonoRepo: false
      });

      mockLanguageDetector.detectFromFileExtensions.mockResolvedValue(['java']);
      mockLanguageDetector.validateLanguages.mockReturnValue({
        supported: ['java'],
        unsupported: [],
        warnings: []
      });

      const result = await scanner.validateProjectStructure('/test/project');

      expect(result.isValid).toBe(true);
      expect(result.detectedLanguages).toEqual(['java']);
      expect(result.suggestions).toContain('💡 No build files detected - using file extension detection');
    });

    it('should handle completely empty projects', async () => {
      mockFs.existsSync.mockReturnValue(true);
      mockBuildFileDetector.detect.mockResolvedValue({
        isValid: false,
        suggestions: [],
        detectedLanguages: [],
        projectMetadata: [],
        subProjects: [],
        isMonoRepo: false
      });

      mockLanguageDetector.detectFromFileExtensions.mockResolvedValue([]);
      mockLanguageDetector.validateLanguages.mockReturnValue({
        supported: [],
        unsupported: [],
        warnings: []
      });

      const result = await scanner.validateProjectStructure('/test/project');

      expect(result.isValid).toBe(false);
      expect(result.detectedLanguages).toEqual([]);
      expect(result.suggestions).toContain('⚠️ No source files found - check project path and file extensions');
    });

    it('should add src directory suggestion when missing', async () => {
      mockFs.existsSync.mockImplementation((path: any) => {
        if (path.includes('src')) return false;
        return true;
      });

      mockBuildFileDetector.detect.mockResolvedValue({
        isValid: true,
        suggestions: [],
        detectedLanguages: ['typescript'],
        projectMetadata: [],
        subProjects: [],
        isMonoRepo: false
      });

      mockLanguageDetector.validateLanguages.mockReturnValue({
        supported: ['typescript'],
        unsupported: [],
        warnings: []
      });

      const result = await scanner.validateProjectStructure('/test/project');

      expect(result.suggestions).toContain('💡 Consider organizing code in a src/ directory for better analysis');
    });

    it('should include language validation warnings', async () => {
      mockFs.existsSync.mockReturnValue(true);
      mockBuildFileDetector.detect.mockResolvedValue({
        isValid: true,
        suggestions: [],
        detectedLanguages: ['typescript', 'csharp'],
        projectMetadata: [],
        subProjects: [],
        isMonoRepo: false
      });

      mockLanguageDetector.validateLanguages.mockReturnValue({
        supported: ['typescript'],
        unsupported: ['csharp'],
        warnings: ['⚠️ csharp is detected but not yet fully supported for parsing']
      });

      const result = await scanner.validateProjectStructure('/test/project');

      expect(result.suggestions).toContain('⚠️ csharp is detected but not yet fully supported for parsing');
    });

    it('should handle detection errors gracefully', async () => {
      mockFs.existsSync.mockReturnValue(true);
      mockBuildFileDetector.detect.mockRejectedValue(new Error('Detection failed'));

      const result = await scanner.validateProjectStructure('/test/project');

      expect(result.isValid).toBe(false);
      expect(result.suggestions).toContain('❌ Failed to analyze project structure: Detection failed');
    });
  });

  describe('getRecommendedScanConfig', () => {
    it('should provide comprehensive scan configuration', async () => {
      const mockDetection = {
        isValid: true,
        suggestions: ['✅ TypeScript project detected'],
        detectedLanguages: ['typescript'],
        primaryLanguage: 'typescript',
        projectMetadata: [{
          name: 'my-app',
          version: '1.0.0',
          language: 'typescript',
          buildFilePath: '/test/package.json'
        }],
        subProjects: [],
        isMonoRepo: false
      };

      const mockRecommendation = {
        languages: ['typescript'],
        primaryLanguage: 'typescript',
        buildSystems: ['npm'],
        frameworks: ['React'],
        suggestions: ['🚀 Framework: React'],
        includeTests: true,
        excludePaths: ['node_modules', 'dist', 'build']
      };

      // Mock the methods directly on the scanner instance
      jest.spyOn(scanner, 'validateProjectStructure').mockResolvedValue(mockDetection);
      mockLanguageDetector.getRecommendedScanConfig.mockResolvedValue(mockRecommendation);

      const result = await scanner.getRecommendedScanConfig('/test/project', 'test-project');

      expect(result.scanConfig.projectId).toBe('test-project');
      expect(result.scanConfig.projectName).toBe('my-app'); // From metadata
      expect(result.scanConfig.languages).toEqual(['typescript']);
      expect(result.scanConfig.excludePaths).toEqual(['node_modules', 'dist', 'build']);
      expect(result.scanConfig.includeTests).toBe(true);
      expect(result.projectMetadata).toEqual(mockDetection.projectMetadata);
      expect(result.suggestions).toEqual(expect.arrayContaining([
        '✅ TypeScript project detected',
        '🚀 Framework: React'
      ]));
    });

    it('should use project ID as name when no metadata available', async () => {
      const mockDetection = {
        isValid: true,
        suggestions: [],
        detectedLanguages: ['java'],
        projectMetadata: [],
        subProjects: [],
        isMonoRepo: false
      };

      const mockRecommendation = {
        languages: ['java'],
        primaryLanguage: 'java',
        buildSystems: ['maven'],
        frameworks: [],
        suggestions: [],
        includeTests: true,
        excludePaths: ['target', 'build']
      };

      mockBuildFileDetector.detect.mockResolvedValue(mockDetection);
      mockLanguageDetector.getRecommendedScanConfig.mockResolvedValue(mockRecommendation);

      const result = await scanner.getRecommendedScanConfig('/test/project');

      expect(result.scanConfig.projectId).toBe('project'); // From path
      expect(result.scanConfig.projectName).toBeUndefined(); // No metadata
    });

    it('should prefer primary language metadata', async () => {
      const mockDetection = {
        isValid: true,
        suggestions: [],
        detectedLanguages: ['typescript', 'java'],
        primaryLanguage: 'typescript',
        projectMetadata: [
          {
            name: 'backend',
            language: 'java',
            buildFilePath: '/test/pom.xml'
          },
          {
            name: 'frontend',
            language: 'typescript',
            buildFilePath: '/test/package.json'
          }
        ],
        subProjects: [],
        isMonoRepo: true
      };

      const mockRecommendation = {
        languages: ['typescript', 'java'],
        primaryLanguage: 'typescript',
        buildSystems: ['npm', 'maven'],
        frameworks: [],
        suggestions: [],
        includeTests: true,
        excludePaths: ['node_modules', 'target']
      };

      jest.spyOn(scanner, 'validateProjectStructure').mockResolvedValue(mockDetection);
      mockLanguageDetector.getRecommendedScanConfig.mockResolvedValue(mockRecommendation);

      const result = await scanner.getRecommendedScanConfig('/test/project');

      expect(result.scanConfig.projectName).toBe('frontend'); // Primary language metadata
    });
  });
});


================================================
FILE: tests/scanner/codebase-scanner.test.ts
================================================
import { CodebaseScanner } from '../../src/scanner/codebase-scanner.js';
import { Neo4jClient } from '../../src/graph/neo4j-client.js';
import { NodeManager } from '../../src/graph/node-manager.js';
import { EdgeManager } from '../../src/graph/edge-manager.js';

// Mock dependencies
jest.mock('../../src/graph/neo4j-client.js');
jest.mock('../../src/graph/node-manager.js');
jest.mock('../../src/graph/edge-manager.js');

describe('CodebaseScanner', () => {
  let mockClient: jest.Mocked<Neo4jClient>;
  let mockNodeManager: jest.Mocked<NodeManager>;
  let mockEdgeManager: jest.Mocked<EdgeManager>;
  let scanner: CodebaseScanner;

  beforeEach(() => {
    jest.clearAllMocks();
    
    mockClient = {
      runQuery: jest.fn().mockResolvedValue({ records: [] }),
      getProject: jest.fn(),
      createProject: jest.fn(),
    } as any;

    mockNodeManager = {
      addNode: jest.fn().mockResolvedValue(undefined),
    } as any;

    mockEdgeManager = {
      addEdge: jest.fn().mockResolvedValue(undefined),
    } as any;

    (NodeManager as jest.MockedClass<typeof NodeManager>).mockImplementation(() => mockNodeManager);
    (EdgeManager as jest.MockedClass<typeof EdgeManager>).mockImplementation(() => mockEdgeManager);

    scanner = new CodebaseScanner(mockClient);
  });

  describe('Constructor', () => {
    test('should create scanner with parsers initialized', () => {
      expect(scanner).toBeInstanceOf(CodebaseScanner);
      expect(NodeManager).toHaveBeenCalledWith(mockClient);
      expect(EdgeManager).toHaveBeenCalledWith(mockClient);
    });
  });

  describe('clearGraph', () => {
    test('should clear project-specific data', async () => {
      await scanner.clearGraph('test-project');

      expect(mockClient.runQuery).toHaveBeenCalledWith(
        expect.stringContaining('MATCH (n:CodeNode {project_id: $project_id})'),
        { project_id: 'test-project' }
      );
    });

    test('should clear all data when no project specified', async () => {
      await scanner.clearGraph();

      expect(mockClient.runQuery).toHaveBeenCalledWith(
        expect.stringContaining('MATCH (n)')
      );
    });
  });

  describe('generateScanReport', () => {
    test('should generate comprehensive report', async () => {
      const mockResult = {
        entities: [
          {
            id: 'class1',
            type: 'class' as const,
            name: 'TestClass',
            qualified_name: 'TestClass',
            source_file: 'test.ts',
            project_id: 'test'
          },
          {
            id: 'method1',
            type: 'method' as const,
            name: 'testMethod',
            qualified_name: 'TestClass.testMethod',
            source_file: 'test.ts',
            project_id: 'test'
          }
        ],
        relationships: [
          {
            id: 'rel1',
            type: 'contains' as const,
            source: 'class1',
            target: 'method1',
            source_file: 'test.ts',
            project_id: 'test'
          }
        ],
        errors: [],
        stats: {
          filesProcessed: 1,
          entitiesFound: 2,
          relationshipsFound: 1,
          processingTimeMs: 1000
        }
      };

      const report = await scanner.generateScanReport(mockResult);

      expect(report).toContain('CODEBASE SCAN REPORT');
      expect(report).toContain('Files processed: 1');
      expect(report).toContain('Entities found: 2');
      expect(report).toContain('• class: 1');
      expect(report).toContain('• method: 1');
      expect(report).toContain('• contains: 1');
      expect(report).toContain('TestClass: 1 methods');
    });

    test('should handle empty results', async () => {
      const mockResult = {
        entities: [],
        relationships: [],
        errors: [],
        stats: {
          filesProcessed: 0,
          entitiesFound: 0,
          relationshipsFound: 0,
          processingTimeMs: 100
        }
      };

      const report = await scanner.generateScanReport(mockResult);

      expect(report).toContain('Files processed: 0');
      expect(report).toContain('No classes found');
    });
  });
});


================================================
FILE: tests/scanner/scanner-simple.test.ts
================================================
// Simple tests for scanner functionality to boost coverage
import { CodebaseScanner } from '../../src/scanner/codebase-scanner';
import { Neo4jClient } from '../../src/graph/neo4j-client';

// Mock neo4j-driver and dependencies
jest.mock('neo4j-driver');
jest.mock('fs');
jest.mock('path');
jest.mock('simple-git', () => ({
  simpleGit: jest.fn(() => ({
    clone: jest.fn(),
    listRemote: jest.fn()
  }))
}));

describe('Scanner Simple Tests', () => {
  let mockClient: jest.Mocked<Neo4jClient>;
  let scanner: CodebaseScanner;

  beforeEach(() => {
    mockClient = {
      runQuery: jest.fn().mockResolvedValue({ records: [] }),
      getProject: jest.fn(),
      createProject: jest.fn()
    } as any;

    scanner = new CodebaseScanner(mockClient);
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('CodebaseScanner Constructor', () => {
    test('should create scanner instance', () => {
      expect(scanner).toBeInstanceOf(CodebaseScanner);
    });
  });

  describe('Scanner Configuration', () => {
    test('should handle scan config with defaults', () => {
      // Test that the scanner can be created and has default behavior
      const newScanner = new CodebaseScanner(mockClient);
      expect(newScanner).toBeDefined();
    });
  });

  describe('Error Handling', () => {
    test('should handle scanner errors gracefully', async () => {
      // Test error handling in scanner
      mockClient.runQuery.mockRejectedValue(new Error('Database error'));
      
      // Since we can't easily test the full scan without mocking the file system,
      // we'll test that the scanner handles database errors
      try {
        // This would typically be called internally during scanning
        await mockClient.runQuery('test query');
      } catch (error) {
        expect(error).toBeInstanceOf(Error);
      }
    });
  });

  // Test language detection methods if they exist as public methods
  describe('Language Detection', () => {
    test('should handle file extension detection', () => {
      // If there are any public utility methods for language detection,
      // we would test them here. For now, just verify the scanner exists.
      expect(scanner).toBeDefined();
    });
  });
});


================================================
FILE: tests/scanner/scanner-types.test.ts
================================================
import { 
  ScanConfig, 
  Language, 
  ParsedEntity, 
  ParsedRelationship, 
  ParseResult, 
  ParseError, 
  LanguageParser 
} from '../../src/scanner/types.js';

describe('Scanner Types', () => {
  describe('ScanConfig', () => {
    test('should create valid ScanConfig with required fields', () => {
      const config: ScanConfig = {
        projectPath: '/test/project',
        projectId: 'test-project',
        languages: ['typescript']
      };

      expect(config.projectPath).toBe('/test/project');
      expect(config.projectId).toBe('test-project');
      expect(config.languages).toContain('typescript');
    });

    test('should accept optional fields', () => {
      const config: ScanConfig = {
        projectPath: '/test/project',
        projectId: 'test-project',
        projectName: 'Test Project',
        languages: ['typescript', 'javascript'],
        excludePaths: ['node_modules/**', 'dist/**'],
        includeTests: true,
        maxDepth: 5,
        outputProgress: true
      };

      expect(config.projectName).toBe('Test Project');
      expect(config.excludePaths).toContain('node_modules/**');
      expect(config.includeTests).toBe(true);
      expect(config.maxDepth).toBe(5);
      expect(config.outputProgress).toBe(true);
    });
  });

  describe('Language type', () => {
    test('should accept valid language values', () => {
      const languages: Language[] = ['typescript', 'javascript', 'java', 'python', 'csharp'];
      
      expect(languages).toContain('typescript');
      expect(languages).toContain('javascript');
      expect(languages).toContain('java');
      expect(languages).toContain('python');
      expect(languages).toContain('csharp');
    });
  });

  describe('ParsedEntity', () => {
    test('should create valid ParsedEntity with required fields', () => {
      const entity: ParsedEntity = {
        id: 'test-entity-1',
        project_id: 'test-project',
        type: 'class',
        name: 'TestClass',
        qualified_name: 'com.test.TestClass',
        source_file: '/test/TestClass.java'
      };

      expect(entity.id).toBe('test-entity-1');
      expect(entity.type).toBe('class');
      expect(entity.name).toBe('TestClass');
      expect(entity.qualified_name).toBe('com.test.TestClass');
    });

    test('should accept all entity types', () => {
      const entityTypes: ParsedEntity['type'][] = [
        'class', 'interface', 'enum', 'exception', 
        'function', 'method', 'field', 'package', 'module'
      ];

      entityTypes.forEach(type => {
        const entity: ParsedEntity = {
          id: `test-${type}`,
          project_id: 'test-project',
          type,
          name: `Test${type}`,
          qualified_name: `test.${type}`,
          source_file: '/test/file'
        };

        expect(entity.type).toBe(type);
      });
    });

    test('should include optional fields', () => {
      const entity: ParsedEntity = {
        id: 'test-method',
        project_id: 'test-project',
        type: 'method',
        name: 'testMethod',
        qualified_name: 'TestClass.testMethod',
        source_file: '/test/TestClass.java',
        description: 'A test method',
        start_line: 10,
        end_line: 15,
        modifiers: ['public', 'static'],
        annotations: [{ name: 'Test', framework: 'junit' }],
        attributes: {
          parameters: [{
            name: 'param1',
            type: 'String',
            description: 'First parameter'
          }],
          return_type: 'void',
          implements: ['Runnable'],
          extends: 'BaseClass'
        }
      };

      expect(entity.description).toBe('A test method');
      expect(entity.start_line).toBe(10);
      expect(entity.end_line).toBe(15);
      expect(entity.modifiers).toContain('public');
      expect(entity.attributes?.parameters).toHaveLength(1);
      expect(entity.attributes?.return_type).toBe('void');
    });
  });

  describe('ParsedRelationship', () => {
    test('should create valid ParsedRelationship with required fields', () => {
      const relationship: ParsedRelationship = {
        id: 'rel-1',
        project_id: 'test-project',
        type: 'extends',
        source: 'ChildClass',
        target: 'ParentClass',
        source_file: '/test/ChildClass.java'
      };

      expect(relationship.id).toBe('rel-1');
      expect(relationship.type).toBe('extends');
      expect(relationship.source).toBe('ChildClass');
      expect(relationship.target).toBe('ParentClass');
    });

    test('should accept all relationship types', () => {
      const relationshipTypes: ParsedRelationship['type'][] = [
        'calls', 'implements', 'extends', 'contains', 
        'references', 'throws', 'belongs_to'
      ];

      relationshipTypes.forEach(type => {
        const relationship: ParsedRelationship = {
          id: `rel-${type}`,
          project_id: 'test-project',
          type,
          source: 'source',
          target: 'target',
          source_file: '/test/file'
        };

        expect(relationship.type).toBe(type);
      });
    });

    test('should include optional attributes', () => {
      const relationship: ParsedRelationship = {
        id: 'rel-calls',
        project_id: 'test-project',
        type: 'calls',
        source: 'methodA',
        target: 'methodB',
        source_file: '/test/file.ts',
        attributes: {
          line_number: 42,
          call_type: 'direct',
          arguments: ['arg1', 'arg2']
        }
      };

      expect(relationship.attributes?.line_number).toBe(42);
      expect(relationship.attributes?.call_type).toBe('direct');
      expect(relationship.attributes?.arguments).toContain('arg1');
    });
  });

  describe('ParseResult', () => {
    test('should create valid ParseResult', () => {
      const result: ParseResult = {
        entities: [{
          id: 'entity-1',
          project_id: 'test-project',
          type: 'class',
          name: 'TestClass',
          qualified_name: 'TestClass',
          source_file: '/test/file.ts'
        }],
        relationships: [{
          id: 'rel-1',
          project_id: 'test-project',
          type: 'contains',
          source: 'entity-1',
          target: 'method-1',
          source_file: '/test/file.ts'
        }],
        errors: [{
          file_path: '/test/file.ts',
          line: 10,
          message: 'Warning: unused variable',
          severity: 'warning'
        }],
        stats: {
          filesProcessed: 5,
          entitiesFound: 25,
          relationshipsFound: 15,
          processingTimeMs: 1500
        }
      };

      expect(result.entities).toHaveLength(1);
      expect(result.relationships).toHaveLength(1);
      expect(result.errors).toHaveLength(1);
      expect(result.stats.filesProcessed).toBe(5);
      expect(result.stats.entitiesFound).toBe(25);
      expect(result.stats.relationshipsFound).toBe(15);
      expect(result.stats.processingTimeMs).toBe(1500);
    });
  });

  describe('ParseError', () => {
    test('should create valid ParseError with required fields', () => {
      const error: ParseError = {
        file_path: '/test/file.ts',
        message: 'Syntax error at line 10'
      };

      expect(error.file_path).toBe('/test/file.ts');
      expect(error.message).toBe('Syntax error at line 10');
    });

    test('should include optional fields', () => {
      const error: ParseError = {
        project_id: 'test-project',
        file_path: '/test/file.ts',
        line: 10,
        message: 'Unexpected token',
        severity: 'error'
      };

      expect(error.project_id).toBe('test-project');
      expect(error.line).toBe(10);
      expect(error.severity).toBe('error');
    });

    test('should accept warning and error severity', () => {
      const warningError: ParseError = {
        file_path: '/test/file.ts',
        message: 'Unused variable',
        severity: 'warning'
      };

      const fatalError: ParseError = {
        file_path: '/test/file.ts',
        message: 'Syntax error',
        severity: 'error'
      };

      expect(warningError.severity).toBe('warning');
      expect(fatalError.severity).toBe('error');
    });
  });

  describe('LanguageParser interface', () => {
    test('should define required methods', () => {
      class MockParser implements LanguageParser {
        canParse(filePath: string): boolean {
          return filePath.endsWith('.mock');
        }

        async parseFile(filePath: string, content: string, projectId: string) {
          return {
            entities: [],
            relationships: [],
            errors: []
          };
        }
      }

      const parser = new MockParser();
      
      expect(typeof parser.canParse).toBe('function');
      expect(typeof parser.parseFile).toBe('function');
      expect(parser.canParse('test.mock')).toBe(true);
      expect(parser.canParse('test.other')).toBe(false);
    });

    test('should return correct parseFile result type', async () => {
      class MockParser implements LanguageParser {
        canParse(filePath: string): boolean {
          return true;
        }

        async parseFile(filePath: string, content: string, projectId: string) {
          return {
            entities: [{
              id: 'mock-entity',
              project_id: projectId,
              type: 'function' as const,
              name: 'mockFunction',
              qualified_name: 'mockFunction',
              source_file: filePath
            }],
            relationships: [],
            errors: []
          };
        }
      }

      const parser = new MockParser();
      const result = await parser.parseFile('/test/file.mock', 'content', 'test-project');

      expect(result.entities).toHaveLength(1);
      expect(result.entities[0].name).toBe('mockFunction');
      expect(result.entities[0].project_id).toBe('test-project');
    });
  });
});


================================================
FILE: tests/scanner/detection/integration.test.ts
================================================
import { ProjectLanguageDetector } from '../../../src/scanner/detection/language-detector.js';
import { ProjectBuildFileDetector } from '../../../src/scanner/detection/build-file-detector.js';

// Simple integration test to verify the components work together
describe('Language Detection Integration', () => {
  let languageDetector: ProjectLanguageDetector;
  let buildFileDetector: ProjectBuildFileDetector;

  beforeEach(() => {
    languageDetector = new ProjectLanguageDetector();
    buildFileDetector = new ProjectBuildFileDetector();
  });

  describe('Component Integration', () => {
    it('should instantiate language detector successfully', () => {
      expect(languageDetector).toBeInstanceOf(ProjectLanguageDetector);
    });

    it('should instantiate build file detector successfully', () => {
      expect(buildFileDetector).toBeInstanceOf(ProjectBuildFileDetector);
    });

    it('should have required methods on language detector', () => {
      expect(typeof languageDetector.detectFromBuildFiles).toBe('function');
      expect(typeof languageDetector.detectFromFileExtensions).toBe('function');
      expect(typeof languageDetector.detectPrimaryLanguage).toBe('function');
      expect(typeof languageDetector.detectLanguages).toBe('function');
      expect(typeof languageDetector.validateLanguages).toBe('function');
      expect(typeof languageDetector.getRecommendedScanConfig).toBe('function');
    });

    it('should have required methods on build file detector', () => {
      expect(typeof buildFileDetector.detect).toBe('function');
      expect(typeof buildFileDetector.canDetect).toBe('function');
      expect(typeof buildFileDetector.extractMetadata).toBe('function');
    });

    it('should validate language correctly', () => {
      const result = languageDetector.validateLanguages(['typescript', 'java', 'csharp']);
      
      expect(result.supported).toContain('typescript');
      expect(result.supported).toContain('java');
      expect(result.unsupported).toContain('csharp');
      expect(result.warnings).toContain('⚠️ csharp is detected but not yet fully supported for parsing');
    });

    it('should detect build files by extension', () => {
      expect(buildFileDetector.canDetect('/path/to/package.json')).toBe(true);
      expect(buildFileDetector.canDetect('/path/to/pom.xml')).toBe(true);
      expect(buildFileDetector.canDetect('/path/to/build.gradle')).toBe(true);
      expect(buildFileDetector.canDetect('/path/to/setup.py')).toBe(true);
      expect(buildFileDetector.canDetect('/path/to/pyproject.toml')).toBe(true);
      expect(buildFileDetector.canDetect('/path/to/MyProject.csproj')).toBe(true);
      expect(buildFileDetector.canDetect('/path/to/unknown.txt')).toBe(false);
    });
  });
});


================================================
FILE: tests/scanner/detection/language-detector.test.ts
================================================
import { ProjectLanguageDetector } from '../../../src/scanner/detection/language-detector.js';
import { ProjectBuildFileDetector } from '../../../src/scanner/detection/build-file-detector.js';
import { glob } from 'glob';

// Mock dependencies
jest.mock('glob');
jest.mock('../../../src/scanner/detection/build-file-detector.js');

const mockGlob = glob as jest.MockedFunction<typeof glob>;
const MockBuildFileDetector = ProjectBuildFileDetector as jest.MockedClass<typeof ProjectBuildFileDetector>;

describe('ProjectLanguageDetector', () => {
  let detector: ProjectLanguageDetector;
  let mockBuildFileDetector: jest.Mocked<ProjectBuildFileDetector>;

  beforeEach(() => {
    mockBuildFileDetector = {
      detect: jest.fn(),
      canDetect: jest.fn(),
      extractMetadata: jest.fn()
    } as any;

    MockBuildFileDetector.mockImplementation(() => mockBuildFileDetector);
    detector = new ProjectLanguageDetector();
    jest.clearAllMocks();
  });

  describe('detectFromBuildFiles', () => {
    it('should detect languages from build files', async () => {
      mockBuildFileDetector.detect.mockResolvedValue({
        isValid: true,
        suggestions: [],
        detectedLanguages: ['typescript', 'java'],
        projectMetadata: [],
        subProjects: [],
        isMonoRepo: false
      });

      const languages = await detector.detectFromBuildFiles('/test/project');

      expect(languages).toEqual(['typescript', 'java']);
      expect(mockBuildFileDetector.detect).toHaveBeenCalledWith('/test/project');
    });

    it('should return empty array on error', async () => {
      mockBuildFileDetector.detect.mockRejectedValue(new Error('Test error'));
      const consoleSpy = jest.spyOn(console, 'warn').mockImplementation();

      const languages = await detector.detectFromBuildFiles('/test/project');

      expect(languages).toEqual([]);
      expect(consoleSpy).toHaveBeenCalled();
      consoleSpy.mockRestore();
    });
  });

  describe('detectFromFileExtensions', () => {
    it('should detect TypeScript files', async () => {
      mockGlob.mockResolvedValue(['src/app.ts', 'src/utils.tsx']);

      const languages = await detector.detectFromFileExtensions('/test/project');

      expect(languages).toContain('typescript');
    });

    it('should detect JavaScript files', async () => {
      mockGlob.mockResolvedValue(['src/app.js', 'src/utils.jsx']);

      const languages = await detector.detectFromFileExtensions('/test/project');

      expect(languages).toContain('javascript');
    });

    it('should detect Java files', async () => {
      mockGlob.mockResolvedValue(['src/main/java/App.java']);

      const languages = await detector.detectFromFileExtensions('/test/project');

      expect(languages).toContain('java');
    });

    it('should detect Python files', async () => {
      mockGlob.mockResolvedValue(['src/main.py', 'tests/test_app.py']);

      const languages = await detector.detectFromFileExtensions('/test/project');

      expect(languages).toContain('python');
    });

    it('should detect C# files', async () => {
      mockGlob.mockResolvedValue(['src/Program.cs', 'Models/User.cs']);

      const languages = await detector.detectFromFileExtensions('/test/project');

      expect(languages).toContain('csharp');
    });

    it('should detect multiple languages', async () => {
      mockGlob.mockResolvedValue([
        'frontend/app.ts',
        'backend/Main.java',
        'scripts/deploy.py'
      ]);

      const languages = await detector.detectFromFileExtensions('/test/project');

      expect(languages).toEqual(expect.arrayContaining(['typescript', 'java', 'python']));
    });

    it('should return empty array when no source files found', async () => {
      mockGlob.mockResolvedValue([]);

      const languages = await detector.detectFromFileExtensions('/test/project');

      expect(languages).toEqual([]);
    });

    it('should handle glob errors gracefully', async () => {
      mockGlob.mockRejectedValue(new Error('Glob error'));
      const consoleSpy = jest.spyOn(console, 'warn').mockImplementation();

      const languages = await detector.detectFromFileExtensions('/test/project');

      expect(languages).toEqual([]);
      expect(consoleSpy).toHaveBeenCalled();
      consoleSpy.mockRestore();
    });
  });

  describe('detectPrimaryLanguage', () => {
    it('should return undefined for empty language array', async () => {
      const primary = await detector.detectPrimaryLanguage([], '/test/project');
      expect(primary).toBeUndefined();
    });

    it('should return the single language', async () => {
      const primary = await detector.detectPrimaryLanguage(['typescript'], '/test/project');
      expect(primary).toBe('typescript');
    });

    it('should prefer build file detection when available', async () => {
      mockBuildFileDetector.detect.mockResolvedValue({
        isValid: true,
        suggestions: [],
        detectedLanguages: ['typescript', 'java'],
        primaryLanguage: 'typescript',
        projectMetadata: [],
        subProjects: [],
        isMonoRepo: false
      });

      const primary = await detector.detectPrimaryLanguage(['typescript', 'java'], '/test/project');
      expect(primary).toBe('typescript');
    });

    it('should fall back to file count when no primary language from build files', async () => {
      mockBuildFileDetector.detect.mockResolvedValue({
        isValid: true,
        suggestions: [],
        detectedLanguages: ['typescript', 'java'],
        projectMetadata: [],
        subProjects: [],
        isMonoRepo: false
      });

      // Mock glob calls for counting files
      mockGlob
        .mockResolvedValueOnce(['app.ts', 'utils.ts']) // 2 TypeScript files
        .mockResolvedValueOnce([]) // 0 TypeScript .tsx files
        .mockResolvedValueOnce(['Main.java']); // 1 Java file

      const primary = await detector.detectPrimaryLanguage(['typescript', 'java'], '/test/project');
      expect(primary).toBe('typescript');
    });
  });

  describe('detectLanguages', () => {
    it('should combine build file and extension detection', async () => {
      mockBuildFileDetector.detect.mockResolvedValue({
        isValid: true,
        suggestions: [],
        detectedLanguages: ['typescript'],
        primaryLanguage: 'typescript',
        projectMetadata: [],
        subProjects: [],
        isMonoRepo: false
      });

      mockGlob.mockResolvedValue(['app.ts', 'Main.java']); // Extension detection finds Java too

      const result = await detector.detectLanguages('/test/project');

      expect(result.languages).toEqual(expect.arrayContaining(['typescript', 'java']));
      expect(result.primaryLanguage).toBe('typescript');
      expect(result.buildFileLanguages).toEqual(['typescript']);
      expect(result.extensionLanguages).toEqual(expect.arrayContaining(['typescript', 'java']));
    });

    it('should deduplicate languages', async () => {
      mockBuildFileDetector.detect.mockResolvedValue({
        isValid: true,
        suggestions: [],
        detectedLanguages: ['typescript'],
        projectMetadata: [],
        subProjects: [],
        isMonoRepo: false
      });

      mockGlob.mockResolvedValue(['app.ts']); // Both methods detect TypeScript

      const result = await detector.detectLanguages('/test/project');

      expect(result.languages).toEqual(['typescript']); // No duplicates
    });
  });

  describe('validateLanguages', () => {
    it('should identify supported languages', () => {
      const result = detector.validateLanguages(['typescript', 'java', 'python']);

      expect(result.supported).toEqual(['typescript', 'java', 'python']);
      expect(result.unsupported).toEqual([]);
      expect(result.warnings).toEqual([]);
    });

    it('should identify unsupported languages', () => {
      const result = detector.validateLanguages(['csharp', 'typescript']);

      expect(result.supported).toEqual(['typescript']);
      expect(result.unsupported).toEqual(['csharp']);
      expect(result.warnings).toContain('⚠️ csharp is detected but not yet fully supported for parsing');
    });

    it('should warn when no supported languages found', () => {
      const result = detector.validateLanguages(['csharp', 'go']);

      expect(result.supported).toEqual([]);
      expect(result.unsupported).toEqual(['csharp', 'go']);
      expect(result.warnings).toContain('❌ No supported languages detected in project');
    });
  });

  describe('getRecommendedScanConfig', () => {
    it('should provide comprehensive scan configuration', async () => {
      // Mock language detection
      mockBuildFileDetector.detect.mockResolvedValue({
        isValid: true,
        suggestions: ['✅ TypeScript project detected'],
        detectedLanguages: ['typescript'],
        primaryLanguage: 'typescript',
        projectMetadata: [{
          name: 'test-project',
          language: 'typescript',
          buildSystem: 'npm',
          framework: 'React',
          buildFilePath: '/test/package.json'
        }],
        subProjects: [],
        isMonoRepo: false
      });

      mockGlob.mockResolvedValue(['app.ts']);

      const config = await detector.getRecommendedScanConfig('/test/project');

      expect(config.languages).toEqual(['typescript']);
      expect(config.primaryLanguage).toBe('typescript');
      expect(config.buildSystems).toEqual(['npm']);
      expect(config.frameworks).toEqual(['React']);
      expect(config.includeTests).toBe(true);
      expect(config.excludePaths).toContain('node_modules');
      expect(config.suggestions).toContain('✅ TypeScript project detected');
    });

    it('should add language-specific exclude paths', async () => {
      mockBuildFileDetector.detect.mockResolvedValue({
        isValid: true,
        suggestions: [],
        detectedLanguages: ['java', 'python'],
        projectMetadata: [],
        subProjects: [],
        isMonoRepo: false
      });

      mockGlob.mockResolvedValue(['Main.java', 'app.py']);

      const config = await detector.getRecommendedScanConfig('/test/project');

      expect(config.excludePaths).toContain('target/**');
      expect(config.excludePaths).toContain('__pycache__/**');
      expect(config.excludePaths).toContain('*.pyc');
    });

    it('should suggest mono-repo handling', async () => {
      mockBuildFileDetector.detect.mockResolvedValue({
        isValid: true,
        suggestions: [],
        detectedLanguages: ['typescript'],
        projectMetadata: [],
        subProjects: [],
        isMonoRepo: true
      });

      mockGlob.mockResolvedValue(['app.ts']);

      const config = await detector.getRecommendedScanConfig('/test/project');

      expect(config.suggestions).toContain('🏗️ Mono-repository structure detected - consider scanning sub-projects separately');
    });

    it('should filter out unsupported languages', async () => {
      mockBuildFileDetector.detect.mockResolvedValue({
        isValid: true,
        suggestions: [],
        detectedLanguages: ['typescript', 'csharp'],
        projectMetadata: [],
        subProjects: [],
        isMonoRepo: false
      });

      mockGlob.mockResolvedValue(['app.ts', 'Program.cs']);

      const config = await detector.getRecommendedScanConfig('/test/project');

      expect(config.languages).toEqual(['typescript']); // C# filtered out
      expect(config.suggestions).toContain('⚠️ csharp is detected but not yet fully supported for parsing');
    });
  });
});


================================================
FILE: tests/scanner/parsers/java-parser.test.ts
================================================
import { JavaParser } from '../../../src/scanner/parsers/java-parser.js';

describe('JavaParser', () => {
  let parser: JavaParser;

  beforeEach(() => {
    parser = new JavaParser();
    jest.clearAllMocks();
  });

  describe('canParse', () => {
    test('should accept Java files', () => {
      expect(parser.canParse('Test.java')).toBe(true);
      expect(parser.canParse('MyClass.java')).toBe(true);
      expect(parser.canParse('/path/to/File.java')).toBe(true);
    });

    test('should reject non-Java files', () => {
      expect(parser.canParse('test.ts')).toBe(false);
      expect(parser.canParse('test.js')).toBe(false);
      expect(parser.canParse('test.py')).toBe(false);
      expect(parser.canParse('test.txt')).toBe(false);
    });

    test('should handle case insensitive extensions', () => {
      expect(parser.canParse('Test.JAVA')).toBe(true);
      expect(parser.canParse('Test.Java')).toBe(true);
    });
  });

  describe('parseFile', () => {
    const projectId = 'test-project';
    const filePath = '/test/Test.java';

    test('should handle empty file', async () => {
      const result = await parser.parseFile(filePath, '', projectId);

      expect(result.entities).toEqual([]);
      expect(result.relationships).toEqual([]);
      // Empty file might generate parsing errors - that's acceptable
      expect(Array.isArray(result.errors)).toBe(true);
    });

    test('should return valid parse result structure', async () => {
      const javaCode = `package com.test;
public class TestClass {
  public void method() {}
}`;

      const result = await parser.parseFile(filePath, javaCode, projectId);

      expect(result).toHaveProperty('entities');
      expect(result).toHaveProperty('relationships');
      expect(result).toHaveProperty('errors');
      expect(Array.isArray(result.entities)).toBe(true);
      expect(Array.isArray(result.relationships)).toBe(true);
      expect(Array.isArray(result.errors)).toBe(true);
    });

    test('should handle simple Java code without throwing', async () => {
      const javaCode = `
        package com.test;
        
        public class TestClass {
          private String name;
          
          public TestClass(String name) {
            this.name = name;
          }
          
          public String getName() {
            return name;
          }
        }
      `;

      expect(async () => {
        await parser.parseFile(filePath, javaCode, projectId);
      }).not.toThrow();
    });

    test('should handle syntax errors gracefully', async () => {
      const javaCode = `
        package com.test;
        
        public class TestClass {
          // Missing closing brace
          public void method() {
        }
      `;

      const result = await parser.parseFile(filePath, javaCode, projectId);

      // Should not throw, may have errors in result
      expect(result).toBeDefined();
      expect(result).toHaveProperty('entities');
      expect(result).toHaveProperty('relationships');
      expect(result).toHaveProperty('errors');
    });
  });
});


================================================
FILE: tests/scanner/parsers/python-parser.test.ts
================================================
import { PythonParser } from '../../../src/scanner/parsers/python-parser.js';

describe('PythonParser', () => {
  let parser: PythonParser;

  beforeEach(() => {
    parser = new PythonParser();
    jest.clearAllMocks();
  });

  describe('canParse', () => {
    test('should accept Python files', () => {
      expect(parser.canParse('test.py')).toBe(true);
      expect(parser.canParse('script.py')).toBe(true);
      expect(parser.canParse('/path/to/file.py')).toBe(true);
    });

    test('should reject non-Python files', () => {
      expect(parser.canParse('test.ts')).toBe(false);
      expect(parser.canParse('test.js')).toBe(false);
      expect(parser.canParse('test.java')).toBe(false);
      expect(parser.canParse('test.txt')).toBe(false);
    });

    test('should handle case insensitive extensions', () => {
      expect(parser.canParse('test.PY')).toBe(true);
      expect(parser.canParse('test.Py')).toBe(true);
    });
  });

  describe('parseFile', () => {
    const projectId = 'test-project';
    const filePath = '/test/test.py';

    test('should handle empty file', async () => {
      const result = await parser.parseFile(filePath, '', projectId);

      // Empty file might still create a module entity, which is acceptable
      expect(Array.isArray(result.entities)).toBe(true);
      expect(Array.isArray(result.relationships)).toBe(true);
      expect(Array.isArray(result.errors)).toBe(true);
    });

    test('should return valid parse result structure', async () => {
      const pythonCode = `def test_function():\n    pass`;

      const result = await parser.parseFile(filePath, pythonCode, projectId);

      expect(result).toHaveProperty('entities');
      expect(result).toHaveProperty('relationships');
      expect(result).toHaveProperty('errors');
      expect(Array.isArray(result.entities)).toBe(true);
      expect(Array.isArray(result.relationships)).toBe(true);
      expect(Array.isArray(result.errors)).toBe(true);
    });

    test('should handle simple Python code without throwing', async () => {
      const pythonCode = `
class TestClass:
    def __init__(self):
        self.value = 42
    
    def get_value(self):
        return self.value
      `;

      expect(async () => {
        await parser.parseFile(filePath, pythonCode, projectId);
      }).not.toThrow();
    });

    test('should handle syntax errors gracefully', async () => {
      const pythonCode = `
def broken_function(
    # Missing closing parenthesis and colon
    print("This will cause a syntax error")
      `;

      const result = await parser.parseFile(filePath, pythonCode, projectId);

      // Should not throw, may have errors in result
      expect(result).toBeDefined();
      expect(result).toHaveProperty('entities');
      expect(result).toHaveProperty('relationships');
      expect(result).toHaveProperty('errors');
    });
  });
});


================================================
FILE: tests/scanner/parsers/typescript-parser.test.ts
================================================
import { TypeScriptParser } from '../../../src/scanner/parsers/typescript-parser.js';

describe('TypeScriptParser', () => {
  let parser: TypeScriptParser;

  beforeEach(() => {
    parser = new TypeScriptParser();
    jest.clearAllMocks();
  });

  describe('canParse', () => {
    test('should accept TypeScript files', () => {
      expect(parser.canParse('test.ts')).toBe(true);
      expect(parser.canParse('component.ts')).toBe(true);
      expect(parser.canParse('/path/to/file.ts')).toBe(true);
    });

    test('should accept TypeScript JSX files', () => {
      expect(parser.canParse('test.tsx')).toBe(true);
      expect(parser.canParse('Component.tsx')).toBe(true);
    });

    test('should accept JavaScript files', () => {
      expect(parser.canParse('test.js')).toBe(true);
      expect(parser.canParse('script.js')).toBe(true);
    });

    test('should accept JSX files', () => {
      expect(parser.canParse('test.jsx')).toBe(true);
      expect(parser.canParse('Component.jsx')).toBe(true);
    });

    test('should reject other file types', () => {
      expect(parser.canParse('test.java')).toBe(false);
      expect(parser.canParse('test.py')).toBe(false);
      expect(parser.canParse('test.txt')).toBe(false);
    });

    test('should handle case insensitive extensions', () => {
      expect(parser.canParse('test.TS')).toBe(true);
      expect(parser.canParse('test.JS')).toBe(true);
    });
  });

  describe('parseFile', () => {
    const projectId = 'test-project';
    const filePath = '/test/file.ts';

    test('should handle empty file', async () => {
      const result = await parser.parseFile(filePath, '', projectId);

      expect(result).toHaveProperty('entities');
      expect(result).toHaveProperty('relationships');
      expect(result).toHaveProperty('errors');
      expect(Array.isArray(result.entities)).toBe(true);
      expect(Array.isArray(result.relationships)).toBe(true);
      expect(Array.isArray(result.errors)).toBe(true);
    });

    test('should return valid parse result structure', async () => {
      const tsCode = `function hello(name: string): string {
  return "Hello " + name;
}`;

      const result = await parser.parseFile(filePath, tsCode, projectId);

      expect(result).toHaveProperty('entities');
      expect(result).toHaveProperty('relationships');
      expect(result).toHaveProperty('errors');
      expect(Array.isArray(result.entities)).toBe(true);
      expect(Array.isArray(result.relationships)).toBe(true);
      expect(Array.isArray(result.errors)).toBe(true);
    });

    test('should handle simple TypeScript code without throwing', async () => {
      const tsCode = `
        interface User {
          name: string;
          age: number;
        }
        
        class UserService {
          private users: User[] = [];
          
          addUser(user: User): void {
            this.users.push(user);
          }
          
          getUsers(): User[] {
            return this.users;
          }
        }
      `;

      expect(async () => {
        await parser.parseFile(filePath, tsCode, projectId);
      }).not.toThrow();
    });

    test('should handle syntax errors gracefully', async () => {
      const tsCode = `
        function broken(
          // Missing closing parenthesis and return type
          console.log("This will cause a syntax error")
      `;

      const result = await parser.parseFile(filePath, tsCode, projectId);

      // Should not throw, may have errors in result
      expect(result).toBeDefined();
      expect(result).toHaveProperty('entities');
      expect(result).toHaveProperty('relationships');
      expect(result).toHaveProperty('errors');
    });
  });
});


================================================
FILE: tests/scanner/parsers/base/base-language-parser.test.ts
================================================
import { BaseLanguageParser } from '../../../../src/scanner/parsers/base/BaseLanguageParser.js';
import { ParsedEntity, ParsedRelationship, ParseError } from '../../../../src/scanner/types.js';

describe('BaseLanguageParser', () => {
  class TestParser extends BaseLanguageParser {
    canParse(filePath: string): boolean {
      return filePath.endsWith('.test');
    }

    async parseFile(filePath: string, content: string, projectId: string) {
      this.setCurrentProject(projectId);
      
      const entities: ParsedEntity[] = [];
      const relationships: ParsedRelationship[] = [];
      const errors: ParseError[] = [];

      // Add test entities using the helper methods
      this.addEntity(entities, {
        id: 'test-entity',
        type: 'function',
        name: 'testFunction',
        qualified_name: 'testFunction',
        source_file: filePath
      });

      this.addRelationship(relationships, {
        id: 'test-relationship',
        type: 'calls',
        source: 'caller',
        target: 'callee',
        source_file: filePath
      });

      this.addError(errors, {
        file_path: filePath,
        message: 'Test error',
        severity: 'warning'
      });

      return { entities, relationships, errors };
    }
  }

  let parser: TestParser;

  beforeEach(() => {
    parser = new TestParser();
  });

  describe('canParse', () => {
    test('should identify supported files', () => {
      expect(parser.canParse('file.test')).toBe(true);
      expect(parser.canParse('file.other')).toBe(false);
    });
  });

  describe('addEntity', () => {
    test('should add entity with project_id', async () => {
      const result = await parser.parseFile('/test/file.test', 'content', 'test-project');

      expect(result.entities).toHaveLength(1);
      expect(result.entities[0]).toMatchObject({
        id: 'test-entity',
        project_id: 'test-project',
        type: 'function',
        name: 'testFunction',
        qualified_name: 'testFunction',
        source_file: '/test/file.test'
      });
    });

    test('should handle multiple entities', async () => {
      class MultiEntityParser extends BaseLanguageParser {
        canParse(filePath: string): boolean {
          return true;
        }

        async parseFile(filePath: string, content: string, projectId: string) {
          this.setCurrentProject(projectId);
          
          const entities: ParsedEntity[] = [];
          const relationships: ParsedRelationship[] = [];
          const errors: ParseError[] = [];

          this.addEntity(entities, {
            id: 'entity1',
            type: 'class',
            name: 'Class1',
            qualified_name: 'Class1',
            source_file: filePath
          });

          this.addEntity(entities, {
            id: 'entity2',
            type: 'method',
            name: 'method1',
            qualified_name: 'Class1.method1',
            source_file: filePath
          });

          return { entities, relationships, errors };
        }
      }

      const multiParser = new MultiEntityParser();
      const result = await multiParser.parseFile('/test/file.test', 'content', 'multi-project');

      expect(result.entities).toHaveLength(2);
      expect(result.entities[0].project_id).toBe('multi-project');
      expect(result.entities[1].project_id).toBe('multi-project');
    });
  });

  describe('addRelationship', () => {
    test('should add relationship with project_id', async () => {
      const result = await parser.parseFile('/test/file.test', 'content', 'test-project');

      expect(result.relationships).toHaveLength(1);
      expect(result.relationships[0]).toMatchObject({
        id: 'test-relationship',
        project_id: 'test-project',
        type: 'calls',
        source: 'caller',
        target: 'callee',
        source_file: '/test/file.test'
      });
    });

    test('should handle multiple relationships', async () => {
      class MultiRelationParser extends BaseLanguageParser {
        canParse(filePath: string): boolean {
          return true;
        }

        async parseFile(filePath: string, content: string, projectId: string) {
          this.setCurrentProject(projectId);
          
          const entities: ParsedEntity[] = [];
          const relationships: ParsedRelationship[] = [];
          const errors: ParseError[] = [];

          this.addRelationship(relationships, {
            id: 'rel1',
            type: 'extends',
            source: 'Child',
            target: 'Parent',
            source_file: filePath
          });

          this.addRelationship(relationships, {
            id: 'rel2',
            type: 'implements',
            source: 'Class',
            target: 'Interface',
            source_file: filePath
          });

          return { entities, relationships, errors };
        }
      }

      const multiParser = new MultiRelationParser();
      const result = await multiParser.parseFile('/test/file.test', 'content', 'multi-project');

      expect(result.relationships).toHaveLength(2);
      expect(result.relationships[0].project_id).toBe('multi-project');
      expect(result.relationships[1].project_id).toBe('multi-project');
    });
  });

  describe('addError', () => {
    test('should add error with project_id', async () => {
      const result = await parser.parseFile('/test/file.test', 'content', 'test-project');

      expect(result.errors).toHaveLength(1);
      expect(result.errors[0]).toMatchObject({
        file_path: '/test/file.test',
        project_id: 'test-project',
        message: 'Test error',
        severity: 'warning'
      });
    });

    test('should handle multiple errors', async () => {
      class MultiErrorParser extends BaseLanguageParser {
        canParse(filePath: string): boolean {
          return true;
        }

        async parseFile(filePath: string, content: string, projectId: string) {
          this.setCurrentProject(projectId);
          
          const entities: ParsedEntity[] = [];
          const relationships: ParsedRelationship[] = [];
          const errors: ParseError[] = [];

          this.addError(errors, {
            file_path: filePath,
            line: 10,
            message: 'Syntax error',
            severity: 'error'
          });

          this.addError(errors, {
            file_path: filePath,
            line: 20,
            message: 'Unused variable',
            severity: 'warning'
          });

          return { entities, relationships, errors };
        }
      }

      const multiParser = new MultiErrorParser();
      const result = await multiParser.parseFile('/test/file.test', 'content', 'multi-project');

      expect(result.errors).toHaveLength(2);
      expect(result.errors[0].project_id).toBe('multi-project');
      expect(result.errors[1].project_id).toBe('multi-project');
      expect(result.errors[0].severity).toBe('error');
      expect(result.errors[1].severity).toBe('warning');
    });
  });

  describe('setCurrentProject', () => {
    test('should set project_id for all subsequent entities', async () => {
      class ProjectTestParser extends BaseLanguageParser {
        canParse(filePath: string): boolean {
          return true;
        }

        async parseFile(filePath: string, content: string, projectId: string) {
          // First set to one project
          this.setCurrentProject('project1');
          
          const entities1: ParsedEntity[] = [];
          this.addEntity(entities1, {
            id: 'entity1',
            type: 'class',
            name: 'Class1',
            qualified_name: 'Class1',
            source_file: filePath
          });

          // Change to another project
          this.setCurrentProject('project2');
          
          const entities2: ParsedEntity[] = [];
          this.addEntity(entities2, {
            id: 'entity2',
            type: 'class',
            name: 'Class2',
            qualified_name: 'Class2',
            source_file: filePath
          });

          return { 
            entities: [...entities1, ...entities2], 
            relationships: [], 
            errors: [] 
          };
        }
      }

      const projectParser = new ProjectTestParser();
      const result = await projectParser.parseFile('/test/file.test', 'content', 'ignored');

      expect(result.entities).toHaveLength(2);
      expect(result.entities[0].project_id).toBe('project1');
      expect(result.entities[1].project_id).toBe('project2');
    });
  });

  describe('abstract methods', () => {
    test('should enforce implementation of abstract methods', () => {
      // This test verifies that the base class correctly defines abstract methods
      // TypeScript prevents instantiation of abstract classes at compile time
      // We can test this by verifying the class has the expected abstract methods
      expect(typeof BaseLanguageParser.prototype.canParse).toBe('undefined');
      expect(typeof BaseLanguageParser.prototype.parseFile).toBe('undefined');
    });
  });

  describe('integration test', () => {
    test('should work with complete parsing workflow', async () => {
      class CompleteParser extends BaseLanguageParser {
        canParse(filePath: string): boolean {
          return filePath.endsWith('.complete');
        }

        async parseFile(filePath: string, content: string, projectId: string) {
          this.setCurrentProject(projectId);
          
          const entities: ParsedEntity[] = [];
          const relationships: ParsedRelationship[] = [];
          const errors: ParseError[] = [];

          // Parse a class
          this.addEntity(entities, {
            id: 'class1',
            type: 'class',
            name: 'TestClass',
            qualified_name: 'com.test.TestClass',
            source_file: filePath,
            start_line: 1,
            end_line: 10,
            modifiers: ['public']
          });

          // Parse a method in the class
          this.addEntity(entities, {
            id: 'method1',
            type: 'method',
            name: 'testMethod',
            qualified_name: 'com.test.TestClass.testMethod',
            source_file: filePath,
            start_line: 3,
            end_line: 7,
            modifiers: ['public'],
            attributes: {
              return_type: 'void',
              parameters: [{
                name: 'param1',
                type: 'String'
              }]
            }
          });

          // Add containment relationship
          this.addRelationship(relationships, {
            id: 'contains1',
            type: 'contains',
            source: 'class1',
            target: 'method1',
            source_file: filePath
          });

          // Add a warning
          this.addError(errors, {
            file_path: filePath,
            line: 5,
            message: 'Consider adding documentation',
            severity: 'warning'
          });

          return { entities, relationships, errors };
        }
      }

      const completeParser = new CompleteParser();
      
      expect(completeParser.canParse('test.complete')).toBe(true);
      expect(completeParser.canParse('test.other')).toBe(false);

      const result = await completeParser.parseFile('/src/Test.complete', 'class TestClass { void testMethod(String param1) {} }', 'integration-test');

      expect(result.entities).toHaveLength(2);
      expect(result.relationships).toHaveLength(1);
      expect(result.errors).toHaveLength(1);

      // Verify class entity
      const classEntity = result.entities.find(e => e.type === 'class');
      expect(classEntity).toMatchObject({
        id: 'class1',
        project_id: 'integration-test',
        name: 'TestClass',
        qualified_name: 'com.test.TestClass',
        modifiers: ['public']
      });

      // Verify method entity
      const methodEntity = result.entities.find(e => e.type === 'method');
      expect(methodEntity).toMatchObject({
        id: 'method1',
        project_id: 'integration-test',
        name: 'testMethod',
        attributes: {
          return_type: 'void',
          parameters: [{ name: 'param1', type: 'String' }]
        }
      });

      // Verify relationship
      expect(result.relationships[0]).toMatchObject({
        id: 'contains1',
        project_id: 'integration-test',
        type: 'contains',
        source: 'class1',
        target: 'method1'
      });

      // Verify error
      expect(result.errors[0]).toMatchObject({
        project_id: 'integration-test',
        file_path: '/src/Test.complete',
        line: 5,
        message: 'Consider adding documentation',
        severity: 'warning'
      });
    });
  });
});


================================================
FILE: tests/scanner/parsers/framework-detection/import-based-detection.test.ts
================================================
import { FrameworkDetectionContext } from '../../../../src/scanner/parsers/framework-detection/FrameworkDetectionTypes.js';
import { JavaFrameworkDetector } from '../../../../src/scanner/parsers/framework-detection/java/JavaFrameworkDetector.js';
import { TypeScriptFrameworkDetector } from '../../../../src/scanner/parsers/framework-detection/typescript/TypeScriptFrameworkDetector.js';
import { ParsedImport } from '../../../../src/scanner/parsers/extractors/base/ContentExtractor.js';

describe('Import-Based Framework Detection', () => {
  let javaDetector: JavaFrameworkDetector;
  let typescriptDetector: TypeScriptFrameworkDetector;

  beforeEach(() => {
    javaDetector = new JavaFrameworkDetector();
    typescriptDetector = new TypeScriptFrameworkDetector();
  });

  describe('Spring Boot Detection', () => {
    it('should detect Spring Boot from core imports with high confidence', () => {
      const imports: ParsedImport[] = [
        { module: 'org.springframework.boot.SpringApplication', items: ['SpringApplication'] },
        { module: 'org.springframework.boot.autoconfigure.SpringBootApplication', items: ['SpringBootApplication'] }
      ];

      const result = javaDetector.detectFrameworkFromImports(imports);
      
      expect(result.framework).toBe('Spring Boot');
      expect(result.confidence).toBeGreaterThan(90);
      expect(result.detectionMethod).toBe('import');
      expect(result.details?.matchedImports).toContain('org.springframework.boot.SpringApplication');
    });

    it('should detect Spring Security from security imports', () => {
      const imports: ParsedImport[] = [
        { module: 'org.springframework.security.access.prepost.PreAuthorize', items: ['PreAuthorize'] },
        { module: 'org.springframework.security.config.annotation.web.builders.HttpSecurity', items: ['HttpSecurity'] }
      ];

      const result = javaDetector.detectFrameworkFromImports(imports);
      
      expect(result.framework).toBe('Spring Security');
      expect(result.confidence).toBeGreaterThan(85);
    });

    it('should combine annotation and import detection for higher confidence', () => {
      const context: FrameworkDetectionContext = {
        annotations: ['RestController', 'Autowired'],
        imports: [
          { module: 'org.springframework.boot.SpringApplication', items: ['SpringApplication'] },
          { module: 'org.springframework.web.bind.annotation.RestController', items: ['RestController'] }
        ]
      };

      const result = javaDetector.detectFrameworkWithContext(context);
      
      expect(result.framework).toBe('Spring Boot');
      expect(result.confidence).toBeGreaterThan(95); // Should be higher than annotation or import alone
      expect(result.detectionMethod).toBe('combined');
      expect(result.details?.matchedAnnotations).toContain('RestController');
      expect(result.details?.matchedImports).toContain('org.springframework.boot.SpringApplication');
    });
  });

  describe('NestJS vs Angular Disambiguation', () => {
    it('should detect NestJS when @Injectable comes from @nestjs/common', () => {
      const context: FrameworkDetectionContext = {
        annotations: ['Injectable', 'Controller'],
        imports: [
          { module: '@nestjs/common', items: ['Injectable', 'Controller'] },
          { module: '@nestjs/core', items: ['NestFactory'] }
        ]
      };

      const result = typescriptDetector.detectFrameworkWithContext(context);
      
      expect(result.framework).toBe('NestJS');
      expect(result.confidence).toBeGreaterThan(90);
      expect(result.detectionMethod).toBe('combined');
    });

    it('should detect Angular when @Injectable comes from @angular/core', () => {
      const context: FrameworkDetectionContext = {
        annotations: ['Injectable', 'Component'],
        imports: [
          { module: '@angular/core', items: ['Injectable', 'Component'] },
          { module: '@angular/common', items: ['CommonModule'] }
        ]
      };

      const result = typescriptDetector.detectFrameworkWithContext(context);
      
      expect(result.framework).toBe('Angular');
      expect(result.confidence).toBeGreaterThan(90);
      expect(result.detectionMethod).toBe('combined');
    });

    it('should prefer import-based detection when annotation is ambiguous', () => {
      const context: FrameworkDetectionContext = {
        annotations: ['Injectable'], // Ambiguous between Angular and NestJS
        imports: [
          { module: '@nestjs/common', items: ['Injectable'] }
        ]
      };

      const result = typescriptDetector.detectFrameworkWithContext(context);
      
      expect(result.framework).toBe('NestJS');
      expect(result.confidence).toBeGreaterThan(80);
    });
  });

  describe('Framework Statistics', () => {
    it('should report import patterns in framework statistics', () => {
      const stats = javaDetector.getFrameworkStatistics();
      
      expect(stats.totalImportPatterns).toBeGreaterThan(0);
      expect(stats.moduleBreakdown).toEqual(
        expect.arrayContaining([
          expect.objectContaining({
            name: 'Spring Boot',
            importPatternCount: expect.any(Number)
          })
        ])
      );
    });

    it('should report TypeScript framework import patterns', () => {
      const stats = typescriptDetector.getFrameworkStatistics();
      
      expect(stats.totalImportPatterns).toBeGreaterThan(0);
      expect(stats.moduleBreakdown).toEqual(
        expect.arrayContaining([
          expect.objectContaining({
            name: 'NestJS',
            importPatternCount: expect.any(Number)
          }),
          expect.objectContaining({
            name: 'Angular',
            importPatternCount: expect.any(Number)
          })
        ])
      );
    });
  });

  describe('Import Pattern Matching', () => {
    it('should match wildcard patterns correctly', () => {
      const imports: ParsedImport[] = [
        { module: 'org.springframework.boot.context.properties.ConfigurationProperties', items: ['ConfigurationProperties'] }
      ];

      const result = javaDetector.detectFrameworkFromImports(imports);
      
      expect(result.framework).toBe('Spring Boot');
      expect(result.confidence).toBeGreaterThan(0);
    });

    it('should handle exact package matches', () => {
      const imports: ParsedImport[] = [
        { module: '@nestjs/common', items: ['Injectable'] }
      ];

      const result = typescriptDetector.detectFrameworkFromImports(imports);
      
      expect(result.framework).toBe('NestJS');
      expect(result.confidence).toBe(95); // Should match exact confidence from pattern
    });
  });
});


================================================
FILE: tests/services/embedding-service.test.ts
================================================
import { EmbeddingService, OpenAIEmbeddingProvider, OllamaEmbeddingProvider } from '../../src/services/embedding-service.js';
import { SemanticSearchConfig } from '../../src/types.js';

// Mock OpenAI
jest.mock('openai', () => {
  return {
    __esModule: true,
    default: jest.fn().mockImplementation(() => ({
      embeddings: {
        create: jest.fn()
      }
    }))
  };
});

// Mock global fetch for Ollama tests
global.fetch = jest.fn();

describe('EmbeddingService', () => {
  const mockConfig: SemanticSearchConfig = {
    provider: 'openai',
    model: 'text-embedding-3-small',
    api_key: 'test-key',
    dimensions: 1536,
    max_tokens: 8000,
    batch_size: 100,
    similarity_threshold: 0.7
  };

  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe('Constructor and Initialization', () => {
    it('should initialize with disabled provider by default', () => {
      const service = new EmbeddingService({
        ...mockConfig,
        provider: 'disabled'
      });
      
      expect(service.isEnabled()).toBe(false);
    });

    it('should initialize OpenAI provider when configured', () => {
      const service = new EmbeddingService(mockConfig);
      expect(service.isEnabled()).toBe(true);
    });

    it('should handle missing API key gracefully', () => {
      const configWithoutKey = { ...mockConfig, api_key: undefined };
      const service = new EmbeddingService(configWithoutKey);
      
      expect(service.isEnabled()).toBe(false);
    });

    it('should initialize Ollama provider when configured', () => {
      const ollamaConfig: SemanticSearchConfig = {
        provider: 'ollama',
        model: 'nomic-embed-text',
        base_url: 'http://localhost:11434',
        dimensions: 768,
        max_tokens: 8000,
        batch_size: 50,
        similarity_threshold: 0.7
      };
      
      const service = new EmbeddingService(ollamaConfig);
      expect(service.isEnabled()).toBe(true);
    });

  });

  describe('extractSemanticContent', () => {
    let service: EmbeddingService;

    beforeEach(() => {
      service = new EmbeddingService(mockConfig);
    });

    it('should extract basic node information', () => {
      const node = {
        name: 'UserValidator',
        qualified_name: 'com.example.UserValidator',
        description: 'Validates user input data'
      };

      const content = service.extractSemanticContent(node);
      expect(content).toContain('UserValidator');
      expect(content).toContain('com.example.UserValidator');
      expect(content).toContain('Validates user input data');
    });

    it('should extract parameter information', () => {
      const node = {
        name: 'validateEmail',
        attributes: {
          parameters: [
            { name: 'email', type: 'string', description: 'Email address to validate' },
            { name: 'strict', type: 'boolean' }
          ]
        }
      };

      const content = service.extractSemanticContent(node);
      expect(content).toContain('Parameters:');
      expect(content).toContain('email: string - Email address to validate');
      expect(content).toContain('strict: boolean');
    });

    it('should extract return type information', () => {
      const node = {
        name: 'calculateTotal',
        attributes: {
          return_type: 'number'
        }
      };

      const content = service.extractSemanticContent(node);
      expect(content).toContain('Returns: number');
    });

    it('should extract annotations', () => {
      const node = {
        name: 'UserController',
        attributes: {
          annotations: [
            { name: '@RestController' },
            { name: '@RequestMapping' }
          ]
        }
      };

      const content = service.extractSemanticContent(node);
      expect(content).toContain('Annotations: @RestController, @RequestMapping');
    });

    it('should extract modifiers', () => {
      const node = {
        name: 'UserService',
        modifiers: ['public', 'final']
      };

      const content = service.extractSemanticContent(node);
      expect(content).toContain('Modifiers: public, final');
    });

    it('should handle empty node gracefully', () => {
      const node = {};
      const content = service.extractSemanticContent(node);
      expect(content).toBe('');
    });
  });

  describe('generateEmbedding', () => {
    let service: EmbeddingService;

    beforeEach(() => {
      service = new EmbeddingService(mockConfig);
    });

    it('should return null when service is disabled', async () => {
      const disabledService = new EmbeddingService({
        ...mockConfig,
        provider: 'disabled'
      });

      const result = await disabledService.generateEmbedding('test text');
      expect(result).toBeNull();
    });

    it('should handle successful embedding generation', async () => {
      const mockEmbedding = [0.1, 0.2, 0.3];
      const mockOpenAI = require('openai').default;
      const mockInstance = new mockOpenAI();
      mockInstance.embeddings.create.mockResolvedValue({
        data: [{ embedding: mockEmbedding }]
      });

      // We need to mock the provider directly since it's private
      // This test verifies the service interface
      const result = await service.generateEmbedding('test text');
      
      if (result) {
        expect(result.vector).toEqual(expect.any(Array));
        expect(result.model).toBe(mockConfig.model);
        expect(result.version).toBe('1.0');
        expect(result.created_at).toBeInstanceOf(Date);
      }
    });

    it('should handle API errors gracefully', async () => {
      // Mock console.error to suppress error output in tests
      const consoleSpy = jest.spyOn(console, 'error').mockImplementation();

      const result = await service.generateEmbedding('test text');
      
      // Service should handle errors and return null
      expect(result).toBeNull();
      
      consoleSpy.mockRestore();
    });
  });

  describe('generateEmbeddings', () => {
    let service: EmbeddingService;

    beforeEach(() => {
      service = new EmbeddingService(mockConfig);
    });

    it('should return null array when service is disabled', async () => {
      const disabledService = new EmbeddingService({
        ...mockConfig,
        provider: 'disabled'
      });

      const texts = ['text1', 'text2'];
      const result = await disabledService.generateEmbeddings(texts);
      expect(result).toEqual([null, null]);
    });

    it('should handle empty input array', async () => {
      const result = await service.generateEmbeddings([]);
      expect(result).toEqual([]);
    });

    it('should handle batch embedding errors gracefully', async () => {
      const consoleSpy = jest.spyOn(console, 'error').mockImplementation();

      const texts = ['text1', 'text2'];
      const result = await service.generateEmbeddings(texts);
      
      expect(result).toEqual([null, null]);
      
      consoleSpy.mockRestore();
    });
  });
});

describe('OpenAIEmbeddingProvider', () => {
  const mockConfig: SemanticSearchConfig = {
    provider: 'openai',
    model: 'text-embedding-3-small',
    api_key: 'test-key',
    dimensions: 1536,
    max_tokens: 8000,
    batch_size: 100,
    similarity_threshold: 0.7
  };

  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe('Constructor', () => {
    it('should throw error when API key is missing', () => {
      const configWithoutKey = { ...mockConfig, api_key: undefined };
      
      expect(() => {
        new OpenAIEmbeddingProvider(configWithoutKey);
      }).toThrow('OpenAI API key is required');
    });

    it('should initialize successfully with valid config', () => {
      expect(() => {
        new OpenAIEmbeddingProvider(mockConfig);
      }).not.toThrow();
    });
  });

  describe('getDimensions and getModel', () => {
    it('should return correct dimensions and model', () => {
      const provider = new OpenAIEmbeddingProvider(mockConfig);
      
      expect(provider.getDimensions()).toBe(1536);
      expect(provider.getModel()).toBe('text-embedding-3-small');
    });
  });

  describe('truncateText', () => {
    it('should truncate long text', () => {
      const provider = new OpenAIEmbeddingProvider(mockConfig);
      
      // Access private method for testing
      const longText = 'a'.repeat(50000);
      const truncated = (provider as any).truncateText(longText, 1000);
      
      expect(truncated.length).toBeLessThan(longText.length);
      expect(truncated.endsWith('...')).toBe(true);
    });

    it('should not truncate short text', () => {
      const provider = new OpenAIEmbeddingProvider(mockConfig);
      
      const shortText = 'short text';
      const result = (provider as any).truncateText(shortText, 1000);
      
      expect(result).toBe(shortText);
    });
  });

  describe('generateEmbedding', () => {
    it('should handle successful API response', async () => {
      const mockEmbedding = [0.1, 0.2, 0.3];
      const mockOpenAI = require('openai').default;
      const mockInstance = new mockOpenAI();
      mockInstance.embeddings.create.mockResolvedValue({
        data: [{ embedding: mockEmbedding }]
      });

      const provider = new OpenAIEmbeddingProvider(mockConfig);
      
      // Replace the client with our mock
      (provider as any).client = mockInstance;
      
      const result = await provider.generateEmbedding('test text');
      
      expect(result).toEqual(mockEmbedding);
      expect(mockInstance.embeddings.create).toHaveBeenCalledWith({
        model: 'text-embedding-3-small',
        input: 'test text'
      });
    });

    it('should handle API errors', async () => {
      const mockOpenAI = require('openai').default;
      const mockInstance = new mockOpenAI();
      mockInstance.embeddings.create.mockRejectedValue(new Error('API Error'));

      const provider = new OpenAIEmbeddingProvider(mockConfig);
      (provider as any).client = mockInstance;

      await expect(provider.generateEmbedding('test text')).rejects.toThrow('Failed to generate embedding: API Error');
    });
  });

  describe('generateEmbeddings', () => {
    it('should handle batch processing', async () => {
      const mockEmbeddings = [[0.1, 0.2], [0.3, 0.4], [0.5, 0.6]];
      const mockOpenAI = require('openai').default;
      const mockInstance = new mockOpenAI();
      mockInstance.embeddings.create.mockResolvedValue({
        data: mockEmbeddings.map(embedding => ({ embedding }))
      });

      const provider = new OpenAIEmbeddingProvider(mockConfig);
      (provider as any).client = mockInstance;

      const texts = ['text1', 'text2', 'text3'];
      const result = await provider.generateEmbeddings(texts);

      expect(result).toEqual(mockEmbeddings);
    });

    it('should process large batches in chunks', async () => {
      const smallBatchConfig = { ...mockConfig, batch_size: 2 };
      const provider = new OpenAIEmbeddingProvider(smallBatchConfig);

      const mockOpenAI = require('openai').default;
      const mockInstance = new mockOpenAI();
      mockInstance.embeddings.create
        .mockResolvedValueOnce({ data: [{ embedding: [0.1, 0.2] }, { embedding: [0.3, 0.4] }] })
        .mockResolvedValueOnce({ data: [{ embedding: [0.5, 0.6] }] });

      (provider as any).client = mockInstance;

      const texts = ['text1', 'text2', 'text3'];
      const result = await provider.generateEmbeddings(texts);

      expect(result).toEqual([[0.1, 0.2], [0.3, 0.4], [0.5, 0.6]]);
      expect(mockInstance.embeddings.create).toHaveBeenCalledTimes(2);
    });
  });
});


describe('OllamaEmbeddingProvider', () => {
  const mockConfig: SemanticSearchConfig = {
    provider: 'ollama',
    model: 'nomic-embed-text',
    base_url: 'http://localhost:11434',
    dimensions: 768,
    max_tokens: 8000,
    batch_size: 50,
    similarity_threshold: 0.7
  };

  beforeEach(() => {
    jest.clearAllMocks();
    (fetch as jest.Mock).mockClear();
  });

  describe('Constructor', () => {
    it('should initialize with default base URL when not provided', () => {
      const configWithoutUrl = { ...mockConfig, base_url: undefined };
      
      expect(() => {
        new OllamaEmbeddingProvider(configWithoutUrl);
      }).not.toThrow();
    });

    it('should use custom base URL when provided', () => {
      const provider = new OllamaEmbeddingProvider(mockConfig);
      expect(provider.getModel()).toBe('nomic-embed-text');
    });
  });

  describe('getDimensions and getModel', () => {
    it('should return correct dimensions and model', () => {
      const provider = new OllamaEmbeddingProvider(mockConfig);
      
      expect(provider.getDimensions()).toBe(768);
      expect(provider.getModel()).toBe('nomic-embed-text');
    });
  });

  describe('generateEmbedding', () => {
    it('should handle successful API response', async () => {
      const mockEmbedding = [0.1, 0.2, 0.3];
      (fetch as jest.Mock).mockResolvedValue({
        ok: true,
        json: jest.fn().mockResolvedValue({
          embedding: mockEmbedding
        })
      });

      const provider = new OllamaEmbeddingProvider(mockConfig);
      const result = await provider.generateEmbedding('test text');

      expect(result).toEqual(mockEmbedding);
      expect(fetch).toHaveBeenCalledWith('http://localhost:11434/api/embeddings', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          model: 'nomic-embed-text',
          prompt: 'test text',
        }),
      });
    });

    it('should handle API errors', async () => {
      (fetch as jest.Mock).mockResolvedValue({
        ok: false,
        status: 500,
        statusText: 'Internal Server Error'
      });

      const provider = new OllamaEmbeddingProvider(mockConfig);

      await expect(provider.generateEmbedding('test text')).rejects.toThrow('Failed to generate Ollama embedding: Ollama API error: 500 Internal Server Error');
    });

    it('should handle network errors', async () => {
      (fetch as jest.Mock).mockRejectedValue(new Error('Network error'));

      const provider = new OllamaEmbeddingProvider(mockConfig);

      await expect(provider.generateEmbedding('test text')).rejects.toThrow('Failed to generate Ollama embedding: Network error');
    });

    it('should truncate long text', async () => {
      const mockEmbedding = [0.1, 0.2, 0.3];
      (fetch as jest.Mock).mockResolvedValue({
        ok: true,
        json: jest.fn().mockResolvedValue({
          embedding: mockEmbedding
        })
      });

      const provider = new OllamaEmbeddingProvider(mockConfig);
      const longText = 'a'.repeat(50000);
      
      await provider.generateEmbedding(longText);

      expect(fetch).toHaveBeenCalledWith(
        expect.any(String),
        expect.objectContaining({
          body: expect.stringContaining('"prompt":"' + 'a'.repeat(32000) + '..."')
        })
      );
    });
  });

  describe('generateEmbeddings', () => {
    it('should handle batch processing', async () => {
      const mockEmbeddings = [[0.1, 0.2], [0.3, 0.4], [0.5, 0.6]];
      
      (fetch as jest.Mock)
        .mockResolvedValueOnce({
          ok: true,
          json: jest.fn().mockResolvedValue({ embedding: mockEmbeddings[0] })
        })
        .mockResolvedValueOnce({
          ok: true,
          json: jest.fn().mockResolvedValue({ embedding: mockEmbeddings[1] })
        })
        .mockResolvedValueOnce({
          ok: true,
          json: jest.fn().mockResolvedValue({ embedding: mockEmbeddings[2] })
        });

      const provider = new OllamaEmbeddingProvider(mockConfig);
      const texts = ['text1', 'text2', 'text3'];
      const result = await provider.generateEmbeddings(texts);

      expect(result).toEqual(mockEmbeddings);
      expect(fetch).toHaveBeenCalledTimes(3);
    });

    it('should process in controlled batches', async () => {
      const smallBatchConfig = { ...mockConfig, batch_size: 2 };
      const provider = new OllamaEmbeddingProvider(smallBatchConfig);

      const mockEmbeddings = [[0.1, 0.2], [0.3, 0.4], [0.5, 0.6]];
      
      // Mock responses for each individual embedding call
      mockEmbeddings.forEach(embedding => {
        (fetch as jest.Mock).mockResolvedValueOnce({
          ok: true,
          json: jest.fn().mockResolvedValue({ embedding })
        });
      });

      const texts = ['text1', 'text2', 'text3'];
      const result = await provider.generateEmbeddings(texts);

      expect(result).toEqual(mockEmbeddings);
      expect(fetch).toHaveBeenCalledTimes(3);
    });

    it('should handle batch errors gracefully', async () => {
      (fetch as jest.Mock).mockRejectedValue(new Error('Network error'));

      const provider = new OllamaEmbeddingProvider(mockConfig);
      const texts = ['text1', 'text2'];

      await expect(provider.generateEmbeddings(texts)).rejects.toThrow('Failed to generate Ollama batch embeddings');
    });
  });
});


================================================
FILE: tests/services/semantic-search-manager.test.ts
================================================
import { SemanticSearchManager } from '../../src/services/semantic-search-manager.js';
import { EmbeddingService } from '../../src/services/embedding-service.js';
import { Neo4jClient } from '../../src/graph/neo4j-client.js';
import { SemanticSearchParams, SemanticEmbedding, CodeNode } from '../../src/types.js';

// Mock dependencies
jest.mock('../../src/services/embedding-service.js');
jest.mock('../../src/graph/neo4j-client.js');

describe('SemanticSearchManager', () => {
  let manager: SemanticSearchManager;
  let mockNeo4jClient: jest.Mocked<Neo4jClient>;
  let mockEmbeddingService: jest.Mocked<EmbeddingService>;

  const mockEmbedding: SemanticEmbedding = {
    vector: [0.1, 0.2, 0.3, 0.4, 0.5],
    model: 'text-embedding-3-small',
    version: '1.0',
    created_at: new Date('2024-01-01')
  };

  const mockCodeNode: CodeNode = {
    id: 'test-node',
    project_id: 'test-project',
    type: 'function',
    name: 'validateEmail',
    qualified_name: 'utils.validateEmail',
    description: 'Validates email addresses'
  };

  beforeEach(() => {
    // Reset mocks
    jest.clearAllMocks();

    // Create mocked instances
    mockNeo4jClient = {
      runQuery: jest.fn(),
      connect: jest.fn(),
      disconnect: jest.fn(),
      healthCheck: jest.fn(),
      initializeDatabase: jest.fn(),
      createProject: jest.fn(),
      getProject: jest.fn(),
      listProjects: jest.fn(),
      deleteProject: jest.fn()
    } as any;

    mockEmbeddingService = {
      isEnabled: jest.fn(),
      generateEmbedding: jest.fn(),
      generateEmbeddings: jest.fn(),
      extractSemanticContent: jest.fn()
    } as any;

    manager = new SemanticSearchManager(mockNeo4jClient, mockEmbeddingService);
  });

  describe('Constructor', () => {
    it('should initialize with provided dependencies', () => {
      expect(manager).toBeInstanceOf(SemanticSearchManager);
    });

    it('should create default embedding service if not provided', () => {
      const managerWithoutService = new SemanticSearchManager(mockNeo4jClient);
      expect(managerWithoutService).toBeInstanceOf(SemanticSearchManager);
    });
  });

  describe('initializeVectorIndexes', () => {
    it('should skip initialization when embedding service is disabled', async () => {
      mockEmbeddingService.isEnabled.mockReturnValue(false);
      const consoleSpy = jest.spyOn(console, 'log').mockImplementation();

      await manager.initializeVectorIndexes();

      expect(consoleSpy).toHaveBeenCalledWith('Semantic search disabled, skipping vector index initialization');
      expect(mockNeo4jClient.runQuery).not.toHaveBeenCalled();

      consoleSpy.mockRestore();
    });

    it('should create vector index when embedding service is enabled', async () => {
      mockEmbeddingService.isEnabled.mockReturnValue(true);
      mockNeo4jClient.runQuery.mockResolvedValue({ records: [] });
      const consoleSpy = jest.spyOn(console, 'log').mockImplementation();

      await manager.initializeVectorIndexes();

      expect(mockNeo4jClient.runQuery).toHaveBeenCalledWith(
        expect.stringContaining('CREATE VECTOR INDEX semantic_embeddings'),
        expect.objectContaining({ dimensions: expect.any(Number) })
      );
      expect(consoleSpy).toHaveBeenCalledWith('Vector indexes initialized successfully');

      consoleSpy.mockRestore();
    });

    it('should handle initialization errors', async () => {
      mockEmbeddingService.isEnabled.mockReturnValue(true);
      const error = new Error('Database error');
      mockNeo4jClient.runQuery.mockRejectedValue(error);
      const consoleSpy = jest.spyOn(console, 'error').mockImplementation();

      await expect(manager.initializeVectorIndexes()).rejects.toThrow('Database error');
      expect(consoleSpy).toHaveBeenCalledWith('Failed to initialize vector indexes:', error);

      consoleSpy.mockRestore();
    });
  });

  describe('addEmbeddingToNode', () => {
    it('should successfully add embedding to node', async () => {
      mockNeo4jClient.runQuery.mockResolvedValue({ 
        records: [{ get: () => mockCodeNode }] 
      });

      await manager.addEmbeddingToNode('test-node', 'test-project', mockEmbedding);

      expect(mockNeo4jClient.runQuery).toHaveBeenCalledWith(
        expect.stringContaining('SET n.semantic_embedding'),
        expect.objectContaining({
          nodeId: 'test-node',
          projectId: 'test-project',
          vector: mockEmbedding.vector,
          model: mockEmbedding.model,
          version: mockEmbedding.version,
          createdAt: mockEmbedding.created_at.toISOString()
        })
      );
    });

    it('should throw error when node not found', async () => {
      mockNeo4jClient.runQuery.mockResolvedValue({ records: [] });

      await expect(
        manager.addEmbeddingToNode('missing-node', 'test-project', mockEmbedding)
      ).rejects.toThrow('Node not found: missing-node in project test-project');
    });
  });

  describe('semanticSearch', () => {
    const searchParams: SemanticSearchParams = {
      query: 'email validation functions',
      project_id: 'test-project',
      limit: 5,
      similarity_threshold: 0.7
    };

    it('should throw error when embedding service is disabled', async () => {
      mockEmbeddingService.isEnabled.mockReturnValue(false);

      await expect(manager.semanticSearch(searchParams)).rejects.toThrow('Semantic search is disabled');
    });

    it('should throw error when query embedding generation fails', async () => {
      mockEmbeddingService.isEnabled.mockReturnValue(true);
      mockEmbeddingService.generateEmbedding.mockResolvedValue(null);

      await expect(manager.semanticSearch(searchParams)).rejects.toThrow('Failed to generate embedding for query');
    });

    it('should perform successful semantic search', async () => {
      mockEmbeddingService.isEnabled.mockReturnValue(true);
      mockEmbeddingService.generateEmbedding.mockResolvedValue(mockEmbedding);
      mockEmbeddingService.extractSemanticContent.mockReturnValue('email validation function');

      const mockRecord = {
        get: jest.fn()
          .mockReturnValueOnce({ properties: mockCodeNode }) // for 'n'
          .mockReturnValueOnce(0.85) // for 'similarity'
      };

      mockNeo4jClient.runQuery.mockResolvedValue({
        records: [mockRecord]
      });

      const results = await manager.semanticSearch(searchParams);

      expect(results).toHaveLength(1);
      expect(results[0]).toEqual({
        node: mockCodeNode,
        similarity_score: 0.85,
        matched_content: 'email validation function'
      });

      expect(mockNeo4jClient.runQuery).toHaveBeenCalledWith(
        expect.stringContaining('vector.similarity.cosine'),
        expect.objectContaining({
          queryVector: mockEmbedding.vector,
          limit: 5,
          threshold: 0.7,
          projectId: 'test-project'
        })
      );
    });

    it('should handle search with node type filters', async () => {
      mockEmbeddingService.isEnabled.mockReturnValue(true);
      mockEmbeddingService.generateEmbedding.mockResolvedValue(mockEmbedding);
      mockNeo4jClient.runQuery.mockResolvedValue({ records: [] });

      const paramsWithFilter = {
        ...searchParams,
        node_types: ['function', 'method'] as any[]
      };

      await manager.semanticSearch(paramsWithFilter);

      expect(mockNeo4jClient.runQuery).toHaveBeenCalledWith(
        expect.stringContaining('AND n.type IN $nodeTypes'),
        expect.objectContaining({
          nodeTypes: ['function', 'method']
        })
      );
    });

    it('should handle search query errors', async () => {
      mockEmbeddingService.isEnabled.mockReturnValue(true);
      mockEmbeddingService.generateEmbedding.mockResolvedValue(mockEmbedding);
      mockNeo4jClient.runQuery.mockRejectedValue(new Error('Query failed'));
      const consoleSpy = jest.spyOn(console, 'error').mockImplementation();

      await expect(manager.semanticSearch(searchParams)).rejects.toThrow('Semantic search failed: Query failed');

      consoleSpy.mockRestore();
    });
  });

  describe('hybridSearch', () => {
    const searchParams: SemanticSearchParams = {
      query: 'user authentication',
      project_id: 'test-project'
    };

    it('should return semantic results when graph context disabled', async () => {
      mockEmbeddingService.isEnabled.mockReturnValue(true);
      mockEmbeddingService.generateEmbedding.mockResolvedValue(mockEmbedding);
      mockEmbeddingService.extractSemanticContent.mockReturnValue('user authentication');

      const mockRecord = {
        get: jest.fn()
          .mockReturnValueOnce({ properties: mockCodeNode })
          .mockReturnValueOnce(0.8)
      };

      mockNeo4jClient.runQuery.mockResolvedValue({ records: [mockRecord] });

      const results = await manager.hybridSearch(searchParams);

      expect(results).toHaveLength(1);
      expect(results[0].node).toEqual(mockCodeNode);
    });

    it('should enhance results with graph context when enabled', async () => {
      mockEmbeddingService.isEnabled.mockReturnValue(true);
      mockEmbeddingService.generateEmbedding.mockResolvedValue(mockEmbedding);
      mockEmbeddingService.extractSemanticContent.mockReturnValue('user authentication');

      // Mock semantic search result
      const semanticRecord = {
        get: jest.fn()
          .mockReturnValueOnce({ properties: mockCodeNode })
          .mockReturnValueOnce(0.8)
      };

      // Mock context query result
      const relatedNode = { ...mockCodeNode, id: 'related-node', name: 'UserService' };
      const contextRecord = {
        get: jest.fn().mockReturnValue({ properties: relatedNode })
      };

      mockNeo4jClient.runQuery
        .mockResolvedValueOnce({ records: [semanticRecord] }) // semantic search
        .mockResolvedValueOnce({ records: [contextRecord] }); // context query

      const results = await manager.hybridSearch(searchParams, {
        includeRelationships: true,
        maxHops: 2
      });

      expect(results).toHaveLength(1);
      expect(results[0].matched_content).toContain('Related: UserService (function)');
    });

    it('should handle context query failures gracefully', async () => {
      mockEmbeddingService.isEnabled.mockReturnValue(true);
      mockEmbeddingService.generateEmbedding.mockResolvedValue(mockEmbedding);
      mockEmbeddingService.extractSemanticContent.mockReturnValue('user authentication');

      const semanticRecord = {
        get: jest.fn()
          .mockReturnValueOnce({ properties: mockCodeNode })
          .mockReturnValueOnce(0.8)
      };

      mockNeo4jClient.runQuery
        .mockResolvedValueOnce({ records: [semanticRecord] })
        .mockRejectedValueOnce(new Error('Context query failed'));

      const consoleSpy = jest.spyOn(console, 'warn').mockImplementation();

      const results = await manager.hybridSearch(searchParams, {
        includeRelationships: true
      });

      expect(results).toHaveLength(1);
      expect(consoleSpy).toHaveBeenCalledWith(
        expect.stringContaining('Failed to get graph context'),
        expect.any(Error)
      );

      consoleSpy.mockRestore();
    });
  });

  describe('getSimilarNodes', () => {
    it('should find similar nodes successfully', async () => {
      const targetEmbedding = [0.1, 0.2, 0.3];
      
      // Mock target node query
      const targetRecord = {
        get: jest.fn()
          .mockReturnValueOnce(targetEmbedding) // embedding
          .mockReturnValueOnce({ properties: mockCodeNode }) // node
      };

      // Mock similar nodes query
      const similarNode = { ...mockCodeNode, id: 'similar-node', name: 'validatePhone' };
      const similarRecord = {
        get: jest.fn()
          .mockReturnValueOnce({ properties: similarNode })
          .mockReturnValueOnce(0.75)
      };

      mockNeo4jClient.runQuery
        .mockResolvedValueOnce({ records: [targetRecord] }) // target node
        .mockResolvedValueOnce({ records: [similarRecord] }); // similar nodes

      mockEmbeddingService.extractSemanticContent.mockReturnValue('phone validation');

      const results = await manager.getSimilarNodes('test-node', 'test-project', 5);

      expect(results).toHaveLength(1);
      expect(results[0]).toEqual({
        node: similarNode,
        similarity_score: 0.75,
        matched_content: 'phone validation'
      });
    });

    it('should throw error when target node not found', async () => {
      mockNeo4jClient.runQuery.mockResolvedValue({ records: [] });

      await expect(
        manager.getSimilarNodes('missing-node', 'test-project')
      ).rejects.toThrow('Node not found or has no embedding: missing-node');
    });
  });

  describe('updateEmbeddings', () => {
    it('should throw error when embedding service is disabled', async () => {
      mockEmbeddingService.isEnabled.mockReturnValue(false);

      await expect(manager.updateEmbeddings()).rejects.toThrow('Semantic search is disabled');
    });

    it('should successfully update embeddings for nodes', async () => {
      mockEmbeddingService.isEnabled.mockReturnValue(true);

      // Mock nodes query
      const nodeRecord = {
        get: jest.fn().mockReturnValue({ properties: mockCodeNode })
      };
      mockNeo4jClient.runQuery.mockResolvedValue({ records: [nodeRecord] });

      // Mock embedding generation
      mockEmbeddingService.extractSemanticContent.mockReturnValue('email validation');
      mockEmbeddingService.generateEmbeddings.mockResolvedValue([mockEmbedding]);

      // Mock successful embedding storage
      const addEmbeddingSpy = jest.spyOn(manager, 'addEmbeddingToNode').mockResolvedValue();

      const result = await manager.updateEmbeddings('test-project', ['function']);

      expect(result.updated).toBe(1);
      expect(result.failed).toBe(0);
      expect(addEmbeddingSpy).toHaveBeenCalledWith('test-node', 'test-project', mockEmbedding);

      addEmbeddingSpy.mockRestore();
    });

    it('should handle embedding generation failures', async () => {
      mockEmbeddingService.isEnabled.mockReturnValue(true);

      const nodeRecord = {
        get: jest.fn().mockReturnValue({ properties: mockCodeNode })
      };
      mockNeo4jClient.runQuery.mockResolvedValue({ records: [nodeRecord] });

      mockEmbeddingService.extractSemanticContent.mockReturnValue('email validation');
      mockEmbeddingService.generateEmbeddings.mockResolvedValue([null]); // Failed generation

      const result = await manager.updateEmbeddings();

      expect(result.updated).toBe(0);
      expect(result.failed).toBe(1);
    });

    it('should handle embedding storage failures', async () => {
      mockEmbeddingService.isEnabled.mockReturnValue(true);

      const nodeRecord = {
        get: jest.fn().mockReturnValue({ properties: mockCodeNode })
      };
      mockNeo4jClient.runQuery.mockResolvedValue({ records: [nodeRecord] });

      mockEmbeddingService.extractSemanticContent.mockReturnValue('email validation');
      mockEmbeddingService.generateEmbeddings.mockResolvedValue([mockEmbedding]);

      // Mock embedding storage failure
      const addEmbeddingSpy = jest.spyOn(manager, 'addEmbeddingToNode')
        .mockRejectedValue(new Error('Storage failed'));
      const consoleSpy = jest.spyOn(console, 'error').mockImplementation();

      const result = await manager.updateEmbeddings();

      expect(result.updated).toBe(0);
      expect(result.failed).toBe(1);

      addEmbeddingSpy.mockRestore();
      consoleSpy.mockRestore();
    });

    it('should handle batch processing errors', async () => {
      mockEmbeddingService.isEnabled.mockReturnValue(true);

      const nodeRecord = {
        get: jest.fn().mockReturnValue({ properties: mockCodeNode })
      };
      mockNeo4jClient.runQuery.mockResolvedValue({ records: [nodeRecord] });

      mockEmbeddingService.extractSemanticContent.mockReturnValue('email validation');
      mockEmbeddingService.generateEmbeddings.mockRejectedValue(new Error('Batch failed'));

      const consoleSpy = jest.spyOn(console, 'error').mockImplementation();

      const result = await manager.updateEmbeddings();

      expect(result.updated).toBe(0);
      expect(result.failed).toBe(1);

      consoleSpy.mockRestore();
    });
  });

  describe('neo4jRecordToCodeNode', () => {
    it('should convert Neo4j record to CodeNode correctly', () => {
      const record = {
        properties: {
          id: 'test-id',
          project_id: 'test-project',
          type: 'function',
          name: 'testFunction',
          qualified_name: 'utils.testFunction',
          description: 'A test function',
          source_file: 'utils.ts',
          start_line: '10',
          end_line: '20',
          modifiers: ['public'],
          attributes: '{"return_type": "string"}'
        }
      };

      // Access private method for testing
      const result = (manager as any).neo4jRecordToCodeNode(record);

      expect(result).toEqual({
        id: 'test-id',
        project_id: 'test-project',
        type: 'function',
        name: 'testFunction',
        qualified_name: 'utils.testFunction',
        description: 'A test function',
        source_file: 'utils.ts',
        start_line: 10,
        end_line: 20,
        modifiers: ['public'],
        attributes: { return_type: 'string' }
      });
    });

    it('should handle missing optional properties', () => {
      const record = {
        properties: {
          id: 'test-id',
          project_id: 'test-project',
          type: 'function',
          name: 'testFunction',
          qualified_name: 'utils.testFunction'
        }
      };

      const result = (manager as any).neo4jRecordToCodeNode(record);

      expect(result).toEqual({
        id: 'test-id',
        project_id: 'test-project',
        type: 'function',
        name: 'testFunction',
        qualified_name: 'utils.testFunction',
        description: undefined,
        source_file: undefined,
        start_line: undefined,
        end_line: undefined,
        modifiers: undefined,
        attributes: undefined
      });
    });
  });
});

