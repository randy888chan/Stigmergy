import fs from "fs-extra";
import path from "path";
import yaml from "js-yaml";
import coreBackup from "../../services/core_backup.js";
import { validateAgents } from "./validate.js";
import { fileURLToPath } from "url";
import chalk from "chalk";

export async function configureIde(
  coreSourceDir,
  outputPath = path.join(process.cwd(), ".roomodes")
) {
  console.log("Configuring IDE...");
  const PORT = process.env.PORT || 3000;
  const ENGINE_URL = `http://localhost:${PORT}`;
  const ALLOWED_ROO_GROUPS = new Set(["read", "edit", "command", "browser"]);

  const manifestPath = path.join(coreSourceDir, "system_docs", "02_Agent_Manifest.md");
  const manifestContent = await fs.readFile(manifestPath, "utf8");
  const manifestYamlMatch = manifestContent.match(/```(?:yaml|yml)\n([\s\S]*?)\s*```/);
  const manifest = yaml.load(manifestYamlMatch[1]);

  const customModes = [];
  const agentsDir = path.join(coreSourceDir, "agents");

  for (const agent of manifest.agents) {
    const agentId = agent.id;
    const agentPath = path.join(agentsDir, `${agentId}.md`);
    if (!(await fs.pathExists(agentPath))) {
      console.warn(`Skipping agent ${agentId}: No definition file found.`);
      continue;
    }

    const rawAgentDefinition = await fs.readFile(agentPath, "utf8");
    const yamlMatch = rawAgentDefinition.match(/```(?:yaml|yml)\n([\s\S]*?)\s*```/);
    if (!yamlMatch || !yamlMatch[1]) {
      console.warn(`Skipping agent ${agentId}: No YAML block found.`);
      continue;
    }

    try {
      // With the corrected data structure, we only need to parse once.
      const agentData = yaml.load(yamlMatch[1]);
      const agentConfig = agentData.agent;

      const slug = (
        agentConfig.alias.startsWith("@") ? agentConfig.alias.substring(1) : agentConfig.alias
      ).replace(/[^a-zA-Z0-9-]/g, "-");

      // Now all persona info and protocols are in one place: agentConfig
      let roleDefString = agentConfig.persona.role || `Agent: ${agentConfig.name}`;
      if (agentConfig.persona.style) {
        roleDefString += `\nStyle: ${agentConfig.persona.style}`;
      }
      if (agentConfig.persona.identity) {
        roleDefString += `\n\nIdentity: ${agentConfig.persona.identity}`;
      }
      // This will now work correctly because core_protocols is part of agentConfig
      if (agentConfig.core_protocols && agentConfig.core_protocols.length > 0) {
        roleDefString +=
          `\n\nCore Protocols:\n` + agentConfig.core_protocols.map((p) => `- ${p}`).join("\n");
      }

      const tools = agentConfig.tools || [];
      const finalGroups = tools.filter((tool) => ALLOWED_ROO_GROUPS.has(tool));
      const hasMcpTool = tools.includes("mcp");
      const source = hasMcpTool ? agentConfig.source || "project" : null;
      const finalSource = source === "execution" ? "project" : source;

      const mode = {
        slug: slug,
        name: `${agentConfig.icon || "ü§ñ"} ${agentConfig.name}`,
        roleDefinition: roleDefString,
        groups: finalGroups,
        api: {
          url: `${ENGINE_URL}/api/chat`,
          method: "POST",
          include: ["history"],
          static_payload: {
            agentId: agentConfig.id,
            model: agentConfig.preferred_model || undefined,
          },
        },
      };

      if (finalSource) {
        mode.source = finalSource;
      }

      customModes.push(mode);
    } catch (error) {
      console.error(`Error processing agent ${agentId}: ${error.message}`);
    }
  }

  customModes.unshift(
    {
      slug: "system-resume",
      name: "‚ñ∂Ô∏è Resume Engine",
      roleDefinition: "Resume the autonomous engine.",
      api: { url: `${ENGINE_URL}/api/control/resume`, method: "POST" },
      groups: ["command"],
    },
    {
      slug: "system-pause",
      name: "‚è∏Ô∏è Pause Engine",
      roleDefinition: "Pause the autonomous engine.",
      api: { url: `${ENGINE_URL}/api/control/pause`, method: "POST" },
      groups: ["command"],
    }
  );

  customModes.sort((a, b) => a.name.localeCompare(b.name));

  const yamlOutput = yaml.dump({ customModes: customModes }, { lineWidth: -1 });
  const fileContent = `# This file is auto-generated by 'stigmergy install'.\n\n${yamlOutput}`;
  await fs.writeFile(outputPath, fileContent, "utf8");
}

async function install() {
  try {
    const targetDir = process.cwd();
    const targetCoreDir = path.join(targetDir, ".stigmergy-core");
    const targetEnvFile = path.join(targetDir, "stigmergy.env.example");

    const __dirname = path.dirname(fileURLToPath(import.meta.url));
    const sourceCoreDir = path.resolve(__dirname, "../../.stigmergy-core");
    const sourceEnvFile = path.resolve(__dirname, "../../.env.example");

    if (!fs.existsSync(sourceCoreDir) || !fs.existsSync(sourceEnvFile)) {
      console.error(
        "‚ùå CRITICAL: Source files (.stigmergy-core or .env.example) not found in the Stigmergy package."
      );
      return false;
    }

    if (fs.existsSync(targetCoreDir)) {
      console.log(
        "‚úÖ .stigmergy-core already exists in your project. Preserving your existing configuration."
      );
    } else {
      console.log("Installing .stigmergy-core into your project...");
      await fs.copy(sourceCoreDir, targetCoreDir);
      console.log("‚úÖ .stigmergy-core installed successfully.");
    }

    if (fs.existsSync(targetEnvFile)) {
      console.log("‚úÖ Stigmergy configuration file (stigmergy.env.example) already exists.");
    } else {
      console.log("Creating Stigmergy configuration template...");
      await fs.copy(sourceEnvFile, targetEnvFile);
      console.log("‚úÖ Created 'stigmergy.env.example'.");
      console.log(
        chalk.yellow(
          "--> ACTION REQUIRED: Please copy the variables from 'stigmergy.env.example' into your main '.env' file when you are ready."
        )
      );
    }

    const agentsValid = await validateAgents(targetCoreDir);
    if (!agentsValid.success) {
      console.error(
        "‚ùå Agent validation failed. Please check the definitions in your new .stigmergy-core folder."
      );
      return false;
    }

    await configureIde(targetCoreDir);
    console.log(`‚úÖ Setup complete. Your project is now configured to use Stigmergy.`);
    return true;
  } catch (error) {
    console.error("‚ùå An unexpected error occurred during installation:", error);
    return false;
  }
}

export { install };
